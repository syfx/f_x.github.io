<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="fx"><meta name="copyright" content="fx"><title>懂得越多，为难得越少 | fx's study notes</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">fx</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">21</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">14</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">fx's study notes</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">fx's study notes</div><div id="site-sub-title">懂得越多，为难得越少</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/18/设计模式之工厂模式/">设计模式之工厂模式</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-18</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/设计模式/">设计模式</a></span><div class="content"><h2 id="设计模式之工厂模式-Factory-Pattern"><a href="#设计模式之工厂模式-Factory-Pattern" class="headerlink" title="设计模式之工厂模式(Factory Pattern)"></a>设计模式之工厂模式(Factory Pattern)</h2><blockquote>
<p>工厂模式是最常用的设计模式之一，它属于创建型设计模式；工厂模式 <strong>提供了一种创建对象的最好方式</strong> （如果你有更好的方式就当我没说）；它的主要作用是让对象的创建与对象的使用分离开来，即使用单独的类来<strong> 封装创建实例的逻辑。</strong><br>工厂模式又可以细分为：   </p>
<ul>
<li>简单工厂模式   </li>
<li>工厂方法模式   </li>
<li>抽象工厂模式   </li>
</ul>
</blockquote>
<h3 id="1、简单工厂模式-Simple-Factory-Pattern"><a href="#1、简单工厂模式-Simple-Factory-Pattern" class="headerlink" title="1、简单工厂模式(Simple Factory Pattern)"></a>1、简单工厂模式(Simple Factory Pattern)</h3><blockquote>
<p>又称为静态工厂方法(Static Factory Method)模式；在简单工厂模式中，通常包含一个静态方法，可以根据参数的不同返回不同类的实例。<br>简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。   </p>
</blockquote>
<ul>
<li>简单工厂模式包含以下几种角色：   <ul>
<li>工厂：负责创建所有具体产品类的实例，工厂类中的静态方法要能够被其它类直接在外界调用，以获得产品对象。   </li>
<li>抽象产品类：是所有具体产品的父类，负责定义其它具体产品的所共有的公共接口（子类共有的行为）   </li>
<li>具体产品类：继承自抽象产品类，是工厂角色的创建目标。   </li>
</ul>
</li>
</ul>
<blockquote>
<blockquote>
<p>如果上面说的不好理解的话，那就来个栗子消化一下吧。   </p>
</blockquote>
<p>在一个游戏中，有三种小怪： <strong>MobA</strong> 、<strong>MobB</strong> 、<strong>Mobc</strong> ;<br>在游戏中，他们都可以攻击主角。这时候，我们就可以使用简单工厂模式来控制它们的 出场（实例生成）。   </p>
</blockquote>
<hr>
<blockquote>
<p>首先，我们应该创建一个抽象怪物类 <strong>Mob</strong> ，让上面那三个小怪类继承自Mob。然后用Mob当做工厂中静态方法的返回对象。<br>不太懂得话，就看看代码吧（c#）：</p>
</blockquote>
<pre><code>namespace FactoryPattern
{
    //怪物工厂
    class MobFactory
    {
        //获取对象实例的静态方法
        public static Mob GetMob(string mobName)
        {
            switch (mobName) {
                case &quot;MobA&quot;: return new MobA();
                case &quot;MobB&quot;: return new MobB();
                case &quot;MobC&quot;: return new MobC();
                default: return null;
            }
        }
    }

    ////使用接口实现抽象类会更好
    //interface I_Mob
    //{
    //    //定义攻击接口（规定每个继承自此抽象类的怪物都能进行攻击）
    //    void Attack();
    //}

    //抽象怪物类
    abstract class Mob
    {
        //定义攻击接口（规定每个继承自此抽象类的怪物都能进行攻击）
        public abstract void Attack(); 
    }
    //小怪A
    class MobA : Mob
    {
        //重写Acctak方法
        public override void Attack()
        {
            Console.WriteLine(&quot;MobA 进行攻击&quot;);
        }
    }
    //小怪B
    class MobB : Mob
    {
        //重写Acctak方法
        public override void Attack()
        {
            Console.WriteLine(&quot;MobB 进行攻击&quot;);
        }
    }
    //小怪C
    class MobC : Mob
    {
        //重写Acctak方法
        public override void Attack()
        {
            Console.WriteLine(&quot;MobC 进行攻击&quot;);
        }
    }

    class Test
    {
        static void Main(string[] args)
        {
            Mob mob = MobFactory.GetMob(&quot;MobA&quot;);
            mob.Attack();                                           //MobA进行攻击
            mob = MobFactory.GetMob(&quot;MobB&quot;);
            mob.Attack();                                           //MobB进行攻击

            Console.ReadKey();
        }
    }
}
</code></pre><p><strong>简单工厂模式分析</strong>    </p>
<blockquote>
<ul>
<li>将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。    </li>
<li>对于简单工厂模式，由于其方法是静态的，因此使用起来比较方便。   </li>
<li>简单工厂模式虽然满足单一职则原则，不过工厂类的职责相对过重，而且增加新的产品时需要修改工厂类的判断逻辑，不符合开闭原则。</li>
</ul>
</blockquote>
<p> <strong>模式优缺点及使用场景</strong>   </p>
<ul>
<li><p>优点   </p>
<blockquote>
<ul>
<li>简单工厂模式实现了对责任的分割，它提供了专门的工厂类用于创建对象，降低系统的耦合度。    </li>
<li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可。   </li>
</ul>
</blockquote>
</li>
<li><p>缺点</p>
<blockquote>
<ul>
<li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。   </li>
<li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。   </li>
<li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。   </li>
<li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。   </li>
</ul>
</blockquote>
</li>
<li><p>使用场景   </p>
<blockquote>
<p>当需要创建的对象较少且以后基本上不要增加新的对象时，用这个工厂方式还是不错的。</p>
</blockquote>
</li>
</ul>
<h3 id="2、工厂方法模式-Factory-Pattern"><a href="#2、工厂方法模式-Factory-Pattern" class="headerlink" title="2、工厂方法模式(Factory Pattern)"></a>2、工厂方法模式(Factory Pattern)</h3><blockquote>
<p>又被称多态性工厂模式。在这个模式中，不再使用一个类创建所有的产品实例，而是实现一个抽象的工厂父类角色，然后为每个产品都实现一个具体的工厂子类，抽象工厂父类角色，仅负责给出具体工厂子类必须实现的接口，而具体的创建对象的逻辑在子类中实现。   </p>
</blockquote>
<ul>
<li>工厂方法模式包含的角色：   <ul>
<li>抽象工厂类：所有具体工厂的父类，规定工厂子类应实现哪些接口。   </li>
<li>具体工厂类：继承自抽象工厂类，用于创建一个特定的产品。   </li>
<li>抽象产品类：所有具体产品的父类，负责定义其它具体产品的所共有的公共接口    </li>
<li>具体产品类：继承自抽象产品类，是具体工厂类角色的创建目标。    </li>
</ul>
</li>
</ul>
<blockquote>
<p>根据上述例子实现的具体代码为：</p>
</blockquote>
<pre><code>namespace FactoryPattern
{
    //怪物接口
    interface Mob
    {
        void Attack();
    }
    //小怪A
    class MobA : Mob
    {
        //重写Acctak方法
        public void Attack()
        {
            Console.WriteLine(&quot;MobA 进行攻击&quot;);
        }
    }
    //小怪B
    class MobB : Mob
    {
        //重写Acctak方法
        public void Attack()
        {
            Console.WriteLine(&quot;MobB 进行攻击&quot;);
        }
    }
    //小怪C
    class MobC : Mob
    {
        //重写Acctak方法
        public void Attack()
        {
            Console.WriteLine(&quot;MobC 进行攻击&quot;);
        }
    }

    //抽象工厂接口
    interface Factory
    {
        Mob GetMob();
    }
    //创建怪物A的工厂
    class MobA_Factory : Factory
    {
        public Mob GetMob()
        {
            return new MobA();
        }
    }
    //创建怪物B的工厂
    class MobB_Factory : Factory
    {
        public Mob GetMob()
        {
            return new MobB();
        }
    }
    //创建怪物C的工厂
    class MobC_Factory : Factory
    {
        public Mob GetMob()
        {
            return new MobC();
        }
    }

    class Test
    {
        static void Main(string[] args)
        {
            //获得小怪A
            Factory factory = new MobA_Factory();
            Mob mob = factory.GetMob();
            mob.Attack();
            //获得小怪B
            factory = new MobB_Factory();
            mob = factory.GetMob();
            mob.Attack();
            Console.ReadKey();
        }
    }
}
</code></pre><p><strong>工厂方法模式分析</strong>   </p>
<blockquote>
<p>在这个模式中，将每个具体产品的创建细节分配给每个具体的工厂来实现，这样做不仅使工厂方法具有简单工厂方法的优点，还解决了简单工厂模式职责过重的问题。不过由于每个产品类都要对应一个工厂类，因此使用此模式时，会在一定程度上增加系统的复杂性。</p>
</blockquote>
<p><strong>优点</strong>     </p>
<blockquote>
<p>工厂方法模式除了具有简单工厂模式的优点外，还具有以下优点：   </p>
</blockquote>
<ul>
<li>进一步的细化了工厂类的职责，真正的实现了在创建实例这块的高内聚、低耦合。   </li>
<li>当一个工厂出现问题时不会影响到其他工厂，提高了程序的健壮性。   </li>
<li>提高了程序的灵活性，当新添加一个产品时，只需添加一个产品类和相应产品的工厂类即可。   </li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>要为每个产品类创建具体工厂，增加了代码量。（个人感觉有其优点相比，这点缺点可以忽略了）</li>
</ul>
<p><strong>应用场景</strong> </p>
<h4 id="产品等级结构与产品族"><a href="#产品等级结构与产品族" class="headerlink" title="产品等级结构与产品族"></a>产品等级结构与产品族</h4><blockquote>
<ul>
<li>产品等级结构：即产品的继承结构，如在上面所用到的例子中，抽象怪物类Mob与小怪MobA、小怪MobB、小怪MobC之间便构成了一个产品等级结构，抽象怪物类是父类，而不同种类的小怪是其子类。   </li>
<li>产品族：在抽象工厂模式中会提到，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。</li>
</ul>
</blockquote>
<p><img src="http://p.qpic.cn/pic_wework/1948211503/f6f018f9ede8d36a07519fb4fbff98f0bf32c401b7f50c90/0" alt=""></p>
<h3 id="3、抽象工厂模式"><a href="#3、抽象工厂模式" class="headerlink" title="3、抽象工厂模式"></a>3、抽象工厂模式</h3><blockquote>
<p>抽象工厂模式是当有多个抽象产品时所使用的一种工厂模式。它和工厂方法模式很像，可以把工厂方法模式当成是产品族为1时的抽象工厂模式。   </p>
</blockquote>
<ul>
<li>抽象工厂模式包含的角色：   <ul>
<li>抽象工厂类：所有具体工厂的父类，实现对具体工厂的规范。   </li>
<li>具体工厂类：继承自抽象工厂类，用于创建某个产品族中的的产具体产品。   </li>
<li>抽象产品类：所有具体产品的父类，负责定义其它具体产品的所共有的公共接口    </li>
<li>具体产品类：继承自抽象产品类，是具体工厂类角色的创建目标之一。   </li>
</ul>
</li>
</ul>
<blockquote>
<p>修改一下上面那个例子，除了怪物类外，现在还要新添加一个武器类，武器类中包括武器WpA、WpB、WpC；怪物MobA使用WpA，怪物MobB使用WpB，怪物MobC使用WpC；<br>使用抽象工厂模式实现怪物和武器生成的代码如下：   </p>
</blockquote>
<pre><code>//怪物接口
interface Mob
{
    void Attack();
}
//小怪A
class MobA : Mob
{
    //重写Acctak方法
    public void Attack()
    {
        Console.WriteLine(&quot;MobA 进行攻击&quot;);
    }
}
//小怪B
class MobB : Mob
{
    //重写Acctak方法
    public void Attack()
    {
        Console.WriteLine(&quot;MobB 进行攻击&quot;);
    }
}
//小怪C
class MobC : Mob
{
    //重写Acctak方法
    public void Attack()
    {
        Console.WriteLine(&quot;MobC 进行攻击&quot;);
    }
}

//武器接口
interface Wp
{
    //攻击加成
    void AtkAdd();
}
//武器WpA
class WpA : Wp
{
    public void AtkAdd()
    {
        Console.WriteLine(&quot;MobA专属武器，MobA提高了攻击力&quot;);
    }
}
//武器WpA
class WpB : Wp
{
    public void AtkAdd()
    {
        Console.WriteLine(&quot;MobB专属武器，MobB提高了攻击力&quot;);
    }
}
//武器WpC
class WpC : Wp
{
    public void AtkAdd()
    {
        Console.WriteLine(&quot;MobC专属武器，MobC提高了攻击力&quot;);
    }
}

//工厂接口
interface Factory
{
    //获取怪物实例的方法
    Mob GetMob();
    //获取武器实例的方法
    Wp GetWp();
}

//A类怪物武器产品族工厂
class A_Factory : Factory
{
    //获取怪物实例的方法
    public Mob GetMob() {
        return new MobA();
    }
    //获取武器实例的方法
    public Wp GetWp()
    {
        return new WpA();
    }
}

//A类怪物武器产品族工厂
class B_Factory : Factory
{
    //获取怪物实例的方法
    public Mob GetMob()
    {
        return new MobB();
    }
    //获取武器实例的方法
    public Wp GetWp()
    {
        return new WpB();
    }
}

//A类怪物武器产品族工厂
class C_Factory : Factory
{
    //获取怪物实例的方法
    public Mob GetMob()
    {
        return new MobC();
    }
    //获取武器实例的方法
    public Wp GetWp()
    {
        return new WpC();
    }
}


class Test
{
    static void Main(string[] args)
    {
        //A类产品族工厂
        Factory factory = new A_Factory();
        Mob moba = factory.GetMob();
        Wp wpa = factory.GetWp();
        wpa.AtkAdd();
        moba.Attack();

        //B类产品族工厂
        factory = new C_Factory();
        Mob mobb = factory.GetMob();
        Wp wpb = factory.GetWp();
        wpb.AtkAdd();
        mobb.Attack();

        Console.ReadKey();
    }
}
</code></pre><p> <strong>抽象工厂模式分析</strong>   </p>
<blockquote>
<p>抽象工厂模式符合单一职责原则、开闭原则、里氏替换原则、依赖倒置原则。它为具有多个产品结构的程序提供了一种获得产品实例的方法。</p>
</blockquote>
<p><strong>抽象工厂的优缺点</strong> </p>
<ul>
<li>优点：   </li>
<li><p>工厂方法模式除了具有简单工厂模式的优点外，还具有以下优点：   </p>
<ul>
<li>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</li>
<li>增加新的产品族时很方便，只需添加生产相应产品族实例的工厂即可，无须修改已有系统。</li>
</ul>
</li>
<li><p>缺点：   </p>
<ul>
<li>当增加新的产品等级结构时，需要对抽象工厂和具体工厂类进行修改，不符合开闭原则。   </li>
</ul>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/17/STL-map和multimap/">STL-map和multimap</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-17</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/C/">C++</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/STL/">STL</a></span><div class="content"><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote>
<p>map与multimap是键值对容器，支持根据键查找值。multimap可以储存重复的键，而前者只能储存唯一的键。使用两者之前要包含时头文件<map><br>为实现快速查找，map与multimap的内部结构看起来像二叉树，这意味着在map或multimap中插入数据时将对其进行排序；因此，位于map中特定位置的元素不能替换为值不同的新元素。   </map></p>
</blockquote>
<p><strong>map及multimap的实例化</strong>   </p>
<ul>
<li><p>实例化map和multimap的语法如下：   </p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
...
map&lt;keyType, valueType, Predicate = std::less&lt;keyType&gt;&gt; mapObject;
multimap&lt;keyType, valueType, Predicate = std::less&lt;keyType&gt;&gt; multimapObject;
</code></pre><blockquote>
<p>其中Predicate可图换为自定义谓词———一个实现了operator()的类或结构。例：</p>
</blockquote>
<pre><code>//实现从大到小排序的谓词
template&lt;typename KeyType&gt;
struct ReverseSort
{
    bool operator()(const KeyType&amp; key1, const KeyType&amp; key2)
    {
        return (key1 &gt; key2);
    }
}      
</code></pre><p><strong>插入元素</strong></p>
<blockquote>
<p>在两种容器之中插入元素时，都可以使用成员函数insert:<br><code>map&lt;int, string&gt; mapInt_String</code><br><code>mapInt_String.insert(make_pair(0, &quot;Number One&quot;));</code><br><code>mapInt_String.insert(pair&lt;int, string&gt;(2, &quot;Number Two&quot;));</code>      </p>
</blockquote>
</li>
<li><strong>std::pair</strong><br>主要作用是将两个数据组合成一个数据，两个数据可以是同一类型或者不同类型。<br>pair实质上是一个结构体，其主要的两个成员变量是<strong>first</strong>和<strong>second</strong>，这两个变量可以直接使用。<br>初始化一个pair可以使用构造函数，也可以使用std::make_pair函数。<br>make_pair函数的定义如下：<br>  <code>template pair make_pair(T1 a, T2 b) { return pair(a, b); }</code><br>在需要pair类型做参数的位置，可以直接调用make_pair生成pair对象。<br>mark_pair可以接受隐式的类型转换，这样可以获得更高的灵活度。但是这样会出现如下问题：<br>例如有如下两个定义：   <pre><code>```std::pair&lt;int, float&gt;(1, 1.1);```   
```std::make_pair(1, 1.1);```   
</code></pre>使用构造函数生成的pair对象的second变量是float类型，而用make_pair生成的pair对象的second变量将是double类型。   </li>
</ul>
<p><strong>查找元素</strong></p>
<blockquote>
<p>可使用成员方法find在这两个容器中查找元素。find返回一个迭代器：<br><code>auto iPairFind = mapInt_String.find(key);</code><br>使用迭代器iPairFind之前，要检查该迭代器：<br><code>if(iPairFind != mapInt_String.end())</code>   </p>
<ul>
<li>注意：<br>在multimap中，因为key值不唯一，因此在使用find查找元素时，返回的迭代器指向首次查找得到的元素。如果想得到所有值，应该使用multimap::count()确定有多少值与指定的key对应。   </li>
</ul>
</blockquote>
<p><strong>删除元素</strong>   </p>
<blockquote>
<p>使用成员函数erase对来删除元素。   </p>
<ul>
<li>通过指定的key来删除元素：<br><code>mapObject.erase(key);</code>   </li>
<li>删除迭代器指向的元素：<br><code>mapObject.erase(iElement);</code>      </li>
<li>使用迭代器指定边界，删除指定范围内的所有元素：<br><code>mapObject.erase(iLowBound, iUpperBound);</code>   </li>
</ul>
</blockquote>
<p><strong>std::unordered_map与std::unordered_multimap</strong>   </p>
<blockquote>
<p>从C++11起，STL支持散列映射——std::unordered_map,使用时需包含头文件&lt;unordered_map&gt;<br>unordered_map的的平均插入和删除时间是固定的，查找元素的时间也是固定的。</p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/17/OpenGL简介及其环境配置/">OpenGL简介及其环境配置</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-17</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/OpenGL/">OpenGL</a></span><div class="content"><h3 id="涉及内容简介"><a href="#涉及内容简介" class="headerlink" title="涉及内容简介"></a>涉及内容简介</h3><blockquote>
<p><strong>OpenGL</strong><br>一般它被认为是一个API(Application Programming Interface, 应用程序编程接口)，包含了一系列可以操作图形、图像的函数。然而，OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范。具体的实现是由驱动开发商针对特定显卡实现的。<br><strong>GLFW(Graphics Library Framework)</strong><br>GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。可认为是符合OpenGL规范的具体的库。<br><strong>GLAD</strong><br>由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。所以任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。<br>GLAD用来帮助开发者解决这个问题。（不用自己手动编写代码查询函数了）</p>
</blockquote>
<blockquote>
<blockquote>
<p>渲染（render）：它表示计算机从模型创建最终图像的过程。   </p>
</blockquote>
</blockquote>
<h3 id="编译环境配置"><a href="#编译环境配置" class="headerlink" title="编译环境配置"></a>编译环境配置</h3><blockquote>
<p>GLFW只是实现了OpenGL规范的具体库中的一个，其他比较流行的还有GLUT，SDL，SFML；<br>我选择使用GLFW。   </p>
</blockquote>
<ul>
<li><p>下载GLFW源文件：<a href="http://www.glfw.org/download.html" target="_blank" rel="noopener">官网（需翻墙）</a><br>打开后点击<strong>Source Package</strong>按钮进行下载。</p>
</li>
<li><p>下载cMake：<a href="https://cmake.org/download/" target="_blank" rel="noopener">官网（需翻墙）</a><br>打开后选择32位的下载就行。 下载按钮长这样 <code>cmake-3.14.0-win32-x86.zip</code></p>
</li>
</ul>
<blockquote>
<p>cMake: CMake是一个工程文件生成工具。用户可以使用预定义好的CMake脚本，根据自己的选择（像是Visual Studio, Code::Blocks, Eclipse）生成不同IDE的工程文件。</p>
</blockquote>
<p>1、下载好cMake并安装成功后，打开cMake；点击<strong>Browsere Source…</strong>按钮选择glfw压缩包解压后的整个文件夹    </p>
<p>2、点击 <strong>Browsere Build…</strong> 选择一个文件夹（最好新建一个空的）来存放编译后的文件。  </p>
<p>3、点击 <strong>Configure</strong> (设置)按钮。选择工程的生成器，由于我们使用的是Visual Studio 2015，我们选择 Visual Studio 14 选项（因为Visual Studio 2015的内部版本号是14）。 </p>
<p>4、点击 <strong>Finish</strong> (完成)按钮保存设置。保存之后，点击Generate(生成)按钮，生成的工程文件会在你第二步选择的文件夹中（假设这个文件夹名为build）。   </p>
<p>5、在build文件夹中点击 <strong>GLFW.sln</strong> 打开项目，然后对其进行编译。   </p>
<p>6、编译通过后在bulid/src/Debug文件夹中找到库 <strong>glfw3.lib</strong> （注意我们用的是第3版）</p>
<p>7、推荐建立一个新的目录包含所有的第三方库文件和头文件，每次新建一个工程时都需要指定这些文件夹。<strong>可以使用一个单独的文件夹，里面包含libs和include文件夹，在这里存放OpenGL工程用到的所有第三方库和头文件。</strong>将第6步的库 <strong>glfw3.lib</strong> 放到libs文件夹下。</p>
<ul>
<li>打开GLAD:<a href="http://glad.dav1d.de/" target="_blank" rel="noopener">官网（再翻次吧）</a>   </li>
</ul>
<p>GLAD是在线服务，将语言(Language)设置为C/C++，在API选项中，选择3.3以上的OpenGL(gl)版本（我们的教程中将使用3.3版本，但更新的版本也能正常工作）。之后将模式(Profile)设置为Core，并且保证生成加载器(Generate a loader)的选项是选中的。现在可以先（暂时）忽略拓展(Extensions)中的内容。都选择完之后，点击生成(Generate)按钮来生成库文件。<br>GLAD现在应该提供给你了一个zip压缩文件，包含两个头文件目录，和一个glad.c文件。将两个头文件目录（glad和KHR）复制到你的 <strong>include</strong> 文件夹中，可以将glad.c文件储存到你的include文件夹下（便于寻找）。</p>
<blockquote>
<p>经过上面的操作我们已经得到了OpenGL工程中所需要的库和头文件了（bulid文件夹下的所有东西，一定要保存好）；接下来开始配置开发环境吧。</p>
<blockquote>
<p>使用VS创建一个Visual C++ 常规空项目。<br>打开 <strong>解决方案资源管理器</strong> 在项目名称上点击右键——&gt;属性，然后在配置属性下选择VC++目录，编辑 <strong>包含目录</strong> 和 <strong>库目录</strong> 分别选择我们的 <strong>build</strong> 文件夹中的 <strong>include</strong> 目录和 <strong>libs</strong> 目录。     </p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在配置属性下选择链接器——&gt;输入，编辑附加依赖项，输入格式为：opengl32.lib 回车 glfw3.lib 然后点击确定按钮。</p>
</blockquote>
</blockquote>
<blockquote>
<p>在配置属性页面确定修改后，环境配置便结束了。在当前项目中新建一个.cpp文件，将下面的代码复制过去，若果能编译且运行成功的话，恭喜你，OK了。</p>
</blockquote>
<pre><code>#include &lt;glad/glad.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#include &lt;iostream&gt;

using namespace std;

void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void processInput(GLFWwindow* window);

int main()
{
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    GLFWwindow* window = glfwCreateWindow(800, 600, &quot;SUCCESS&quot;, NULL, NULL);

    if (window == NULL) {
        std::cout &lt;&lt; &quot;Failed to create the windows&quot; &lt;&lt; std::endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl;
        return -1;
    }

    while (!glfwWindowShouldClose(window)) {

        processInput(window);
        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    glfwTerminate();
    return 0;
}

void framebuffer_size_callback(GLFWwindow* windows, int width, int height) {
    glViewport(0, 0, width, height);
}

void processInput(GLFWwindow* window) {
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {
        glfwSetWindowShouldClose(window, true);
    }
}
</code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/16/STL-set和multiset/">STL-set和multiset</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-16</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/C/">C++</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/STL/">STL</a></span><div class="content"><ul>
<li><p><strong>简介</strong></p>
<blockquote>
<p>使用set与multiset时需要包含头文件 &lt;set><br>set与multiset让使用者能够在容器中快速查找键（键是储存在一维容器中的值），set和multiset的区别在于set中键值要求唯一，后者可以重复。<br>set与multiset的内部结构像是二叉树，插入与素时要对元素进行排序，因此，相对于vector，list那些容器，set与multiset在插入新元素时效率较低（有额外排序开销），在元素查找方面效率较高。因此，它们适用于那些需要频繁查找的程序中。      </p>
<blockquote>
<p>set与multiset操作相似，下面的介绍以set为例。   </p>
</blockquote>
</blockquote>
</li>
<li><p><strong>实例化set</strong></p>
<blockquote>
<p>实例化一个特定类型的set,以int类型为例：</p>
</blockquote>
<pre><code>set&lt;int&gt; intSet;
</code></pre><blockquote>
<p>set与multiset在元素插入时对其进行排序，默认使用std::less对插入数据进行排序。<br>要创建二元谓词，可在类中定义一个operator()：   </p>
</blockquote>
<pre><code>emplate&lt;typename T&gt;
struct SortStandard
{
    //从大到小排序
    bool operator()(const T&amp; lhs, const T&amp; rhs)
    {
        return (lhs &gt; rhs);
    }
};

int main()
{
    //指定排序规则的初始化操作
    set&lt;int, SortStandard&lt;int&gt;&gt; intSet;
    return 0;
}
</code></pre><blockquote>
<p>也可以使用另外一个set或者两个set迭代器对其进行初始化：</p>
</blockquote>
<pre><code>set&lt;int, SortStandard&lt;int&gt;&gt; intSet;
set&lt;int&gt; intSet1(intSet.cbegin(), intSet.cend());
//这里不能用intSet初始化intSet，因为他们两个排序方式不一样
set&lt;int&gt; intSet2(intSet1);
</code></pre><blockquote>
<p><strong>注意：</strong> 上面代码中不能用intSet初始化intSet，因为他们的排序方式不同。   </p>
</blockquote>
</li>
<li><p><strong>插入元素</strong>   </p>
<blockquote>
<p>使用成员函数insert()进行元素插入操作。   </p>
</blockquote>
<pre><code>set&lt;int&gt; intSet;

intSet.insert(-1);
intSet.insert(600);
intSet.insert(66);

set&lt;int&gt; intSet1;
intSet1.insert(intSet.cbegin(), intSet.cend());
auto pos = ++intSet1.begin();
//报错
//*pos = 16;
</code></pre></li>
</ul>
<blockquote>
<p>无论使用begin()还是cbegin()获得的迭代器，都不等对*pos进行赋值操作，因为set不允许改变其内元素的值。<br>set也不能使用 [] 操作符获取元素的值；可以使用迭代器来获取元素值。   </p>
</blockquote>
<ul>
<li><p><strong>删除元素</strong>   </p>
<blockquote>
<p>关联容器都提供了成员函数erase()。<br>1、根据键删除值：<br>setObject.erase(key);<br>2、传入一个迭代器，删除迭代器指向的值：<br>setObject.erase(iElement);<br>3、使用迭代器指定边界，删除边界内的所有元素：<br>setObject.erase(iLowerBound, iUpperBound);   </p>
</blockquote>
<pre><code>set&lt;int&gt; intSet;
intSet.insert(-1);
intSet.insert(600);
intSet.insert(66);

intSet.erase(66);
intSet.erase(++intSet.begin(), intSet.end());
</code></pre></li>
</ul>
<blockquote>
<p>当multiset存在多个相同的值时，用setObject.erase(key)删除值时，会将他们全部删除。   </p>
</blockquote>
<pre><code>multiset&lt;int&gt; intSet;
intSet.insert(66);
intSet.insert(600);
intSet.insert(66);

intSet.erase(66);
</code></pre><p><strong>C++11</strong></p>
<blockquote>
<p>在C++11中，新增加了散列集合unordered_set和unordered_multiset；它们相对于set和multiset进一步的改善了性能。他们使用散列函数来计算排序索引。   </p>
<blockquote>
<p>使用时添加头文件&lt;unordered_set></p>
</blockquote>
</blockquote>
<p><strong>注意</strong>，将对象储存到set或multiset中时，别忘了在类中实现运算符&lt;和==，前者将成为排序谓词，后者用于find()函数。   </p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/16/STL-list和forward-list/">STL-list和forward_list</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-16</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/C/">C++</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/STL/">STL</a></span><div class="content"><ul>
<li><p><strong>list的特点</strong>   </p>
<blockquote>
<p>在list开头、中间、末尾插入数据，所需时间都是固定的，将元素从list中产出所需的时间是固定的。插入或者删除元素后，指向list中其他元素的迭代器仍然有效。<br>不过搜索速度比vector慢，因为元素没有储存在连续的内存单元中。   </p>
</blockquote>
</li>
<li><p><strong>插入元素</strong>   </p>
<blockquote>
<p>使用成员函数push_back()和push_front在list末尾和开头插入元素，使用成员函数insert在list中插入元素。  </p>
</blockquote>
<pre><code>list&lt;int&gt; intList(3, 6);
intList.push_front(5);
intList.push_back(7);

//在迭代器指向的位置添加一个元素
intList.insert(intList.begin(), 4);

//在迭代器指向的位置添加指定数量的某个元素
intList.insert(intList.end(), 2, 8);

//在迭代器指向的位置插入某个容器两个迭代器之间的元素
list&lt;int&gt; anoList(2, 9);
intList.insert(intList.end(), anoList.begin(), anoList.end());
</code></pre></li>
<li><p><strong>删除元素</strong></p>
<blockquote>
<p>使用list::erase()来删除list中的元素，他有两个重载版本，一个版本接受一个迭代器并删除迭代器指向的元素，另一个接受两个迭代器参数并删除指定范围内的所有元素。</p>
</blockquote>
</li>
<li><p><strong>元素反转和排序</strong></p>
<blockquote>
<p>使用list的成员方法reverse()和sort()对list进行反转和排序，执行者两个操作后之前指向元素的迭代器仍然有效。   </p>
</blockquote>
<pre><code>list&lt;int&gt; intList;
intList.push_back(7);
intList.push_front(5);
intList.push_back(6);

auto int6 = --intList.end();                                            //6
list&lt;int&gt;::const_iterator int7 = ++intList.begin();        //7
//反转
intList.reverse();
//排序
intList.sort();
cout &lt;&lt; *int6 &lt;&lt; endl;                //6
cout &lt;&lt; *int7 &lt;&lt; endl;                //7   
</code></pre></li>
</ul>
<blockquote>
<p>其中排序方法sort()还有一个重载版本，接受一个二元谓词作为参数：</p>
</blockquote>
<pre><code>//从大到小排序
bool MySortStandard(const int&amp; lsh, const int&amp; rsh) {
    return (lsh &gt; rsh);
}
int main()
{
    ......
        //排序
        intList.sort(MySortStandard);
    ......
}
</code></pre><p><strong>STL forward_list</strong></p>
<blockquote>
<p>从c++11起，可以使用单向链表forward_list;<br>使用时需要包含头文件 &lt;forward_list&gt;<br>使用forward时，只能使用push_front()函数在开头插入元素，其他操作与list很像。   </p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/15/STL-vector/">STL-vector</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-15</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/C/">C++</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/STL/">STL</a></span><div class="content"><h2 id="STL-vector"><a href="#STL-vector" class="headerlink" title="STL vector"></a>STL vector</h2><blockquote>
<p>使用vector时需要包含头文件<strong>&lt;vector></strong> </p>
</blockquote>
<ul>
<li><p><strong>vector的特点</strong><br>vector动态数组类：<br>1、无论数组中存在多少元素，在数组末尾添加新元素时所需时间都是固定的。<br>2、在数组中间添加或者删除元素时，与<strong>该元素后面的元素个数</strong>成正比。<br>3、储存的元素是动态的，vector类负责管理内存。   </p>
</li>
<li><p><strong>vector的初始化</strong>   </p>
<blockquote>
<p>下面的代码介绍了vector的几种初始化方法。   </p>
</blockquote>
<pre><code>//默认初始化
vector&lt;int&gt; intVec;

//初始化时设置至少包含的元素数（并没有限制大小），每个元素初始值默认为0
vector&lt;int&gt; intVec1(10);

//同上，并设置每个元素的初始化值
vector&lt;int&gt; intVec2(10, 66);

//使用另外一个vector来初始化
vector&lt;int&gt; intVec3(intVec2);

//使用另一个vector的两个迭代器来初始化
vector&lt;int&gt; intVec4(intVec2.cbegin(), intVec2.cbegin() + 5);
</code></pre></li>
</ul>
<blockquote>
<p>cbegin()和cend()是C++11新增的，它们返回一个const的迭代器，不能用于修改元素。</p>
</blockquote>
<ul>
<li><p><strong>vector插入元素</strong></p>
<blockquote>
<p>使用成员函数push_back()在容器末尾插入元素；使用insert()在指定位置插入元素。   </p>
</blockquote>
<pre><code>vector&lt;int&gt; intVec(5);
intVec.push_back(66);
cout &lt;&lt; intVec.size() &lt;&lt; endl;        //6

//在指定位置插入元素
intVec.insert(intVec.begin(), 67);

//在指定位置插入指定个数的某个元素
intVec.insert(intVec.begin(), 2, 66);

//在指定位置插入另一个vector的内容(使用迭代器指定范围)
vector&lt;int&gt; anoVec(3, 65);
intVec.insert(intVec.begin(), 
                    anoVec.begin(), anoVec.end());
</code></pre></li>
</ul>
<blockquote>
<p>使用insert插入元素时，效率较低，与其特点有关。   </p>
</blockquote>
<ul>
<li><p><strong>访问vector中的元素</strong></p>
<blockquote>
<p>使用下标用算符[]访问元素，超出容器边界时结果不确定。<br>使用成员方法at()访问元素，超出容器边界时将会报错。<br>使用迭代器访问元素。   </p>
</blockquote>
<pre><code>vector&lt;int&gt; intVec;
intVec.push_back(64);
intVec.push_back(65);
intVec.push_back(66);
//使用 [] 访问元素
for (size_t i = 0; i &lt; intVec.size(); ++i) {
    cout &lt;&lt; intVec[i] &lt;&lt; endl;
}
//使用 at() 访问元素
for (size_t i = 0; i &lt; intVec.size(); ++i) {
    cout &lt;&lt; intVec.at(i) &lt;&lt; endl;
}
//使用迭代器访问元素
for (vector&lt;int&gt;::const_iterator pos = intVec.begin()
    ; pos != intVec.end()
    ; ++pos)
{
    cout &lt;&lt; *pos &lt;&lt; endl;
}
</code></pre></li>
<li><p><strong>删除vector中的元素</strong></p>
<blockquote>
<p>使用pop_back()从vector中删除元素所需要的时间是固定的。<br>不能使用偏移位置和元素数删除指定个数的元素。   </p>
</blockquote>
<pre><code>vector&lt;int&gt; intVec;
intVec.push_back(64);
intVec.push_back(65);
intVec.push_back(66);

//删除vector末尾的元素
intVec.pop_back();

//删除迭代器指向的元素
intVec.erase(intVec.begin());

//删除两个迭代器之间的元素
intVec.erase(intVec.begin(), intVec.begin() + 2);
</code></pre></li>
<li><p><strong>大小和容量的区别</strong></p>
<blockquote>
<p>可以通过成员函数size()和capacity()来获取vector的大小和容量。<br><strong>容量</strong>总是大于等于<strong>大小</strong>，当当前容量不足时，重新分配容量时，会分配比当前所需容量更大的容量（比如容量满时再插入数据时，可能会分配两个元素的容量，或者更多）。<br>可使用成员函数reserve(number),设置当前容器的容量（如果传入的number小于size的话，默认使用size的值。）   </p>
</blockquote>
</li>
</ul>
<h3 id="STL-deque"><a href="#STL-deque" class="headerlink" title="STL deque"></a>STL deque</h3><blockquote>
<p>发音：/dek/<br>使用时要包含头文件 <deque><br>deque与vector极其相似，只是可以使用成员函数push_front()和pop_frone()在开头插入和删除元素。      </deque></p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/13/STL-string/">STL-string</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-13</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/C/">C++</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/STL/">STL</a></span><div class="content"><h2 id="STL简介"><a href="#STL简介" class="headerlink" title="STL简介"></a>STL简介</h2><blockquote>
<p>标准模板库是一组<strong>模板类和函数</strong>，向程序员提供了：<br>1.用于储存信息的<strong>容器</strong>，包含：   </p>
<blockquote>
<p>顺序容器<br>(1). std::vector——与动态数组类似，在最后插入数据。<br>(2). std::deque——与std::vector类似，允许在开头添加或删除数据。<br>(3). std::list——与双向链表类似。<br>(4). std::forward_list——类似于std::list，不过是单向链表。   </p>
</blockquote>
<blockquote>
<p>关联容器<br>(1). std::set——储存各不相同的值，在插入时进行排序。（对数复杂度）<br>    std::unordered_set——c++11新增的，与set相同。（复杂度为常数）   </p>
</blockquote>
<blockquote>
<p>(2). std::map——储存键值对，并根据唯一的键排序。（对数复杂度）<br>    std::unordered_map——c++11新增的，与map相同。（复杂度为对数）  </p>
</blockquote>
<blockquote>
<p>(3). std::multiset——与set类似，但值不需要是唯一的。<br>    std::unordered_multiset——c++11新增的，与unordered_set类似。但值不需要是唯一的。   </p>
</blockquote>
<blockquote>
<p>(4). std::multimap——与map类似，不要求键是唯一的。<br>    std::unordered_multimap——c++11新增的，与unordered_map类似。不要求键是唯一的。    </p>
</blockquote>
<blockquote>
<p>容器适配器<br>(1). std::stack：以LIFO(后进先出)的方式储存元素。<br>(2). std::queue：以FIFO(先进先出)的方式储存元素。<br>(3). std::priority_queue：以特定顺序储存元素。   </p>
</blockquote>
<p>2.用于访问容器储存的信息的<strong>迭代器</strong><br>3.用于操作容器内容的<strong>算法</strong>   </p>
</blockquote>
<p><strong>下文再介绍时，省略了std::</strong></p>
<p><strong>STL迭代器</strong>   </p>
<blockquote>
<p>指针是最简单的迭代器，让该指针指向数组中的第一个元素，然后递增指针以获得下一个元素。<br>STL中的迭代器是模板类，在某种程度上，可以将它理解成泛型指针。    </p>
</blockquote>
<p><strong>STL算法</strong></p>
<blockquote>
<p>为程序员提供的查找、排序、反转等功能的模板函数。<br>使用STL算法时，要包含<strong>标准头文件<algorihm></algorihm></strong><br>常用STL算法如下：</p>
<blockquote>
</blockquote>
<p>std::find: 在集合中查找值。<br>std::find_if: 根据用户指定的谓词在集合中查找值。<br>std::reverse: 反转集合中的元素的排序。<br>std::remove_if: 根据用户定义的谓词将元素从集合中删除。<br>std::transform: 使用用户定义的变换函数对容器中的元素进行变换。   </p>
<blockquote>
</blockquote>
</blockquote>
<p><strong>使用迭代器在容器和算法之间交互</strong>   </p>
<pre><code>#include &lt;iostream&gt;   
#include &lt;vector&gt;   
#include &lt;algorithm&gt;   
using namespace std;   

int main()   
{
    vector&lt;int&gt; IntArray;   
    IntArray.push_back(123);
    IntArray.push_back(1997);
    IntArray.push_back(917);
    IntArray.push_back(2019);
    IntArray.push_back(6666);

    //使用迭代器遍历容器元素
    //for (vector&lt;int&gt;::iterator IA = IntArray.begin(); 
    //        IA &lt; IntArray.end(); ++IA) {
    //    cout &lt;&lt; *IA &lt;&lt; endl;
    //}
    //使用迭代器遍历容器元素，此处所使用了auto让编译器自动判断类型
    for (auto iArrayWalker = IntArray.begin(); 
            iArrayWalker &lt; IntArray.end(); ++iArrayWalker){
        cout &lt;&lt; *iArrayWalker &lt;&lt; endl;
    }
    //使用find算法在容器中查找元素1997，查到末尾时（end()）还没找到，便返回end()的地址
    //vector&lt;int&gt;::iterator value = find(IntArray.begin(), IntArray.end(), 1997);
    auto value = find(IntArray.begin(), IntArray.end(), 1997);

    //判断是否找到元素1997
    if (value != IntArray.end()) {
        cout &lt;&lt; &quot;value: &quot; &lt;&lt; *value &lt;&lt; endl;
        //获取1997在容器中的位置，及到begin()的距离
        int index = distance(IntArray.begin(), value);
        cout &lt;&lt; &quot;index: &quot; &lt;&lt; index &lt;&lt; endl;
    }
    getchar();
    return 0;
}
</code></pre><blockquote>
<p>由上述代码可以看出，迭代器就是获得的是容器中元素的地址；因此，在某种程度上可以将它理解为泛型指针。</p>
</blockquote>
<h2 id="STL-string类"><a href="#STL-string类" class="headerlink" title="STL string类"></a>STL string类</h2><blockquote>
<p>std::stirng与std::wstring是STL库中一个帮助程序员用于字符串操作的容器类。使用时要包含<string>头文件。<br>以std::string为例来介绍这个类的用法。</string></p>
</blockquote>
<ul>
<li><p><strong>实例化string</strong>   </p>
<pre><code>const char* C_StyleString = &quot;Hello String&quot;;
const char* cString = &quot;Hello String&quot;;
//使用构造函数初始化
string str(cString);
//使用等号初始化
string str1 = cString;
//使用string类型数据初始化
string strCopy(cString);
//使用某个字符串的前n位初始化
string str2(&quot;Hello String&quot;, 5);
//使用指定数量的字符初始化
string str3(6, &apos;a&apos;);                    //str3 = aaaaaa
//string str3(6, &apos;adf&apos;);                //str3 = ffffff
</code></pre></li>
<li><p><strong>访问string的内容</strong></p>
<pre><code>//通过[]访问元素
for (int i = 0; i &lt; str.length(); ++i) {
    cout &lt;&lt; str[i] &lt;&lt; endl;
}
//通过迭代器访问
for (string::const_iterator pos = str.begin()
    ; pos != str.end()
    ; ++pos)
{
    //*pos = &apos;h&apos;;                //报错，pos指向的值是const类型的，不可更改
    cout &lt;&lt; *pos &lt;&lt; endl;
}
//通过迭代器访问
for (string::iterator pos = str.begin()
    ; pos != str.end()
    ; ++pos)
{
    *pos = &apos;6&apos;;                    //不报错
    cout &lt;&lt; *pos &lt;&lt; endl;
}
</code></pre></li>
</ul>
<blockquote>
<p>上面代码中使用迭代器时，使用了一个新的迭代器const_iterator,使用它时，迭代器的值可变，但迭代器指向的值的值不可被改变。</p>
</blockquote>
<ul>
<li><strong>字符串拼接</strong>   </li>
</ul>
<blockquote>
<p>使用+=或者成员函数append()来拼接字符串。</p>
</blockquote>
<pre><code>string str4 = &quot;Hello &quot;;
string str5 = &quot;World &quot;;
string str6(&quot;Beautiful!&quot;);

str4 += str5;                //str4 = Hello World 
str4.append(str6);            //str4 = Hello World Beautiful!
</code></pre><ul>
<li><strong>字符/子字符串查找</strong>   </li>
</ul>
<blockquote>
<p>可以使用string中的成员函数find来查找字符或者子字符串。<br>查找成功返回字符的索引或子字符串首个字符的索引。<br>查找失败返回string::npos（实际值为-1）。</p>
</blockquote>
<pre><code>string str6 = &quot;Hello World&quot;;
//从索引为0初的字符往后进行查找
int index = str6.find(&quot;World&quot;, 0);    
cout &lt;&lt; index &lt;&lt; endl;                        //6
//查找str6中所有 l 的索引
size_t charPos = str6.find(&apos;l&apos;, 0);
while (charPos != string::npos) {            
    cout &lt;&lt; charPos &lt;&lt; endl;                //2 3 9
    charPos = str6.find(&apos;l&apos;, ++charPos);
}
</code></pre><blockquote>
<p>size_t在32位架构上是4字节，在64位架构上是8字节，在不同架构上进行编译时需要注意这个问题。而int在不同架构下都是4字节；且int为带符号数，size_t为无符号数。</p>
</blockquote>
<ul>
<li><p><strong>字符串截短</strong>   </p>
<blockquote>
<p>可以使用成员函数erase()来删除字符串中的字符。<br>使用方法如下： </p>
</blockquote>
<p>  string myStr = “Life is always like this.”;</p>
</li>
</ul>
<p>1.在给定偏移位置（索引值）和指定数目时删除字符。  </p>
<pre><code>//删除索引在 区间[14,19) 内的字符串
myStr.erase(14,5);            //Life is always this.
</code></pre><p>2.删除迭代器iChar指向的字符。</p>
<pre><code>auto iChar = find(myStr.begin(), myStr.end(), &apos;.&apos;);
myStr.erase(iChar);            //Life is always like this
</code></pre><p>3.删除两个迭代器指定范围内的字符串。</p>
<pre><code>myStr.erase(++myStr.begin(), myStr.end());    //L
</code></pre><blockquote>
<p>使用成员方法clear()时，经清楚全部内容并重置string对象。</p>
</blockquote>
<ul>
<li><strong>字符串反转</strong></li>
</ul>
<blockquote>
<p>使用泛型算法std::reverse()对字符串进行反转。(注意不是成员方法)<br>reverse接收两个参数，起始迭代器、终止迭代器，然后将对两个迭代器之间的内容进行反转。</p>
</blockquote>
<pre><code>string myStr = &quot;Life is always like this.&quot;;
reverse(++myStr.begin(), myStr.end());        //L.siht ekil syawla si efi
</code></pre><ul>
<li><strong>字符串大小写转换</strong>   </li>
</ul>
<blockquote>
<p>使用算法std::transform()进行大小写转换。(注意不是成员方法)<br>transform(first, last, r_first, trans)接收四个参数：开始迭代器、终止迭代器、开始迭代器、要执行的变换。<br>要执行转大写操作时 trans = toupper, 要执行转小写操作时 trans = tolower。   </p>
</blockquote>
<pre><code>string myStr = &quot;life is always like this.&quot;;
transform(++myStr.begin(), myStr.end(), ++myStr.begin(), toupper);
//——&gt;lIFE IS ALWAYS LIKE THIS.
transform(++myStr.begin(), myStr.end(), ++myStr.begin(), tolower);
//——&gt;life is always like this.
</code></pre><blockquote>
<p>如果要编写的应用程序需要更好的支持非拉丁字符，如中文与日文时，应使用std::wstring。   </p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/13/c-模板/">c++模板</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-13</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/C/">C++</a></span><div class="content"><blockquote>
<p>模板可能是c++中最强大最强大却最少被使用（或被理解）的<strong>特性</strong>之一了；我们可以用模板来定义一种适用于<strong>不同类型</strong>的对象的<strong>行为</strong><br>这就像是用#define定义的一个返回两个数中最大值的宏函数那样<br><code>#define MAX_NUM(a, b) ((a) &gt; (b) ? (a) : (b))</code><br>这里的a，b可以是int类型、也可以是其他类型；与“”宏函数不同的是<strong>宏不是类型安全的，而模板是类型安全的</strong>   </p>
</blockquote>
<ul>
<li><p>模板函数/类声明语法   </p>
<blockquote>
<p>template &lt;参数列表&gt;<br>模板函数/类的声明   </p>
</blockquote>
<p>   参数列表中包含关键字typename，它定义了参数objectTyep，objectType是一个占位符，当对象实例化模板时（创建类实例时）将使用指定的对象类型替换它：</p>
<pre><code>//模板函数   
template &lt;typename T&gt;   
const T&amp; GetMax(const T&amp; num1, const T&amp; num2)   
{
    if(num1 &lt; num2)
        return num2;
    return num1;   
}   

//模板类   
template &lt;typename T1, typename T2&gt;   
class Template   
{   
private:   
    T1 m_Obj1;   
    T2 m_Obj2;   
public:   
    Template(T1 obj1, T2 obj2):   
      m_Obj1(obj1), m_Obj2(obj2){ }   

      void print(){   
        cout &lt;&lt; m_Obj1 &lt;&lt; &quot;  &quot; &lt;&lt; m_Obj2 &lt;&lt; endl;   
      }   
};   

int main()   
{   
    Template&lt;int, float&gt; tem(66, 66.6);   
    tem.print();   
    cout &lt;&lt; GetMax&lt;float&gt;(25.5, 123) &lt;&lt; endl;   
    cout &lt;&lt; GetMax(25.5, 123.0)
    return 0;   
}   
</code></pre></li>
</ul>
<blockquote>
<p>上述代码中实例化Template类时，将T1指定为int类型，将T2指定为float类型（显式指定）。<br>第一次调用模板函数时，将T指定为float类型；第二次调用时却没有指定类型，但这样也是正确的，这时候，模板函数会自动判断数据的类型（隐式指定）。<br>不过，<strong>对于模板类，必须要显式指定其类型</strong>。   </p>
</blockquote>
<p><strong>声明包含多个参数的模板</strong>   </p>
<blockquote>
<p>声明包含多个参数的模板时, 参数之间用逗号隔开：<br>template &lt; typename T1, typename T2,…., typename Tn &gt;</p>
</blockquote>
<p><strong>声明包含默认参数的模板</strong></p>
<blockquote>
<p>声明包含默认参数的模板时, 可将它初始化成默认类型：<br>template &lt; typename T1 = int, … , typename tn = int &gt;</p>
</blockquote>
<p><strong>*模板类和静态成员</strong>   </p>
<blockquote>
<p>在普通的类中，类成员被定义成静态的话，该静态成员被所有实例共享；<br>在模板类中，也类似这样，只不过是被同类型的具体化的实例所共享的：</p>
</blockquote>
<pre><code>template &lt;typename T&gt;
class Template
{
private:
    T m_Obj1;
    static int T_Num; 
public:
    static int getT_Num()
    {
        return T_Num;
    }
    static void setT_Num(const int&amp; num)
    {
        T_Num = num;
    }
};

//静态成员变量的初始化
template &lt;typename T&gt;
int Template&lt;T&gt;::T_Num = 0;        


int main()
{
    Template&lt;int&gt;::setT_Num(1997);
    Template&lt;float&gt;::setT_Num(917);
    cout &lt;&lt; Template&lt;int&gt;::getT_Num() &lt;&lt; endl;            //1997
    cout &lt;&lt; Template&lt;float&gt;::getT_Num() &lt;&lt; endl;        //917
    return 0;    
}
</code></pre><blockquote>
<p>上述代码中两次输出结果分别是1997、917。你该懂了吧<br><strong>c++中的静态成员变量</strong><br>在c++的类中，如果存在静态成员变量的话，必须对它进行初始化,格式如下：</p>
<blockquote>
<p>&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt; = &lt;值&gt;   </p>
</blockquote>
<p>模板类中的静态成员变量的初始化格式：（参考上述代码的初始化）</p>
<blockquote>
<p>template&lt;参数&gt; &lt;数据类型&gt;&lt;类名&lt;参数&gt;&gt;::&lt;静态数据成员名&gt; = &lt;值&gt;   </p>
</blockquote>
</blockquote>
<p><strong>c++11</strong><br><strong>使用static_assert执行编译阶段的检查</strong>（类似assert宏）   </p>
<blockquote>
<p>static_assert是c++11中新加的功能（有的编译器不支持），它是一种编译断言，能够在不满足条件时禁止编译。<br>使用格式：<br>static _assert(表达式, “表达式为假时输出的错误信息”)</p>
</blockquote>
<pre><code>template &lt;typename T&gt;
class CanNotInt
{
public:
    CanNotInt(){
        static_assert(sizeof(T) != sizeof(int), &quot;No int please&quot;);    
    }
};
int main()
{
    CanNotInt&lt;int&gt; test;
    return 0;
}
</code></pre><blockquote>
<p>上述代码编译时会报错。</p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/13/c-宏/">c++宏</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-13</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/C/">C++</a></span><div class="content"><p><strong>前言</strong>   </p>
<blockquote>
<p>预处理器：在编译之前运行的工具。<br><strong>预处理器编译指令</strong>是向预处理器发出的命令，总是以符号<strong>#</strong>开头。根据程序员的指示，决定编译器实际要编译的文本内容。<br>比如：对于一个宏<code>#define PI 3.1415</code>，在编译之前，预处理器会在代码中找到 PI 并将它替换为 3.1415 。</p>
</blockquote>
<p><strong>使用#define定义常量</strong></p>
<ul>
<li>语法： #define identifer(标识符) value(值)<br>栗子：<br><code>#define PI 3.1415</code><br><code>#define NICKNAME &quot;f_x&quot;</code><br><code>#define THIS_IS_DOUBLE double</code><br><code>#define THIS_IS_FOR for</code>   </li>
<li><p>预处理器对宏指定的文本进行简单的替换，因此可以用宏来编写简单的函数<br>栗子：   </p>
<pre><code>#define PI 3.1415
   #define AREA_CIRCLE(r) ( PI * (r) * (r))
</code></pre></li>
</ul>
<p><strong>为什么要使用这么多括号？</strong>   </p>
<blockquote>
<p>对于上面的宏AREA_CIRCLE,若在代码中这样使用<br><code>cout &lt;&lt; AREA_CIRCLE(4+6);</code><br>使用括号时，经预处理器处理后：<br><code>cout &lt;&lt; (3.1415 * (4 + 6) * (4 + 6))</code><br>不使用括号时：<br><code>cout &lt;&lt; 3.1415 * 4 + 6 * 4 + 6</code><br>你懂得。。。   </p>
</blockquote>
<p><strong>宏的其他作用</strong></p>
<ul>
<li><p>避免头文件的多次包含   </p>
<blockquote>
<p>假设有两个头文件class1.h,class2.h,当我们不得不让两个类相互包含时，对预处理器来说，这样会造成递归问题；<br>为了避免这种问题，可以使用宏和预处理器编译指令#ifndef（if-not-define）和endif。   </p>
</blockquote>
<pre><code>#ifndef HEADER2_H_H            //如果宏HEADER2_H_H未定义
#define HEADER2_H_H            //定义宏HEADER2_H_H
#include &lt;class2.h&gt;

class class1
{
    ......
};

#endif
</code></pre></li>
</ul>
<pre><code>#ifndef HEADER1_H_H            //如果宏HEADER1_H_H未定义
#define HEADER1_H_H            //定义宏HEADER1_H_H
#include &lt;class1.h&gt;

class class2
{
    ......
};

#endif   
</code></pre><blockquote>
<p>预处理器进行死板的文本替换，这可以减轻程序员的负担，当并不是能减轻编译器的负担。<br>其次，对于宏PI，我们没有太大的控制权，其类型是double还是float？答案是都不是。在预处理器看来，PI就是3.1415，根本不知道其数据类型。<br>所以定义常量时 const 是更好的选择<br><code>const double PI = 3.14215;</code><br><strong>define与const的区别</strong><br>1.起作用的阶段不同：#define在预处理阶段起作用； const在编译或者运行阶段起作用；<br>2.起作用的方式不同：#define进行简单的文本替换，不能进行类型检查；const定义的常量有对应的数据类型；<br>3.储存方式不同：#define定义的宏常量在内存中有多个备份，而const定义的常量在内存中只有一个备份；<br>4.const常量可用于调试，而#define定义的常量不能用于调试（预处理阶段被替换掉了）；</p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/11/27/算法时间复杂的的计算/">算法时间复杂的的计算</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-11-27</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/算法/">算法</a></span><div class="content"><p><code>一般用大写O()来表示算法的时间复杂度写法，通常叫做大O记法。</code><br><code>一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。</code>   </p>
<p><strong>大O推导法：</strong> </p>
<pre><code>用常数1取代运行时间中的所有加法常数
   在修改后的运行函数中，只保留最高阶项
如果最高阶项存在且不是1，则去除与这个项相乘的常数  
</code></pre><p><strong>示例：</strong></p>
<pre><code>n++;                                      /*执行次数为1*/
function(n);                              /*执行次数为n*/
int i,j;
for(i = 0 ; i &lt; n ; i++){                 /*执行次数为nXn*/
    for(j = 0; j &lt; n; j++){
        function(i);  
    }
}
for(i = 0 ; i &lt; n ; i++){                /*执行次数为n(n+1)/2*/
  for(j = i ; j &lt; n ; j++){
      /*时间复杂度为O(1)的程序*/  
  }  
}
</code></pre><p>它的执行次数f(n) = 1 + n + n^2 + n(n+1)/2,<br>根据推导大O阶的方法，最终它的时间复杂度为：O(n^2)</p>
<p><img src="https://i.imgur.com/Z1poILo.png" alt=""><br><strong>时间复杂度所耗费的时间是：</strong><br>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n2) &lt; O(n3) &lt;O(2n) &lt; O(n!) &lt;O(nn)</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By fx</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>