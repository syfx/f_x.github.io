<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="f_x">
  <!-- Open Graph Data -->
  <meta property="og:title" content="STL-string">
  <meta property="og:description" content="">
  <meta property="og:site_name" content="f_x&#39;s blog">
  <meta property="og:type" content="article">
  <meta property="og:image" content="http://yoursite.com">
  
    <link rel="alternate" href="/atom.xml" title="f_x&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>f_x's blog</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/mypicture3.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">STL-string</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/syfx">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:782933913@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By f_x</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-03-13</span>
            <span class="time">09:59:27</span>
          </span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/C/">#C++</a> <a class="tag" href="/tags/STL/">#STL</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h2 id="STL简介"><a href="#STL简介" class="headerlink" title="STL简介"></a>STL简介</h2><blockquote>
<p>标准模板库是一组<strong>模板类和函数</strong>，向程序员提供了：<br>1.用于储存信息的<strong>容器</strong>，包含：   </p>
<blockquote>
<p>顺序容器<br>(1). std::vector——与动态数组类似，在最后插入数据。<br>(2). std::deque——与std::vector类似，允许在开头添加或删除数据。<br>(3). std::list——与双向链表类似。<br>(4). std::forward_list——类似于std::list，不过是单向链表。   </p>
</blockquote>
<blockquote>
<p>关联容器<br>(1). std::set——储存各不相同的值，在插入时进行排序。（对数复杂度）<br>    std::unordered_set——c++11新增的，与set相同。（复杂度为常数）   </p>
</blockquote>
<blockquote>
<p>(2). std::map——储存键值对，并根据唯一的键排序。（对数复杂度）<br>    std::unordered_map——c++11新增的，与map相同。（复杂度为对数）  </p>
</blockquote>
<blockquote>
<p>(3). std::multiset——与set类似，但值不需要是唯一的。<br>    std::unordered_multiset——c++11新增的，与unordered_set类似。但值不需要是唯一的。   </p>
</blockquote>
<blockquote>
<p>(4). std::multimap——与map类似，不要求键是唯一的。<br>    std::unordered_multimap——c++11新增的，与unordered_map类似。不要求键是唯一的。    </p>
</blockquote>
<blockquote>
<p>容器适配器<br>(1). std::stack：以LIFO(后进先出)的方式储存元素。<br>(2). std::queue：以FIFO(先进先出)的方式储存元素。<br>(3). std::priority_queue：以特定顺序储存元素。   </p>
</blockquote>
<p>2.用于访问容器储存的信息的<strong>迭代器</strong><br>3.用于操作容器内容的<strong>算法</strong>   </p>
</blockquote>
<p><strong>下文再介绍时，省略了std::</strong></p>
<p><strong>STL迭代器</strong>   </p>
<blockquote>
<p>指针是最简单的迭代器，让该指针指向数组中的第一个元素，然后递增指针以获得下一个元素。<br>STL中的迭代器是模板类，在某种程度上，可以将它理解成泛型指针。    </p>
</blockquote>
<p><strong>STL算法</strong></p>
<blockquote>
<p>为程序员提供的查找、排序、反转等功能的模板函数。<br>使用STL算法时，要包含<strong>标准头文件<algorihm></algorihm></strong><br>常用STL算法如下：</p>
<blockquote>
</blockquote>
<p>std::find: 在集合中查找值。<br>std::find_if: 根据用户指定的谓词在集合中查找值。<br>std::reverse: 反转集合中的元素的排序。<br>std::remove_if: 根据用户定义的谓词将元素从集合中删除。<br>std::transform: 使用用户定义的变换函数对容器中的元素进行变换。   </p>
<blockquote>
</blockquote>
</blockquote>
<p><strong>使用迭代器在容器和算法之间交互</strong>   </p>
<pre><code>#include &lt;iostream&gt;   
#include &lt;vector&gt;   
#include &lt;algorithm&gt;   
using namespace std;   

int main()   
{
    vector&lt;int&gt; IntArray;   
    IntArray.push_back(123);
    IntArray.push_back(1997);
    IntArray.push_back(917);
    IntArray.push_back(2019);
    IntArray.push_back(6666);

    //使用迭代器遍历容器元素
    //for (vector&lt;int&gt;::iterator IA = IntArray.begin(); 
    //        IA &lt; IntArray.end(); ++IA) {
    //    cout &lt;&lt; *IA &lt;&lt; endl;
    //}
    //使用迭代器遍历容器元素，此处所使用了auto让编译器自动判断类型
    for (auto iArrayWalker = IntArray.begin(); 
            iArrayWalker &lt; IntArray.end(); ++iArrayWalker){
        cout &lt;&lt; *iArrayWalker &lt;&lt; endl;
    }
    //使用find算法在容器中查找元素1997，查到末尾时（end()）还没找到，便返回end()的地址
    //vector&lt;int&gt;::iterator value = find(IntArray.begin(), IntArray.end(), 1997);
    auto value = find(IntArray.begin(), IntArray.end(), 1997);

    //判断是否找到元素1997
    if (value != IntArray.end()) {
        cout &lt;&lt; &quot;value: &quot; &lt;&lt; *value &lt;&lt; endl;
        //获取1997在容器中的位置，及到begin()的距离
        int index = distance(IntArray.begin(), value);
        cout &lt;&lt; &quot;index: &quot; &lt;&lt; index &lt;&lt; endl;
    }
    getchar();
    return 0;
}
</code></pre><blockquote>
<p>由上述代码可以看出，迭代器就是获得的是容器中元素的地址；因此，在某种程度上可以将它理解为泛型指针。</p>
</blockquote>
<h2 id="STL-string类"><a href="#STL-string类" class="headerlink" title="STL string类"></a>STL string类</h2><blockquote>
<p>std::stirng与std::wstring是STL库中一个帮助程序员用于字符串操作的容器类。使用时要包含<string>头文件。<br>以std::string为例来介绍这个类的用法。</string></p>
</blockquote>
<ul>
<li><p><strong>实例化string</strong>   </p>
<pre><code>const char* C_StyleString = &quot;Hello String&quot;;
const char* cString = &quot;Hello String&quot;;
//使用构造函数初始化
string str(cString);
//使用等号初始化
string str1 = cString;
//使用string类型数据初始化
string strCopy(cString);
//使用某个字符串的前n位初始化
string str2(&quot;Hello String&quot;, 5);
//使用指定数量的字符初始化
string str3(6, &apos;a&apos;);                    //str3 = aaaaaa
//string str3(6, &apos;adf&apos;);                //str3 = ffffff
</code></pre></li>
<li><p><strong>访问string的内容</strong></p>
<pre><code>//通过[]访问元素
for (int i = 0; i &lt; str.length(); ++i) {
    cout &lt;&lt; str[i] &lt;&lt; endl;
}
//通过迭代器访问
for (string::const_iterator pos = str.begin()
    ; pos != str.end()
    ; ++pos)
{
    //*pos = &apos;h&apos;;                //报错，pos指向的值是const类型的，不可更改
    cout &lt;&lt; *pos &lt;&lt; endl;
}
//通过迭代器访问
for (string::iterator pos = str.begin()
    ; pos != str.end()
    ; ++pos)
{
    *pos = &apos;6&apos;;                    //不报错
    cout &lt;&lt; *pos &lt;&lt; endl;
}
</code></pre></li>
</ul>
<blockquote>
<p>上面代码中使用迭代器时，使用了一个新的迭代器const_iterator,使用它时，迭代器的值可变，但迭代器指向的值的值不可被改变。</p>
</blockquote>
<ul>
<li><strong>字符串拼接</strong>   </li>
</ul>
<blockquote>
<p>使用+=或者成员函数append()来拼接字符串。</p>
</blockquote>
<pre><code>string str4 = &quot;Hello &quot;;
string str5 = &quot;World &quot;;
string str6(&quot;Beautiful!&quot;);

str4 += str5;                //str4 = Hello World 
str4.append(str6);            //str4 = Hello World Beautiful!
</code></pre><ul>
<li><strong>字符/子字符串查找</strong>   </li>
</ul>
<blockquote>
<p>可以使用string中的成员函数find来查找字符或者子字符串。<br>查找成功返回字符的索引或子字符串首个字符的索引。<br>查找失败返回string::npos（实际值为-1）。</p>
</blockquote>
<pre><code>string str6 = &quot;Hello World&quot;;
//从索引为0初的字符往后进行查找
int index = str6.find(&quot;World&quot;, 0);    
cout &lt;&lt; index &lt;&lt; endl;                        //6
//查找str6中所有 l 的索引
size_t charPos = str6.find(&apos;l&apos;, 0);
while (charPos != string::npos) {            
    cout &lt;&lt; charPos &lt;&lt; endl;                //2 3 9
    charPos = str6.find(&apos;l&apos;, ++charPos);
}
</code></pre><blockquote>
<p>size_t在32位架构上是4字节，在64位架构上是8字节，在不同架构上进行编译时需要注意这个问题。而int在不同架构下都是4字节；且int为带符号数，size_t为无符号数。</p>
</blockquote>
<ul>
<li><p><strong>字符串截短</strong>   </p>
<blockquote>
<p>可以使用成员函数erase()来删除字符串中的字符。<br>使用方法如下： </p>
</blockquote>
<p>  string myStr = “Life is always like this.”;</p>
</li>
</ul>
<p>1.在给定偏移位置（索引值）和指定数目时删除字符。  </p>
<pre><code>//删除索引在 区间[14,19) 内的字符串
myStr.erase(14,5);            //Life is always this.
</code></pre><p>2.删除迭代器iChar指向的字符。</p>
<pre><code>auto iChar = find(myStr.begin(), myStr.end(), &apos;.&apos;);
myStr.erase(iChar);            //Life is always like this
</code></pre><p>3.删除两个迭代器指定范围内的字符串。</p>
<pre><code>myStr.erase(++myStr.begin(), myStr.end());    //L
</code></pre><blockquote>
<p>使用成员方法clear()时，经清楚全部内容并重置string对象。</p>
</blockquote>
<ul>
<li><strong>字符串反转</strong></li>
</ul>
<blockquote>
<p>使用泛型算法std::reverse()对字符串进行反转。(注意不是成员方法)<br>reverse接收两个参数，起始迭代器、终止迭代器，然后将对两个迭代器之间的内容进行反转。</p>
</blockquote>
<pre><code>string myStr = &quot;Life is always like this.&quot;;
reverse(++myStr.begin(), myStr.end());        //L.siht ekil syawla si efi
</code></pre><ul>
<li><strong>字符串大小写转换</strong>   </li>
</ul>
<blockquote>
<p>使用算法std::transform()进行大小写转换。(注意不是成员方法)<br>transform(first, last, r_first, trans)接收四个参数：开始迭代器、终止迭代器、开始迭代器、要执行的变换。<br>要执行转大写操作时 trans = toupper, 要执行转小写操作时 trans = tolower。   </p>
</blockquote>
<pre><code>string myStr = &quot;life is always like this.&quot;;
transform(++myStr.begin(), myStr.end(), ++myStr.begin(), toupper);
//——&gt;lIFE IS ALWAYS LIKE THIS.
transform(++myStr.begin(), myStr.end(), ++myStr.begin(), tolower);
//——&gt;life is always like this.
</code></pre><blockquote>
<p>如果要编写的应用程序需要更好的支持非拉丁字符，如中文与日文时，应使用std::wstring。   </p>
</blockquote>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        </p><p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

