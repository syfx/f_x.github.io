<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="f_x">
  <!-- Open Graph Data -->
  <meta property="og:title" content="最短路径算法Floyd与Dijkstra">
  <meta property="og:description" content="">
  <meta property="og:site_name" content="f_x&#39;s blog">
  <meta property="og:type" content="article">
  <meta property="og:image" content="http://yoursite.com">
  
    <link rel="alternate" href="/atom.xml" title="f_x&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>f_x's blog</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/mypicture3.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">最短路径算法Floyd与Dijkstra</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/syfx">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:782933913@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By f_x</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-04-17</span>
            <span class="time">12:16:47</span>
          </span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/算法/">#算法</a> <a class="tag" href="/tags/最短路径/">#最短路径</a> <a class="tag" href="/tags/图/">#图</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h3 id="一、弗洛伊德算法（Floyd）"><a href="#一、弗洛伊德算法（Floyd）" class="headerlink" title="一、弗洛伊德算法（Floyd）"></a>一、弗洛伊德算法（Floyd）</h3><blockquote>
<p>Floyd算法的思想比较简单，它的核心代码只有5行；</p>
</blockquote>
<pre><code>for (int k = 0; k &lt; G.vCount; ++k)
    for (int i = 0; i &lt; G.vCount; ++i)
        for (int j = 0; j &lt; G.vCount; ++j)
            if (G.arcs[i][j] &gt; G.arcs[i][k] + G.arcs[k][j])
                G.arcs[i][j] = G.arcs[i][k] + G.arcs[k][j];
</code></pre><p> 对于一个有向图G：<br> <img src="http://p.qpic.cn/pic_wework/1948211503/c8cec3d80ab6b3b9e5d697e65a4cfbf9f23b6b3a2a6272f0/0" alt=""></p>
<blockquote>
<p>我们可以认为当前二维数组中的值表示的是两个顶点之间的直接路径长度（即中间不经过其它顶点进行中转时的路径）。这个直接路径并不一定是最短路径。<br>例如：G[1][3] = 6表示从1到3的直接路径长度为6，当我们引入2号顶点作为中转点时，（即先从顶点1走到顶点2，再从顶点2走到顶点3），从顶点1到3的路径长度可以更短，为G[1][2] + G[2][3] = 5;</p>
</blockquote>
<p><strong>上述思想的代码实现非常简单：</strong></p>
<pre><code>void Floyd(Graph G)
{
    for (int k = 0; k &lt; G.vCount; ++k) {
        for (int i = 0; i &lt; G.vCount; ++i) {
            for (int j = 0; j &lt; G.vCount; ++j) {
                if (G.arcs[i][j] &gt; G.arcs[i][k] + G.arcs[k][j])
                    G.arcs[i][j] = G.arcs[i][k] + G.arcs[k][j];
            }
        }
    }
    cout &lt;&lt; &quot;任意两点间的最短距离为：&quot; &lt;&lt; endl;
    //打印最终结果
    ShowGraph(G);
}
</code></pre><blockquote>
<p>这段代码中，最外层的循环用来控制当前允许经过哪个点进行中转。内层的两个循环表示<strong>当经过此中转点时一个顶点到其他所有顶点的距离是否能更短</strong>，若能更短，则更新最短距离。用一句话概括就是：<strong>从i号顶点到j号顶点只经过前k号顶点的最短路径</strong>(比如当要经过k-1顶点进行中转时，图中的储存的路径已经是经过前k-1号顶点时的最短路径了)，这其实是一种“动态规划”的思想（可以根据 <strong>斐波那契数列</strong> 想象一下这个思想）。</p>
</blockquote>
<p>由代码不难看出，Floyd算法的时间复杂度为O(n^3),因为要储存两两顶点间的最短路径，所以空间复杂度为O(n^2)（我在这里没有使用辅助空间，直接在原图中进行操作了）。</p>
<h3 id="二、迪杰斯特拉算法（Dijkstra）"><a href="#二、迪杰斯特拉算法（Dijkstra）" class="headerlink" title="二、迪杰斯特拉算法（Dijkstra）"></a>二、迪杰斯特拉算法（Dijkstra）</h3><blockquote>
<p>Dijkstra算法是一种“单源最短路径算法”（求一个顶点(源点)到其余各个顶点的最短路径），它是一种采用<strong>贪婪策略</strong>（在对问题求解时，总是做出在当前看来是最好的选择）实现的算法。 </p>
</blockquote>
<p> 对于有向图G：<br><img src="http://p.qpic.cn/pic_wework/1948211503/c8cec3d80ab6b3b9e5d697e65a4cfbf9f23b6b3a2a6272f0/0" alt=""></p>
<blockquote>
<p>在算法中，我们声明一个dis数组用来储存源点到其余顶点的的最短路径的“预估值”。以0号顶点为源点，有：    </p>
</blockquote>
<p><img src="http://p.qpic.cn/pic_wework/1948211503/d4d2dfc447ed7b3a3f9b73c399bc945848a023b66c121091/0" alt=""></p>
<blockquote>
<p>在dis表中选择到源点“预估值”最小的顶点（不包括源点本身），为dis[1] = 2;选择1号顶点后，dis[1]的值就可以从“预估值”变成“确定值”了；为什么呢？因为目前到源点最近的顶点为1号顶点，且图中边的权重都是正数（此算法不适用于带负权图），因此，不可能找到一个中转点使得从源点到1号顶点的路径更短。<br>这样的话，我们就还需要使用一个数组book来标记源点到当前点的最短路径是否为确定值（一般使用两个列表来分别储存“预估值”与“确定值”）。     </p>
</blockquote>
<p><img src="http://p.qpic.cn/pic_wework/1948211503/b4b2bfa455b687c5b64bc652096a40a12dab663aab792e89/0" alt=""></p>
<blockquote>
<p>确定源点到1号顶点的最短路径之后，我们对1号顶点的所有出边进行松弛：对于1号顶点，有一条出边1-&gt;2，我们讨论当通过1号顶点进行中转时，源点到2号顶点的路径是否能更短，即比较dis[2]与dis[1] + G[1][2]的大小，如果更短，则更新dis[2]的值。这一过程称为边的松弛。<br>对1号顶点的所有出边松弛完毕后，继续在“预估值”中选取最小的值执行边松弛操作，直到所有“预估值”变为“确定值”。</p>
</blockquote>
<p><strong>代码实现如下：</strong></p>
<pre><code>void Dijkstra(Graph G, int origin)
{
    //dis：储存源点到其它点的最短距离，book：用来做标记，标记到当前点到源点的最短距离是否已被确定
    int *dis = new int[G.vCount], *book = new int[G.vCount];
    int i = 0, j = 0, k = 0, s = 0, min = MaxInt;
    for (i = 0; i &lt; G.vCount; ++i) {
        //GetSub(G,origin)：获取源点在顶点表中的下标
        s = GetSub(G, origin);
        dis[i] = G.arcs[s][i];
    }
    //初始化标记
    for (i = 0; i &lt; G.vCount; ++i) {
        book[i] = 0;
    }
    //设置源点到源点的最短距离为已确定
    book[s] = 1;
    //确定源点到dis表里的所有顶点的最短距离，算法核心
    for (i = 1; i &lt; G.vCount; ++i) {
        min = MaxInt;
        //在未确定到源点最短距离的顶点中找到离源点最近的顶点
        for (j = 1; j &lt; G.vCount; ++j) {
            if (book[j] == 0 &amp;&amp; dis[j] &lt; min) {
                min = dis[j];
                s = j;
            }
        }
        //设置s点到源点的最短距离为已知
        book[s] = 1;
        //对当前顶点的出边进行松弛
        for (k = 0; k &lt; G.vCount; ++k) {
            //判断下标为s的顶点到下标为k的顶点间是否存在边，若存在，对其进行松弛操作
            if (G.arcs[s][k] &lt; MaxInt) {
                if (dis[k] &gt; dis[s] + G.arcs[s][k]) {
                    dis[k] = dis[s] + G.arcs[s][k];
                }
            }
        }
    }
    //打印最短路径
    for (i = 0; i &lt; G.vCount; ++i) {
        cout &lt;&lt; &quot;点&quot; &lt;&lt; origin &lt;&lt; &quot;到&quot; &lt;&lt; G.vexs[i] &lt;&lt; &quot;的最短距离为：&quot; &lt;&lt; dis[i] &lt;&lt; endl;
    }

}
</code></pre><blockquote>
<p>Dijkstra算法的时间复杂度为O(n^2)，在对算法的优化方面，可以使用最小堆在来实现查找最小“预估值”操作，若数据较多，且图为稀疏图时，通过邻接表来储存边，也能在一定程度上优化此算法的性能。</p>
</blockquote>
<p><strong>完整代码：</strong></p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

const int Num = 50;
const int MaxInt = 32767;
struct Graph {
    int vexs[Num];                        //顶点表
    int arcs[Num][Num];            //边表
    int vCount;                            //顶点数量
    int aCount;                            //边数量
};

//获取值在顶点表中下标
int GetSub(Graph G, int value)
{
    int i;
    for (i = 0; i &lt; G.vCount; ++i) {
        if (G.vexs[i] == value)
            break;
    }
    return i;
}
//创建图（邻接矩阵）
void CreatMap(Graph &amp;G)
{
    int t1, t2, w;
    //输入顶点信息
    for (int i = 0; i &lt; G.vCount; ++i) {
        cin &gt;&gt; G.vexs[i];
    }
    for (int i = 0; i &lt; G.vCount; ++i)
        for (int j = 0; j &lt; G.vCount; ++j) {
            G.arcs[i][j] = MaxInt;
            if (i == j)
                G.arcs[i][j] = 0;
        }

    for (int i = 0; i &lt; G.aCount; ++i) {
        cin &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; w;
        int s1 = GetSub(G, t1);
        int s2 = GetSub(G, t2);
        if (s1 != G.vCount &amp;&amp; s2 != G.vCount) {
            G.arcs[s1][s2] = w;
            //G.arcs[s2][s1] = w;            //无向图        
        }    
    }
}
//打印图
void ShowGraph(Graph G) 
{
    for (int i = 0; i &lt; G.vCount; ++i) {
        for (int j = 0; j &lt; G.vCount; ++j) {
            cout &lt;&lt; G.arcs[i][j] &lt;&lt; &quot;\t&quot;;
        }
        cout &lt;&lt; endl;
    }
}

//弗洛伊德算法
void Floyd(Graph G)
{
    for (int k = 0; k &lt; G.vCount; ++k) {
        for (int i = 0; i &lt; G.vCount; ++i) {
            for (int j = 0; j &lt; G.vCount; ++j) {
                if (G.arcs[i][j] &gt; G.arcs[i][k] + G.arcs[k][j])
                    G.arcs[i][j] = G.arcs[i][k] + G.arcs[k][j];
            }
        }
    }
    cout &lt;&lt; &quot;任意两点间的最短距离为：&quot; &lt;&lt; endl;
    //打印最终结果
    ShowGraph(G);
}


/*
迪杰斯特拉算法
G：图
origin：源点（起点）
*/
void Dijkstra(Graph G, int origin)
{
    //dis：储存源点到其它点的最短距离，book：用来做标记，标记到当前点到源点的最短距离是否已被确定
    int *dis = new int[G.vCount], *book = new int[G.vCount];
    int i = 0, j = 0, k = 0, s = 0, min = MaxInt;
    for (i = 0; i &lt; G.vCount; ++i) {
        //GetSub(G,origin)：获取源点在顶点表中的下标
        s = GetSub(G, origin);
        dis[i] = G.arcs[s][i];
    }
    //初始化标记
    for (i = 0; i &lt; G.vCount; ++i) {
        book[i] = 0;
    }
    //设置源点到源点的最短距离为已确定
    book[s] = 1;

    //确定源点到dis表里的所有顶点的最短距离，算法核心
    for (i = 1; i &lt; G.vCount; ++i) {
        min = MaxInt;
        //在未确定到源点最短距离的顶点中找到离源点最近的顶点
        for (j = 1; j &lt; G.vCount; ++j) {
            if (book[j] == 0 &amp;&amp; dis[j] &lt; min) {
                min = dis[j];
                s = j;
            }
        }
        //设置s点到源点的最短距离为已知
        book[s] = 1;
        //对当前顶点的出边进行松弛
        for (k = 0; k &lt; G.vCount; ++k) {
            //判断下标为s的顶点到下标为k的顶点间是否存在边，若存在，对其进行松弛操作
            if (G.arcs[s][k] &lt; MaxInt) {
                if (dis[k] &gt; dis[s] + G.arcs[s][k]) {
                    dis[k] = dis[s] + G.arcs[s][k];
                }
            }
        }
    }

    //打印最短路径
    for (i = 0; i &lt; G.vCount; ++i) {
        cout &lt;&lt; &quot;点&quot; &lt;&lt; origin &lt;&lt; &quot;到&quot; &lt;&lt; G.vexs[i] &lt;&lt; &quot;的最短距离为：&quot; &lt;&lt; dis[i] &lt;&lt; endl;
    }

}

int main()
{
    Graph G;
    cin &gt;&gt; G.vCount &gt;&gt; G.aCount;
    CreatMap(G);
    ShowGraph(G);
    Floyd(G);
    Dijkstra(G, 0);
    system(&quot;pause&quot;);
    return 0;
}


/*
10 13
0 1 2 3 4 5 6 7  8 9
0 1 3
0 6 6
0 4 5
1 2 2 
1 9 9
2 3 1
3 6 3
4 5 3
5 6 2
6 7 2
6 9 3
7 8 6
8 9 8
*/
</code></pre>
        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        </p><p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

