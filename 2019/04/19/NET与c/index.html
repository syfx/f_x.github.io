<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="懂得越多，为难得越少"><title>.NET与c# | fx's study notes</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">.NET与c#</h1><a id="logo" href="/.">fx's study notes</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">.NET与c#</h1><div class="post-meta">Apr 19, 2019<span> | </span><span class="category"><a href="/categories/编程语言/">编程语言</a></span></div><div class="post-content"><h3 id="一、什么是-NET"><a href="#一、什么是-NET" class="headerlink" title="一、什么是.NET"></a>一、什么是.NET</h3><p>.NET是一个微软搭造的开发者平台，它主要包括：   </p>
<ol>
<li>支持(面向)该平台的编程语言(如C#、Visual Basic、C++/CLI、F#、IronPython、IronRuby…)   </li>
<li>用于该平台下开发人员的技术框架体系(<strong>即 .NET实现</strong>)   </li>
<li>用于支持开发人员开发的软件工具(即SDK，如VS2017、VS Code等)   </li>
</ol>
<blockquote>
<ul>
<li>.NET实现<br>Microsoft 积极开发和维护的主要 .NET实现 有4个：.NET Framework、.NET Core、Mono 和 UWP。<br>每个 .NET实现 都具有以下组件：<ol>
<li>一个或多个运行时。    <ul>
<li>.NET运行时<br>  运行时是用于托管程序的执行环境。 操作系统属于运行时环境，但不属于 .NET 运行时。 下面是 .NET 运行时的一些示例：<ul>
<li>.NET Framework 公共语言运行时 (CLR)</li>
<li>.NET Core 核心公共语言运行时 (CoreCLR)</li>
<li>适用于通用 Windows 平台的 .NET Native</li>
<li>用于 Xamarin.iOS、Xamarin.Android、Xamarin.Mac 和 Mono 桌面框架的 Mono 运行时</li>
</ul>
</li>
</ul>
</li>
<li>实现 .NET Standard 并且可实现其他 API 的类库。 示例：.NET Framework 基类库、.NET Core 基类库。  <ul>
<li>.NET Standard<br>  .NET Standard 是一组所有 .NET 平台都应实现的 API。 更正式地说，它是构成协定统一集（这些协定是编写代码的依据）的特定 .NET API 组。 这些协定在每个 .NET实现 中实现。 这可实现不同 .NET实现 间的可移植性，有效地使代码可在任何位置运行。  </li>
</ul>
</li>
<li>可选择包含一个或多个应用程序框架。 示例：ASP.NET、Windows 窗体…(包含在 .NET Framework 中)</li>
<li>可包含开发工具。 某些开发工具在多个实现之间共享。   </li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="NET架构结构"><a href="#NET架构结构" class="headerlink" title=".NET架构结构"></a>.NET架构结构</h4><p><img src="http://p.qpic.cn/pic_wework/1948211503/e9efe5f95612423a370ff2bd921d91a831e60fed1ac22fa4/0" alt=""></p>
<h4 id="1、CTS-通用类型系统-Common-Type-System"><a href="#1、CTS-通用类型系统-Common-Type-System" class="headerlink" title="1、CTS-通用类型系统(Common Type System)"></a>1、CTS-通用类型系统(Common Type System)</h4><blockquote>
<p>.NET实现对语言不可知。 <strong>这意味着程序员可以使用可编译为 IL 的任意语言进行编写代码。而且这些通过不同语言进行编写的代码进行交互(即跨语言操作)</strong>。   </p>
<blockquote>
<p>跨语言操作：比如，c#和vb是.NET下两个不同的语言，不过在c#中写的类可以在vb中当做自家写的类一样正常使用。   </p>
</blockquote>
<p>为透明地执行此操作，必须使用某种通用方式描所有受支持类型。 这正是 CTS 的职责。 其功能如下：      </p>
<ul>
<li>建立用于跨语言执行的框架。   </li>
<li>提供面向对象的模型，支持在 .NET 实现上实现各种语言。   </li>
<li>定义处理类型时所有语言都必须遵守的一组规则。   </li>
<li>提供包含应用程序开发中使用的基本基元数据类型（如 Boolean、Byte、Char 等）的库。  </li>
</ul>
</blockquote>
<h4 id="2、CLS-公共语言规范-Common-Language-Specification"><a href="#2、CLS-公共语言规范-Common-Language-Specification" class="headerlink" title="2、CLS-公共语言规范(Common Language Specification)"></a>2、CLS-公共语言规范(Common Language Specification)</h4><blockquote>
<p>为实现完全互操作性情景，代码中创建的所有对象都必须依赖于使用它的语言（即其调用方）的某些共性。 由于存在多种不同语言，因此 .NET 在公共语言规范 (CLS) 中指定了这些共性。然后定义了一组规则，开发者都遵守这个规则来编码，那么代码就能被任意.NET平台支持的语言所通用。<br>而与其说是规则，不如说它是一组语言互操作的标准规范，这就是CLS。</p>
<blockquote>
<p>注意：<strong>CLS 遵从性的规则仅适用于组件的公共接口，而非其私有实现。</strong></p>
</blockquote>
</blockquote>
<h4 id="3、CLR-公共语言运行-时-或库-Common-Language-Runtime"><a href="#3、CLR-公共语言运行-时-或库-Common-Language-Runtime" class="headerlink" title="3、CLR-公共语言运行 时(或库)(Common Language Runtime)"></a>3、CLR-公共语言运行 时(或库)(Common Language Runtime)</h4><blockquote>
<p>这里指的是 .NET Framework 的运行时。<br>可以将CLR看成一个在 执行时 <strong>管理代码</strong> 的代理（<strong>托管代码</strong>），它提供核心服务（如内存管理（GC）、线程管理和远程处理），而且还强制实施严格的类型安全以及可确保安全性和可靠性的其他形式的代码准确性。事实上，代码管理的概念是 运行时 的基本原则。</p>
<blockquote>
<p>托管：以垃圾回收器（GC）为例，在c#中，内存分配和释放的工作本应该是我们做的，现在这些工作却让GC帮你做了，这就是“托管”的概念。<br>因此，C#被称为托管语言。C#编写的代码也就称为托管代码,C#生成的模块称为托管模块等。<br>从这个角度来看，那些脱离了.NET提供的诸如垃圾回收器这样的环境管制，就是对应的 非托管了。</p>
</blockquote>
<p>CLR管理内存、线程执行、代码执行、代码安全验证、编译以及其他系统服务。这些功能是在CLR上运行的托管代码所固有的。这套环境及体系之完善，以至于就像一个小型的系统一样，所以通常形象的称CLR为”.NET虚拟机”。</p>
</blockquote>
<h4 id="NET程序的编译执行"><a href="#NET程序的编译执行" class="headerlink" title=".NET程序的编译执行"></a>.NET程序的编译执行</h4><blockquote>
<ul>
<li>对于用非托管语言(c/c++)编写的程序源代码，编译时翻译器将源码翻译为本地 机器语言，以文件形式保存在硬盘上；运行时，操作系统将文件读出到内存，然后CPU从内存中取出指令执行。    </li>
<li>对于托管代码，编译时将源码翻译为微软中间语言（IL）代码，运行的时候通过JIT（即时编译器）翻译为本地机器语言，同时.NET代码运行时有一个CLR环境来管理程序。   <blockquote>
<p>翻译器与解释器：   </p>
<ul>
<li>在编译时<strong>翻译器</strong>将源代码翻译成机器语言保存到文件中（例如C/C++）；执行效率高，不过难以移植。   </li>
<li>在运行时<strong>解释器</strong>对源代码逐行进行翻译和执行（例如Python）；执行效率较低，不过易于移植。   </li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><img src="http://p.qpic.cn/pic_wework/1948211503/01070d1133a261b41edd9346720be2c008e98d1b93db163c/0" alt="">   </p>
<h3 id="二、C-简介"><a href="#二、C-简介" class="headerlink" title="二、C#简介"></a>二、C#简介</h3><h4 id="1、-C-及其特点"><a href="#1、-C-及其特点" class="headerlink" title="1、 C#及其特点"></a>1、 C#及其特点</h4><blockquote>
<p>C#是微软公司在2000年7月发布的一种全新且<strong>简单、安全、面向对象</strong>的程序设计语言，是专门为.NET的应用而开发的语言。它吸收了C++、Visual Basic、Delphi、Java等语言的优点，体现了当今最新的程序设计技术的功能和精华。C#继承了C语言的语法风格，同时又继承了C++的面向对象特性。不同的是，C#的对象模型已经面向Internet进行了重新设计，使用的是.NET框架的类库；<strong>C#不再提供对指针类型的支持，使得程序不能随便访问内存地址空间，从而更加健壮；C#不再支持 多重继承，避免了以往类层次结构中由于多重继承带来的可怕后果</strong>。.NET框架为C#提供了一个强大的、易用的、逻辑结构一致的程序设计环境。同时，公共语言运行时（Common Language Runtime）为C#程序语言提供了一个托管的运行时环境，使程序比以往更加稳定、安全。<br>总结一下，c#特点有：    </p>
<ul>
<li>语言简洁。   </li>
<li>保留了C++的强大功能。   </li>
<li>快速应用开发功能。   </li>
<li>语言的自由性。   </li>
<li>强大的Web服务器控件。   </li>
<li>支持跨平台。   </li>
<li>与XML相融合。   </li>
</ul>
</blockquote>
<h4 id="2、-c-存在哪些缺点呢？"><a href="#2、-c-存在哪些缺点呢？" class="headerlink" title="2、 c#存在哪些缺点呢？"></a>2、 c#存在哪些缺点呢？</h4><blockquote>
<ul>
<li>不适合开发高性能的程序：因为中间语言和编译过程，比C/C++等语言会慢一些，还有就是内存自动回收机制导致难以立即释放不需要的内存，不采用(不建议)内联函数和析构函数。   </li>
<li>Windows平台以外支持有限： 因为除Windows外，还没有其他操作系统上的稳定版本的.Net Framework环境，提供给.Net 程序来运行。</li>
</ul>
</blockquote>
<h4 id="3、-c-与其它语言的比较"><a href="#3、-c-与其它语言的比较" class="headerlink" title="3、 c#与其它语言的比较"></a>3、 c#与其它语言的比较</h4><blockquote>
<ul>
<li>C#与C++的比较      <ul>
<li>编译目标：C++代码直接编译为本地可执行代码，而C#默认编译为中间语言（IL）代码，执行时再通过Just-In-Time将需要的模块临时编译成本地代码。   </li>
<li>内存管理：C++需要显式地删除动态分配给堆的内存，而C#不需要这么做，C#采用垃圾回收机制自动在合适的时机回收不再使用的内存。   </li>
<li>指针：C++中大量地使用指针，而C#使用对类实例的引用，如果确实想在C#中使用指针，必须声明该内容是非安全的。不过，一般情况下C#中没有必要使用指针。   </li>
<li>字符串处理：在C#中，字符串是作为一种基本数据类型来对待的，因此比C++中对字符串的处理要简单得多。   </li>
<li>库：C++依赖于以继承和模板为基础的标准库，C#则依赖于.NET基库。</li>
<li>C++允许类的多继承，而C#只允许类的单继承，而通过接口实现多继承。</li>
</ul>
</li>
<li>C#与Java的比较<ul>
<li>C#面向对象的程度比Java高。   </li>
<li>C#中的基本类型都是面向对象的。   </li>
<li>C#具有比Java更强大的功能。   </li>
<li>C#语言的执行速度比Java快。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="4、值类型与引用类型，装箱与拆箱"><a href="#4、值类型与引用类型，装箱与拆箱" class="headerlink" title="4、值类型与引用类型，装箱与拆箱"></a>4、值类型与引用类型，装箱与拆箱</h4><blockquote>
<ul>
<li>在c#中，<strong>值类型</strong>的变量直接储存数据，数据存在栈中，执行复制操作时，复制了一个新的数据给另一个变量，两个数据相互独立；而<strong>引用类型</strong>持有的是数据的引用，在栈上开辟一小块内存储存一个地址，地址指向堆中实际储存数据的内存（相当于c++中的指针，只是c#做了一些工作使这个指针与它指向的对象更紧密的联系在一起了）。   </li>
<li>数据从值类型转换为引用类型的过程被称为<strong>“装箱”</strong>，从引用类型转换为值类型的过程被称为<strong>“拆箱”</strong>。装箱与拆箱操作比较费时，应该尽量避免装箱拆箱操作。</li>
</ul>
</blockquote>
<p><strong>值类型与引用类型的分类</strong><br><img src="http://p.qpic.cn/pic_wework/1948211503/fafcf6eaab4a7774885510cc4dd684254710f43750315fcb/0" alt=""></p>
<p>.NET中六个重要的概念：栈、堆、值类型、引用类型、装箱和拆箱：<br><a href="https://www.cnblogs.com/edisonchou/p/3947170.html" target="_blank" rel="noopener">https://www.cnblogs.com/edisonchou/p/3947170.html</a>   </p>
<p>什么是.NET：<br><a href="https://www.cnblogs.com/1996V/p/9037603.html#net3" target="_blank" rel="noopener">https://www.cnblogs.com/1996V/p/9037603.html#net3</a></p>
<p><strong>注：</strong>图片来自网上</p>
</div><div class="tags"><a href="/tags/NET/">.NET</a><a href="/tags/c/">c#</a></div><div class="post-nav"><a class="pre" href="/2019/04/24/c-高级知识点/">c#高级知识点</a><a class="next" href="/2019/04/17/最短路径算法Floyd与Dijkstra/">最短路径算法Floyd与Dijkstra</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://syfx.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/图形渲染/">图形渲染</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/总结/">总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程模式/">编程模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/c/" style="font-size: 15px;">c#</a> <a href="/tags/OpenGL/" style="font-size: 15px;">OpenGL</a> <a href="/tags/STL/" style="font-size: 15px;">STL</a> <a href="/tags/Unity3D/" style="font-size: 15px;">Unity3D</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/操作系统/" style="font-size: 15px;">操作系统</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/NET/" style="font-size: 15px;">.NET</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/最短路径/" style="font-size: 15px;">最短路径</a> <a href="/tags/图/" style="font-size: 15px;">图</a> <a href="/tags/Unity/" style="font-size: 15px;">Unity</a> <a href="/tags/二叉树/" style="font-size: 15px;">二叉树</a> <a href="/tags/指针/" style="font-size: 15px;">指针</a> <a href="/tags/链表/" style="font-size: 15px;">链表</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/03/C-知识点总结/">C++知识点总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/22/动态规划/">动态规划</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/21/OpenGL入门/">OpenGL入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/14/Unity3D性能优化/">Unity3D性能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/22/Unity3DAssetBundle/">Unity3D AssetBundle</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/20/Unity3D资源处理/">Unity3D资源处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/24/c-高级知识点/">c#高级知识点</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/19/NET与c/">.NET与c#</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/最短路径算法Floyd与Dijkstra/">最短路径算法Floyd与Dijkstra</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/04/常用排序算法/">常用排序算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">fx's study notes.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>