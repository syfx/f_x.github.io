<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="懂得越多，为难得越少"><title>Unity3D资源处理 | fx's study notes</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.6"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Unity3D资源处理</h1><a id="logo" href="/.">fx's study notes</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Unity3D资源处理</h1><div class="post-meta">May 20, 2019<span> | </span><span class="category"><a href="/categories/总结/">总结</a></span></div><div class="post-content"><h3 id="GUID与fileID-本地ID"><a href="#GUID与fileID-本地ID" class="headerlink" title="GUID与fileID(本地ID)"></a>GUID与fileID(本地ID)</h3><p>Unity会为每个导入到Assets目录中的资源创建一个meta文件，文件中记录了GUID，GUID用来记录资源之间的引用关系。还有fileID（本地ID），用于标识资源内部的资源。资源间的依赖关系通过GUID来确定；资源内部的依赖关系使用fileID来确定。</p>
<h3 id="InstanceID-实例ID"><a href="#InstanceID-实例ID" class="headerlink" title="InstanceID(实例ID)"></a>InstanceID(实例ID)</h3><p>Unity为了在运行时，提升资源管理的效率，会在内部维护一个缓存表，负责将文件的GUID与fileID转换成为整数数值，这个数值在本次会话中是唯一的，称作实例ID(InstanceID)。<br>程序启动时，实例ID缓存与所有工程内建的对象(例如在场景中被引用)，以及Resource文件夹下的所有对象，都会被一起初始化。如果在运行时导入了新的资源，或从AssetBundle中载入了新的对象，缓存会被更新，并为这些对象添加相应条目。实例ID仅在失效时才会被从缓存中移除，当提供了指定文件GUID和fileID的AssetBundle被卸载时会产生移除操作。<br>卸载AssetBundle会使实例ID失效，实例ID与其文件GUID和fileID之间的映射会被删除以便节省内存。重新载入AssetBundle后，载入的每个对象都会获得新的实例ID。   </p>
<h3 id="资源的生命周期"><a href="#资源的生命周期" class="headerlink" title="资源的生命周期"></a>资源的生命周期</h3><p>Object从内存中加载或卸载的时间点是定义好的。Object有两种加载方式：自动加载与外部加载。当对象的实例ID与对象本身解引用，对象当前未被加载到内存中，而且可以定位到对象的源数据，此时对象会被自动加载。对象也可以外部加载，通过在脚本中创建对象或者调用资源加载API来载入对象（例如：AssetBundle.LoadAsset）<br>对象加载后，Unity会尝试修复任何可能存在的引用关系，通过将每个引用文件的GUID与FileID转化成实例ID的方式。<br>一旦对象的实例ID被解引用且满足以下两个标准时，对象会被强制加载：   </p>
<ul>
<li>实例ID引用了一个没有被加载的对象。   </li>
<li>实例ID在缓存中存在对应的有效GUID和本地ID。   </li>
</ul>
<p>如果文件GUID和本地ID没有实例ID，或一个已卸载对象的实例ID引用了非法的文件GUID和本地ID，则引用本身会被保留，但实例对象不会被加载。在Unity编辑器中表现为空引用，在运行的应用中，或场景视图里，空对象会以多种方式表示，取决于丢失对象的类型：网格会变得不可见，纹理呈现为紫红色等等。</p>
<h3 id="MonoScripts"><a href="#MonoScripts" class="headerlink" title="MonoScripts"></a>MonoScripts</h3><p>一个MonoScripts含有三个字符串：程序集名称，类名称，命名空间。<br>构建工程时，Unity会收集Assets文件夹中独立的脚本文件并编译他们，组成一个Mono程序库。Unity会将Assets目录中的语言分开编译，Assets/Plugins目录中的脚本同理。Plugin子目录之外的C#脚本会放在Assembly-CSharp.dll中。而Plugin及其子目录中的脚本则放置在Assembly-CSharp-firstpass.all中。<br>这些程序库会被MonoScripts所引用，并在程序第一次启动时被加载。</p>
<h3 id="资源文件夹Assets"><a href="#资源文件夹Assets" class="headerlink" title="资源文件夹Assets"></a>资源文件夹Assets</h3><p>为Unity编辑器下的资源文件夹，Unity项目编辑时的所有资源都将置入此文件夹内。在编辑器下，可以使用以下方法获得资源对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssetDatabase.LoadAssetAtPath(&quot;Assets/x.txt&quot;);</span><br></pre></td></tr></table></figure>
<p>注意：此方法只能在编辑器下使用，当项目打包后，在游戏内无法运作。参数为包含Assets内的文件全路径，并且需要文件后缀。<br>Assets下的资源除特殊文件夹内，或者在会打入包内的场景中引用的资源，其余资源不会被打入包中。</p>
<h3 id="Resources资源载入"><a href="#Resources资源载入" class="headerlink" title="Resources资源载入"></a>Resources资源载入</h3><p>Assets下的特殊文件夹，此文件夹内的资源将会在项目打包时，全部打入包内，并能通过以下方法获得对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Resources.Load(&quot;fileName&quot;);   </span><br><span class="line">Resources.Load(&quot;fileName&quot;);</span><br></pre></td></tr></table></figure>
<p>注意：函数内的参数为相对于Resource目录下的文件路径与名称,不包含后缀。<br>Assets目录下可以拥有任意路径及数量的Resources文件夹，在运行时,Resources下的文件路径将被合并。<br>例：Assets/Resources/test.txt与Assets/TestFloder/Resources/test.png在使用Resource.Load (“test”)载入时，将被视为同一资源，只会返回第一个符合名称的对象。如果使用Resource.Load(“test”)将返回text.txt；<br>如果在Resources下有相同路径及名称的资源，使用以上方法只能获得第一个符合查找条件的对象，使用以下方法能或得到所有符合条件的对象：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] assets = Resources.LoadAll(&quot;fileName&quot;);    </span><br><span class="line">TextAsset[] assets = Resources.LoadAll(&quot;fileName&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在工程进行打包后，Resource文件夹中的资源将进行加密与压缩，打包后的程序内将不存在Resource文件夹，故无法通过路径访问以及更新资源。<br>在程序启动时会为Resource下的所有对象进行初始化，构建实例ID。随着Resource内资源的数量增加，此过程耗时的增加是非线性的。故会出现程序启动时间过长的问题，请密切留意Resource内的资源数量   </p>
</blockquote>
<h3 id="卸载资源"><a href="#卸载资源" class="headerlink" title="卸载资源"></a>卸载资源</h3><p>所有实例化后的 GameObject 可以通过 Destroy 函数销毁。请留意 Object 与 GameObject 之间的区别与联系<br>Object 可以通过 Resources 中的相关 Api 进行卸载：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Resources.UnloadAsset(Object);			//卸载对应Object   </span><br><span class="line">Resources.UnloadUnusedAssets();			//卸载所有没有被引用以及实例化的Object</span><br></pre></td></tr></table></figure>
<p>注意以下情况：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = Resources.Load(&quot;MyPrefab&quot;);    </span><br><span class="line">GameObject instance = Instantiate(obj) as GameObjct;    </span><br><span class="line">...</span><br><span class="line">Destroy(instance);    </span><br><span class="line">Resources.UnloadUnusedAssets(); 		//卸载资源</span><br></pre></td></tr></table></figure>
<p>此时UnloadUnusedAssets将不会生效，因为obj依然引用了MyPrefab，需要将obj = null，才可生效。   </p>
<h3 id="StreamingAssets"><a href="#StreamingAssets" class="headerlink" title="StreamingAssets"></a>StreamingAssets</h3><blockquote>
<p>概述<br>StreamingAssets 文件夹为流媒体文件夹，此文件夹内的资源将不会经过压缩与加密，原封不动的打包进游戏包内。在游戏安装时，StreamAssets 文件件内的资源将根据平台，移动到对应的文件夹内。 StreamingAssets 文件夹在 Android 与 IOS 平台上为只读文件夹。</p>
</blockquote>
<p>你可以使用以下函数获得不同平台下的StreamingAssets文件夹路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application.streamingAssetsPath</span><br></pre></td></tr></table></figure>
<p>参考以下各平台下 StreamingAssets 文件夹的等价路径，Application.dataPath 为程序安装路径。Android 平台下的路径比较特殊，请留意此路径的前缀，在一些资源读取的方法中是不必要的（eg：AssetBundle.LoadFromFile）    </p>
<ul>
<li>Application.dataPath+”/StreamingAssets”//Windows OR MacOS    </li>
<li>Application.dataPath+”/Raw” //IOS    </li>
<li>“jar:file://“+Application.dataPath+”!/assets/“ //Android<br>StreamingAssets文件夹下的文件在游戏中只能通过 IOStream 或者 WWW 的方式读取<br>io方式：   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileStream stream = File.Open(Application.streamingAssetsPath + &quot;/fileName&quot;, FileMode.Open);</span><br></pre></td></tr></table></figure>
<p>WWW方式（注意协议与不同平台下路径的区别）：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private IEnumerator Start()   </span><br><span class="line">&#123;   </span><br><span class="line">    WWW www = new WWW(Application.streamingAssetsPath + &quot;/Cube&quot;);   </span><br><span class="line">    yield return www; </span><br><span class="line">	//将获取的web页面的内容作为字符串返回（只读）    </span><br><span class="line">    Debug.Log(www.text);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AssetBundle特有的资源加载方式：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//同步地从磁盘上的文件加载    </span><br><span class="line">AssetBundle.LoadFromFile(assetbundlePath+&quot;/name.unity3d&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="PersistentDataPath"><a href="#PersistentDataPath" class="headerlink" title="PersistentDataPath"></a>PersistentDataPath</h3><p>路径：Application.persistentDataPath<br>Unity指定的一个可读写的外部文件夹，该路径因平台及系统配置不同而不同。可以用来保存数据及文件。该目录下的资源不会在打包时被打入包中，也不会自动被Unity导入及转换。该文件夹只能通过IOStream以及WWW的方式进行资源加载。   </p>
<h3 id="WWW载入资源"><a href="#WWW载入资源" class="headerlink" title="WWW载入资源"></a>WWW载入资源</h3><p>WWW是一个Unity封装的网络下载模块，支持Http以及file两种URL协议，并会尝试将资源转换成Unity能使用的AssetsComponents（如果资源是Unity不支持的格式，则只能取出byte[]）。具体对应的格式参考第一章表格。WWW加载是异步加载方法。<br>每次new WWW时，Unity都会启用一个线程去进行下载。通过此方式读取或者下载资源，会在内存中生成WebStream，WebStream为下载文件转换后的内容，占用内存较大。使用WWW.Dispose将终止仍在加载过程中的进程，并释放掉内存中的WebStream。 如果WWW不及时释放，将占用大量的内存。<br>如果载入的为Assetbundle且进行过压缩，则还会在内存中占用一份AssetBundle解压用的缓冲区Deompresion Buffer,AssetBundle压缩格式的不同会影响此区域的大小。<br>WWW.LoadFromCacheOrDownload静态方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int version = 1;    </span><br><span class="line">WWW.LoadFromCacheOrDownload(PathURL+&quot;/fileName&quot;,version);</span><br></pre></td></tr></table></figure>
<p>使用此方式加载，将先从硬盘上的存储区域查找是否有对应的资源，再验证本地Version与传入值之间的关系，如果传入的Version&gt;本地Version，则从传入的URL地址下载资源，并缓存到硬盘，替换掉现有资源，如果传入的Version&lt;=本地Version，则直接从本地读取资源；如果本地没有存储资源，则下载资源。此方法的存储路径无法设定以及访问。使用此方法载入资源，不会在内存中生成WebStream（其实已经将WebStream保存在本地），如果硬盘空间不够进行存储，将自动使用new WWW方法加载，并在内存中生成WebStream。在本地存储中，使用fileName作为标识符，所以更换URL地址而不更改文件名，将不会造成缓存资源的变更。保存的路径无法更改，也没有接口去获取此路径。</p>
</div><div class="tags"><a href="/tags/Unity3D/">Unity3D</a></div><div class="post-nav"><a class="pre" href="/2019/05/22/Unity3DAssetBundle/">Unity3D AssetBundle</a><a class="next" href="/2019/04/24/c-高级知识点/">c#高级知识点</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.6"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.6"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.6"></script><script>var gitalk = new Gitalk({
  clientID: 'syfx.github.io',
  clientSecret: 'ff484e20f1e6f752134cb70ae1a43f30a7542849',
  repo: 'syfx.github.io',
  owner: 'syfx',
  admin: ['syfx'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://syfx.github.io"></form></div><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="http://syfx.github.io"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/图形渲染/">图形渲染</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/总结/">总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程模式/">编程模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/二叉树/" style="font-size: 15px;">二叉树</a> <a href="/tags/OpenGL/" style="font-size: 15px;">OpenGL</a> <a href="/tags/STL/" style="font-size: 15px;">STL</a> <a href="/tags/Unity/" style="font-size: 15px;">Unity</a> <a href="/tags/Unity3D/" style="font-size: 15px;">Unity3D</a> <a href="/tags/操作系统/" style="font-size: 15px;">操作系统</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/指针/" style="font-size: 15px;">指针</a> <a href="/tags/NET/" style="font-size: 15px;">.NET</a> <a href="/tags/c/" style="font-size: 15px;">c#</a> <a href="/tags/最短路径/" style="font-size: 15px;">最短路径</a> <a href="/tags/图/" style="font-size: 15px;">图</a> <a href="/tags/链表/" style="font-size: 15px;">链表</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/03/C-知识点总结/">C++知识点总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/22/动态规划/">动态规划</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/21/OpenGL入门/">OpenGL入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/14/Unity3D性能优化/">Unity3D性能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/22/Unity3DAssetBundle/">Unity3D AssetBundle</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/20/Unity3D资源处理/">Unity3D资源处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/24/c-高级知识点/">c#高级知识点</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/19/NET与c/">.NET与c#</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/最短路径算法Floyd与Dijkstra/">最短路径算法Floyd与Dijkstra</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/04/常用排序算法/">常用排序算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://learnopengl-cn.github.io/" title="OpenGL" target="_blank">OpenGL</a><ul></ul><a href="https://gpp.tkchu.me/" title="游戏编程模式" target="_blank">游戏编程模式</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">fx's study notes.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.6" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.6" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" color="100,99,98" opacity="0.7" zindex="-1" count="150" src="//lib.baomitu.com/canvas-nest.js/2.0.4/canvas-nest.umd.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.6"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.6"></script></div></body></html>