<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Unity3D资源处理"><meta name="keywords" content="Unity3D"><meta name="author" content="fx"><meta name="copyright" content="fx"><title>Unity3D资源处理 | fx's study notes</title><link rel="shortcut icon" href="/fx.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#GUID与fileID-本地ID"><span class="toc-number">1.</span> <span class="toc-text">GUID与fileID(本地ID)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InstanceID-实例ID"><span class="toc-number">2.</span> <span class="toc-text">InstanceID(实例ID)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#资源的生命周期"><span class="toc-number">3.</span> <span class="toc-text">资源的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MonoScripts"><span class="toc-number">4.</span> <span class="toc-text">MonoScripts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#资源文件夹Assets"><span class="toc-number">5.</span> <span class="toc-text">资源文件夹Assets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Resources资源载入"><span class="toc-number">6.</span> <span class="toc-text">Resources资源载入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#卸载资源"><span class="toc-number">7.</span> <span class="toc-text">卸载资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StreamingAssets"><span class="toc-number">8.</span> <span class="toc-text">StreamingAssets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PersistentDataPath"><span class="toc-number">9.</span> <span class="toc-text">PersistentDataPath</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WWW载入资源"><span class="toc-number">10.</span> <span class="toc-text">WWW载入资源</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">fx</div><div class="author-info__description text-center">懂得越多，为难得越少</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">22</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">16</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">5</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Learn</div><a class="author-info-links__name text-center" href="https://learnopengl-cn.github.io/">OpenGL</a><a class="author-info-links__name text-center" href="https://gpp.tkchu.me/">游戏编程模式</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://p.qpic.cn/pic_wework/1948211503/babcaaaa9297aa741e49ed921650a20476d250d0718288dc/0)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">fx's study notes</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">Unity3D资源处理</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-20</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/总结/">总结</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h3 id="GUID与fileID-本地ID"><a href="#GUID与fileID-本地ID" class="headerlink" title="GUID与fileID(本地ID)"></a>GUID与fileID(本地ID)</h3><p>Unity会为每个导入到Assets目录中的资源创建一个meta文件，文件中记录了GUID，GUID用来记录资源之间的引用关系。还有fileID（本地ID），用于标识资源内部的资源。资源间的依赖关系通过GUID来确定；资源内部的依赖关系使用fileID来确定。</p>
<h3 id="InstanceID-实例ID"><a href="#InstanceID-实例ID" class="headerlink" title="InstanceID(实例ID)"></a>InstanceID(实例ID)</h3><p>Unity为了在运行时，提升资源管理的效率，会在内部维护一个缓存表，负责将文件的GUID与fileID转换成为整数数值，这个数值在本次会话中是唯一的，称作实例ID(InstanceID)。<br>程序启动时，实例ID缓存与所有工程内建的对象(例如在场景中被引用)，以及Resource文件夹下的所有对象，都会被一起初始化。如果在运行时导入了新的资源，或从AssetBundle中载入了新的对象，缓存会被更新，并为这些对象添加相应条目。实例ID仅在失效时才会被从缓存中移除，当提供了指定文件GUID和fileID的AssetBundle被卸载时会产生移除操作。<br>卸载AssetBundle会使实例ID失效，实例ID与其文件GUID和fileID之间的映射会被删除以便节省内存。重新载入AssetBundle后，载入的每个对象都会获得新的实例ID。   </p>
<h3 id="资源的生命周期"><a href="#资源的生命周期" class="headerlink" title="资源的生命周期"></a>资源的生命周期</h3><p>Object从内存中加载或卸载的时间点是定义好的。Object有两种加载方式：自动加载与外部加载。当对象的实例ID与对象本身解引用，对象当前未被加载到内存中，而且可以定位到对象的源数据，此时对象会被自动加载。对象也可以外部加载，通过在脚本中创建对象或者调用资源加载API来载入对象（例如：AssetBundle.LoadAsset）<br>对象加载后，Unity会尝试修复任何可能存在的引用关系，通过将每个引用文件的GUID与FileID转化成实例ID的方式。<br>一旦对象的实例ID被解引用且满足以下两个标准时，对象会被强制加载：   </p>
<ul>
<li>实例ID引用了一个没有被加载的对象。   </li>
<li>实例ID在缓存中存在对应的有效GUID和本地ID。   </li>
</ul>
<p>如果文件GUID和本地ID没有实例ID，或一个已卸载对象的实例ID引用了非法的文件GUID和本地ID，则引用本身会被保留，但实例对象不会被加载。在Unity编辑器中表现为空引用，在运行的应用中，或场景视图里，空对象会以多种方式表示，取决于丢失对象的类型：网格会变得不可见，纹理呈现为紫红色等等。</p>
<h3 id="MonoScripts"><a href="#MonoScripts" class="headerlink" title="MonoScripts"></a>MonoScripts</h3><p>一个MonoScripts含有三个字符串：程序集名称，类名称，命名空间。<br>构建工程时，Unity会收集Assets文件夹中独立的脚本文件并编译他们，组成一个Mono程序库。Unity会将Assets目录中的语言分开编译，Assets/Plugins目录中的脚本同理。Plugin子目录之外的C#脚本会放在Assembly-CSharp.dll中。而Plugin及其子目录中的脚本则放置在Assembly-CSharp-firstpass.all中。<br>这些程序库会被MonoScripts所引用，并在程序第一次启动时被加载。</p>
<h3 id="资源文件夹Assets"><a href="#资源文件夹Assets" class="headerlink" title="资源文件夹Assets"></a>资源文件夹Assets</h3><p>为Unity编辑器下的资源文件夹，Unity项目编辑时的所有资源都将置入此文件夹内。在编辑器下，可以使用以下方法获得资源对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssetDatabase.LoadAssetAtPath(&quot;Assets/x.txt&quot;);</span><br></pre></td></tr></table></figure>
<p>注意：此方法只能在编辑器下使用，当项目打包后，在游戏内无法运作。参数为包含Assets内的文件全路径，并且需要文件后缀。<br>Assets下的资源除特殊文件夹内，或者在会打入包内的场景中引用的资源，其余资源不会被打入包中。</p>
<h3 id="Resources资源载入"><a href="#Resources资源载入" class="headerlink" title="Resources资源载入"></a>Resources资源载入</h3><p>Assets下的特殊文件夹，此文件夹内的资源将会在项目打包时，全部打入包内，并能通过以下方法获得对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Resources.Load(&quot;fileName&quot;);   </span><br><span class="line">Resources.Load(&quot;fileName&quot;);</span><br></pre></td></tr></table></figure>
<p>注意：函数内的参数为相对于Resource目录下的文件路径与名称,不包含后缀。<br>Assets目录下可以拥有任意路径及数量的Resources文件夹，在运行时,Resources下的文件路径将被合并。<br>例：Assets/Resources/test.txt与Assets/TestFloder/Resources/test.png在使用Resource.Load (“test”)载入时，将被视为同一资源，只会返回第一个符合名称的对象。如果使用Resource.Load(“test”)将返回text.txt；<br>如果在Resources下有相同路径及名称的资源，使用以上方法只能获得第一个符合查找条件的对象，使用以下方法能或得到所有符合条件的对象：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] assets = Resources.LoadAll(&quot;fileName&quot;);    </span><br><span class="line">TextAsset[] assets = Resources.LoadAll(&quot;fileName&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在工程进行打包后，Resource文件夹中的资源将进行加密与压缩，打包后的程序内将不存在Resource文件夹，故无法通过路径访问以及更新资源。<br>在程序启动时会为Resource下的所有对象进行初始化，构建实例ID。随着Resource内资源的数量增加，此过程耗时的增加是非线性的。故会出现程序启动时间过长的问题，请密切留意Resource内的资源数量   </p>
</blockquote>
<h3 id="卸载资源"><a href="#卸载资源" class="headerlink" title="卸载资源"></a>卸载资源</h3><p>所有实例化后的 GameObject 可以通过 Destroy 函数销毁。请留意 Object 与 GameObject 之间的区别与联系<br>Object 可以通过 Resources 中的相关 Api 进行卸载：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Resources.UnloadAsset(Object);			//卸载对应Object   </span><br><span class="line">Resources.UnloadUnusedAssets();			//卸载所有没有被引用以及实例化的Object</span><br></pre></td></tr></table></figure>
<p>注意以下情况：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = Resources.Load(&quot;MyPrefab&quot;);    </span><br><span class="line">GameObject instance = Instantiate(obj) as GameObjct;    </span><br><span class="line">...</span><br><span class="line">Destroy(instance);    </span><br><span class="line">Resources.UnloadUnusedAssets(); 		//卸载资源</span><br></pre></td></tr></table></figure>
<p>此时UnloadUnusedAssets将不会生效，因为obj依然引用了MyPrefab，需要将obj = null，才可生效。   </p>
<h3 id="StreamingAssets"><a href="#StreamingAssets" class="headerlink" title="StreamingAssets"></a>StreamingAssets</h3><blockquote>
<p>概述<br>StreamingAssets 文件夹为流媒体文件夹，此文件夹内的资源将不会经过压缩与加密，原封不动的打包进游戏包内。在游戏安装时，StreamAssets 文件件内的资源将根据平台，移动到对应的文件夹内。 StreamingAssets 文件夹在 Android 与 IOS 平台上为只读文件夹。</p>
</blockquote>
<p>你可以使用以下函数获得不同平台下的StreamingAssets文件夹路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application.streamingAssetsPath</span><br></pre></td></tr></table></figure>
<p>参考以下各平台下 StreamingAssets 文件夹的等价路径，Application.dataPath 为程序安装路径。Android 平台下的路径比较特殊，请留意此路径的前缀，在一些资源读取的方法中是不必要的（eg：AssetBundle.LoadFromFile）    </p>
<ul>
<li>Application.dataPath+”/StreamingAssets”//Windows OR MacOS    </li>
<li>Application.dataPath+”/Raw” //IOS    </li>
<li>“jar:file://“+Application.dataPath+”!/assets/“ //Android<br>StreamingAssets文件夹下的文件在游戏中只能通过 IOStream 或者 WWW 的方式读取<br>io方式：   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileStream stream = File.Open(Application.streamingAssetsPath + &quot;/fileName&quot;, FileMode.Open);</span><br></pre></td></tr></table></figure>
<p>WWW方式（注意协议与不同平台下路径的区别）：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private IEnumerator Start()   </span><br><span class="line">&#123;   </span><br><span class="line">    WWW www = new WWW(Application.streamingAssetsPath + &quot;/Cube&quot;);   </span><br><span class="line">    yield return www; </span><br><span class="line">	//将获取的web页面的内容作为字符串返回（只读）    </span><br><span class="line">    Debug.Log(www.text);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AssetBundle特有的资源加载方式：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//同步地从磁盘上的文件加载    </span><br><span class="line">AssetBundle.LoadFromFile(assetbundlePath+&quot;/name.unity3d&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="PersistentDataPath"><a href="#PersistentDataPath" class="headerlink" title="PersistentDataPath"></a>PersistentDataPath</h3><p>路径：Application.persistentDataPath<br>Unity指定的一个可读写的外部文件夹，该路径因平台及系统配置不同而不同。可以用来保存数据及文件。该目录下的资源不会在打包时被打入包中，也不会自动被Unity导入及转换。该文件夹只能通过IOStream以及WWW的方式进行资源加载。   </p>
<h3 id="WWW载入资源"><a href="#WWW载入资源" class="headerlink" title="WWW载入资源"></a>WWW载入资源</h3><p>WWW是一个Unity封装的网络下载模块，支持Http以及file两种URL协议，并会尝试将资源转换成Unity能使用的AssetsComponents（如果资源是Unity不支持的格式，则只能取出byte[]）。具体对应的格式参考第一章表格。WWW加载是异步加载方法。<br>每次new WWW时，Unity都会启用一个线程去进行下载。通过此方式读取或者下载资源，会在内存中生成WebStream，WebStream为下载文件转换后的内容，占用内存较大。使用WWW.Dispose将终止仍在加载过程中的进程，并释放掉内存中的WebStream。 如果WWW不及时释放，将占用大量的内存。<br>如果载入的为Assetbundle且进行过压缩，则还会在内存中占用一份AssetBundle解压用的缓冲区Deompresion Buffer,AssetBundle压缩格式的不同会影响此区域的大小。<br>WWW.LoadFromCacheOrDownload静态方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int version = 1;    </span><br><span class="line">WWW.LoadFromCacheOrDownload(PathURL+&quot;/fileName&quot;,version);</span><br></pre></td></tr></table></figure>
<p>使用此方式加载，将先从硬盘上的存储区域查找是否有对应的资源，再验证本地Version与传入值之间的关系，如果传入的Version&gt;本地Version，则从传入的URL地址下载资源，并缓存到硬盘，替换掉现有资源，如果传入的Version&lt;=本地Version，则直接从本地读取资源；如果本地没有存储资源，则下载资源。此方法的存储路径无法设定以及访问。使用此方法载入资源，不会在内存中生成WebStream（其实已经将WebStream保存在本地），如果硬盘空间不够进行存储，将自动使用new WWW方法加载，并在内存中生成WebStream。在本地存储中，使用fileName作为标识符，所以更换URL地址而不更改文件名，将不会造成缓存资源的变更。保存的路径无法更改，也没有接口去获取此路径。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">fx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://syfx.github.io/2019/05/20/Unity3D资源处理/">http://syfx.github.io/2019/05/20/Unity3D资源处理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://syfx.github.io">fx's study notes</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity3D/">Unity3D</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=undefined" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/05/22/Unity3DAssetBundle/"><i class="fa fa-chevron-left">  </i><span>Unity3D AssetBundle</span></a></div><div class="next-post pull-right"><a href="/2019/04/24/c-高级知识点/"><span>c#高级知识点</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'c0ee81174c2d41d7a768',
  clientSecret: 'ff484e20f1e6f752134cb70ae1a43f30a7542849',
  repo: 'syfx.github.io',
  owner: 'syfx',
  admin: 'syfx',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(http://p.qpic.cn/pic_wework/1948211503/babcaaaa9297aa741e49ed921650a20476d250d0718288dc/0)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By fx</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://syfx.github.io">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>