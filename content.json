{"meta":{"title":"fx's study notes","subtitle":null,"description":"懂得越多，为难得越少","author":"fx","url":"http://syfx.github.io","root":"/"},"pages":[{"title":"tags","date":"2019-04-23T12:19:43.000Z","updated":"2019-04-23T12:20:12.217Z","comments":true,"path":"tags/index.html","permalink":"http://syfx.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-04-23T12:20:56.000Z","updated":"2019-04-23T12:21:35.806Z","comments":true,"path":"categories/index.html","permalink":"http://syfx.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"C++知识点总结","slug":"C-知识点总结","date":"2019-09-03T13:13:29.000Z","updated":"2020-01-04T13:29:55.782Z","comments":true,"path":"2019/09/03/C-知识点总结/","link":"","permalink":"http://syfx.github.io/2019/09/03/C-知识点总结/","excerpt":"","text":"写在前面：当要找工作时，发现对于面试中问的问题总有种朦朦胧胧的熟悉感，但让自己说时又不能说出个所以然来，归根结底，还是太菜了；记性不好，还是把比较重要的知识点记下来，常看看吧。 C++语言简介 c++是在c语言的基础上开发出的一种面向对象的编程语言，c++支持多种编程范式，包括面向对象编程、泛型编程、过程化编程。c++应用广泛，常应用于系统、引擎等开发领域。 面向对象 从实体上抽象出我们需要的属性及行为。对于其三大基本特征封装、继承、多态，我想是大概是在一定程度上增加了程序的安全性、复用性及灵活性吧。 C++与C的区别 主要区别在于 c++ 在 c 语言的基础上增加了类的概念，这一点可以从 c++ 早前的名字 c with classes 中看出。再者，c++ 相比 c 语言引入了更多的特性，例如命名空间、模板与泛型编程特性。 #define、const #define：预编译指令，可用来定义一个常量。 const：是c和c++中的关键字，用来声明一个常量（不可改变的变量），const可在一定程度上提高程序的安全性及可靠性；const可用来修饰基本数据类型、指针和引用；当const修饰指针时，要搞明白被修饰的是指针本身，还是指针指向的变量，例如： int t1 = 1, t2 = 2; const int *p1 = &amp;t1; //指针常量 int const *p2 = &amp;t1; //指针常量（p1与p2效果相同） //*p2 = 3; (错误) //不允许修改 指针指向的变量 的值 p2 = &amp;t2; //允许修改 指针 的值 int *const p3 = &amp;t1; //常量指针 *p3 = 3; //允许修改 指针指向的变量 的值 //p3 = &amp;t2; (错误) //不允许修改 指针 的值 使用const修饰的函数，只能调用const修饰的函数，普通函数能调用const修饰的函数。使用const修饰的成员函数，表示在该函数中不会对对象进行改变。 static的作用在c++中，static会修改所修饰标识符的链接属性，由external（外部的）变为internal（内部的）；即该标识符只能在其所处的文件中起作用。 补充： 另一个链接属性 none：总是被当做单独的个体，也就是说该标识符的多个声明被当作独立不同的实体。 extern：声明一个全局变量，作用范围是整个工程。 关于变量的声明与定义声明（引用性声明）：声明一个变量时并没有为该变量分配内存空间，它只是告诉编译器， 该变量会在某处进行定义。 定义（定义性声明）：声明一个变量的同时也为其分配储存空间。 声明一个变量 extern int A; 或 extern A; 定义一个变量 int A; 1.对于全局静态变量而言，可将该变量的作用域理解为从其所在文件开头，到其所在文件的结尾。全局静态变量被储存在全局静态区 2.局部静态变量，作用域不变，只是在离开作用域后，局部静态变量并未被销毁，当再次进入该作用域时，它的值也和上次一样。全局静态变量也被储存在全局静态区 关于内存五区 栈区、堆区、静态区、常量区、代码区 花费碎片时间，将搞懂的知识点写下来，未完待续。。。","categories":[],"tags":[]},{"title":"动态规划","slug":"动态规划","date":"2019-08-22T14:29:14.000Z","updated":"2019-08-22T15:10:38.687Z","comments":true,"path":"2019/08/22/动态规划/","link":"","permalink":"http://syfx.github.io/2019/08/22/动态规划/","excerpt":"","text":"动态规划 学习动态规划思想后的学习总结，以便日后复习使用。 动态规划思想三要素：最优子结构、边界、状态转移公式。 最优子结构要解决当前问题，需解决的简化后的子问题。 边界问题结束的条件。 状态转移公式联系当前子结构和上一级结构之间的表达式。 找寻上述三个要素的过程称为“建模”，其难点在于如何建立状态转移公式。 还是以几个问题为例对这一思想进行阐述吧。 斐波那契数列指这样一个数列，第一项和第二项为1，其余项的值为它前两项值得和：1,1,2,3,5,8……n问题：求第n项的值。 对于这个问题，最先想到的办法应该是通过递归解决，因为它的代码书写比较简单。 1234567int fibo(vector&lt;int&gt; nums, int n) &#123; if(n &lt;= 1)&#123; return 1; &#125; return fibo(nums, n - 1) + fibo(nums, n - 2); &#125; 使用递归解决时，最大的问题就是进行了太多次无意义的重复函数调用，比如，在求n-1项和n-2项的值时，都调用了函数来求n-3项的值。具体有多少个重复项，可以自己画个二叉树来分析一下。怎么避免呢？可以从以空间换时间的角度来思考一下，比如将所有已求得的值保存到哈希表中，当需要某项的值时，先从哈希表中查找，没有查找到时再递归运算。 在上面这一优化策略中就体现出了动态规划的思想：动态规划在于避免进行重复的运算，根据从低至上的策略，让先解决的子问题的结果作为后续问题的条件以避免重复求解相同的问题。 因此，我们可以这样来解决上述问题 123456789101112int fibo(vector&lt;int&gt; nums, int n) &#123; if(n &lt;= 1)&#123; return 1; &#125; int f = 1, s = 1; for(int i = 2; i &lt; n; ++i)&#123; s = f + s; f = s - f; &#125; return s; &#125; 在上面的代码中，首先我们将s赋值为f+s；然后在通过s-f将f赋值为之前s的值；最终的s就是第n项的值 未完待续。。。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://syfx.github.io/categories/学习笔记/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://syfx.github.io/tags/算法/"}]},{"title":"OpenGL入门","slug":"OpenGL入门","date":"2019-08-21T13:06:02.000Z","updated":"2019-08-22T14:36:00.215Z","comments":true,"path":"2019/08/21/OpenGL入门/","link":"","permalink":"http://syfx.github.io/2019/08/21/OpenGL入门/","excerpt":"","text":"一、状态机在真正学习OpenGL之前，要先了解一个概念：状态机 什么是状态机呢？可以将它理解成一种设计模式——通过一段特殊的组织代码的方式来表示对象当前所处的状态。概念总是不好理解，举个栗子：比如有一个小的绘制图形的状态机sOpenGL，里面有个属性保存当前要绘制的图形（即当前的状态），当我们设置要绘制的图形为 圆形 之后，每次通过这个sOpenGL绘制图形，都会绘制一个圆。然后当我们不想让它绘制圆时，就调用接口改变要绘制的图形（切换状态）。状态机当前的状态又被称为 上下文(Context) OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项(当前图形的渲染设置)，操作缓冲(当前保存的图形数据)。最后，我们使用当前OpenGL上下文进行图形渲染。 待更新。。。","categories":[{"name":"图形渲染","slug":"图形渲染","permalink":"http://syfx.github.io/categories/图形渲染/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://syfx.github.io/tags/OpenGL/"}]},{"title":"Unity3D性能优化","slug":"Unity3D性能优化","date":"2019-06-14T01:07:30.000Z","updated":"2019-06-15T09:33:47.813Z","comments":true,"path":"2019/06/14/Unity3D性能优化/","link":"","permalink":"http://syfx.github.io/2019/06/14/Unity3D性能优化/","excerpt":"","text":"多细节层次（LOD） 使用LOD优化技术进行渲染，可以随着某个对象与摄像机的距离增加而减少渲染对象的三角形数量。只要全部的对象不是同时靠近摄像机，LOD 便能降低硬件的负载并提高渲染性能。在 Unity 中，使用 LOD Group 组件为对象设置 LOD 渲染。 选中某个层级后，通过拖拽或者点击Add按钮来选择相机位于这个层级时应显示的图形 在一个层级上点击右键来增加一个新层级或者删除选定的层级 MipmapMipmap 是图像逐渐减小版本的的列表，用于优化实时3D引擎的性能，当纹理远离相机时使用较小版本的纹理。在导入纹理时，勾选 Generate Mip Maps选项为当前纹理创建Mipmap。使用Mipmap时会多占用 33% 的内存 如果贴图的基本尺寸是256x256像素的话,它 mipmap 就会有8个层级。每个层级是上一层级的四分之一的大小，依次层级大小就是：128x128;64x64;32x32;16x16;8x8;4x4;2x2;1x1(一个像素)。 因此，使用 Mipmap 时会增加内存占用。不过使用 Mipmap 可以很好的优化性能 因为 mipmap 贴图需要被读取的像素远少于普通贴图，所以渲染的速度得到了提升。而且操作的时间减少了，因为 mipmap 的图片已经是做过抗锯齿处理的，从而减少了实时渲染的负担。放大和缩小纹理也因为 mipmap 而变得更有效率。 建议游戏中的距离相机位置会发生变化的纹理始终使用 Mipmap；（除 GUI 纹理、天空盒、游标外） 各向异性过滤（Anisotropic filtering）各向异性过滤可以提高从掠射角观察时的纹理质量。此渲染在显卡上非常消耗资源。提高各向异性等级对于地面和地板纹理而言是一种很好的做法。可在质量设置（Quality Settings）中强制对所有纹理进行各向异性过滤或完全禁用该功能。导入纹理时通过 Aniso Level 选项来设置各向异性等级。 纹理导入设置对性能及内存的影响纹理尺寸大小建议纹理尺寸大小应该每边为2的整数次幂（即2、4…64..2048像素）。因为使用 NPOT（非2的整数幂）纹理大小时，通常要占用稍微多一点的内存；并且 GPU 的采样速度可更慢。因此，最好使用2的整幂大小的纹理。如果平台或 GPU 不支持 NPOT 纹理大小，Unity 会对纹理进行缩放和填充以达到一个2的整幂大小。这一过程会使用更多内存并使加载速度变慢。 2的整幂纹理大小,左侧不使用 mipmap，右侧使用 mipmapNPOT 纹理大小,左侧不使用 mipmap，右侧使用 mipmap Read/Write Enable选中这个选项，允许从脚本函数（例如 Texture2D.SetPixels…）中访问纹理数据，但这种情况下会生成纹理数据的副本，使纹理资源所需的内存增加一倍，因此，非绝对必要下不要使用这个属性。 Generate Mip Maps选中此框，可为当前纹理生成 Mipmap。 Border Miip Maps： 选中此框可避免颜色向外渗透到较低 MIP 级别的边缘。 Mip Map Filtering Box：切换时淡出 Mipmap 的最简单的方法，随着尺寸减小，MIP 级别将变得更加平滑。 Kaiser：随着 Mipmap 的尺寸大小下降，对其应用锐化。如果纹理在远处太模糊，可尝试此选项。 Fadeout Mip Maps：滚动条左边的的滚动项表示第一个开始淡出的 MIP 级别。其右边的滚动项表示纹理完全变灰的 MIP 级别。 Aniso Level以大角度查看时提高纹理质量。 避免频繁的GCGC何时触发？ 堆内存不足仍进行堆内存分配时 自动触发，不同的平台运行频率不一样 强制执行GC（GC.Collect()尽量避免主动调用它）因此，在代码中，要尽量避免大量临时变量的生成，或者避免有大量临时变量产生的操作其他策略有： 对需要频繁生成和销毁的对象使用对象池进行缓存 需要对字符串频繁进行拼接等操作时，使用使用StringBUilder 循环时尽量使用for，除非必须使用foreach 其他关于脚本和设置方面的优化策略，这两篇博客写的很不错Unity性能优化 – 脚本篇（https://wuzhiwei.net/unity_script_optimization/）Unity性能优化 – 设置篇（https://wuzhiwei.net/unity-settings-optimization/） 未完待续。。。 参考文献 https://docs.unity3d.com/2018.4/Documentation/Manual/ImportingTextures.html https://docs.unity3d.com/2018.4/Documentation/Manual/TextureTypes.html https://zh.wikipedia.org/wiki/Mipmap","categories":[{"name":"随笔","slug":"随笔","permalink":"http://syfx.github.io/categories/随笔/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://syfx.github.io/tags/Unity/"}]},{"title":"Unity3D AssetBundle","slug":"Unity3DAssetBundle","date":"2019-05-22T08:51:31.000Z","updated":"2019-06-03T10:30:00.231Z","comments":true,"path":"2019/05/22/Unity3DAssetBundle/","link":"","permalink":"http://syfx.github.io/2019/05/22/Unity3DAssetBundle/","excerpt":"","text":"AssetBundle简介 AssetBundle是Unity支持的一种文件储存格式，也是Unity官方推荐的资源存储与更新方式，它可以对资源(Asset)进行压缩，分组打包，动态加载，以及实现热更新，但是AssetBundle无法对Unity脚本进行热更新。（因此通过Lua来进行热更行）至于为什么，这篇文章说的挺详细了：https://www.jianshu.com/p/71fffc9a9cac 在Unity的5.3版本时，简化了AssetBundle的打包方式，只留下了一个API与寥寥几个设置参数，而之前最让人头痛的资源依赖管理，也被默认进行处理。 而在每个Asset文件的Inspector面板上都会多出一个Asset Labels的设定栏： AssetBundle Name：需要将此资源打包的AssetBundle名称 AssetBundle Variant：需要将此资源打包的AssetBundle的扩展名Variant：Variant是5.3以后新添加的一个概念，这个值其实是一个尾缀，添加在对应AssetBundle的名称之后，如：ddzgame.hd，hd就是Variant(从此以后AssetBundle的尾缀已经跟其文件类型本身没有任何联系了)。它主要用在不同版本资源的使用和动态替换AssetBundle。它被用来支持定制化的参数。与预定义宏类似，它可以对一个单独对象重映射项目中不同的资源。这样就可以灵活控制语言、地区、或者用户偏好。AssetBundle Variant相同的AssetBundle之间将有共同的内部id。通过设置Variant变量，可以实现定制化的资源控制。可以使用Variant区分了相同资源的不同版本，所以它可以为同一个资源提供不同的解决方案。 AssetBundle相关操作自动打包脚本从以上可知，如果需要一个一个的对资源设置AssetBundle Name与Variant实在太过繁琐与麻烦，也可能出现纰漏，好在可以通过脚本去批量设置这两个参数。（脚本放到Unity的Editor文件夹下） 12345//path是资源在Assets下的路径（eg： Assets/.../.....） AssetImporter assetImporter = AssetImporter.GetAtPath(&quot;path&quot;); //设置AssetBundle Name与VariantassetImporter.assetBundleName = &quot;AssetbundleName&quot;; assetImporter.assetBundleVariant = &quot;AssetbundleVariant&quot;; 12345678910111213141516[MenuItem(&quot;AssetsBundle/Build AssetBundle&quot;)] static public void BuildAssetBundle() &#123; AssetImporter asserImporter = AssetImporter.GetAtPath(&quot;Assets/Sources/Player1.prefab&quot;); asserImporter.assetBundleName = &quot;player&quot;; asserImporter.assetBundleVariant = &quot;prefab&quot;; //将ab资源打包的当前工程的AssetBundles文件夹下（与Assets同级） if(!Directory.Exists(&quot;AssetBundles&quot;)) &#123; Directory.CreateDirectory(&quot;AssetBundles&quot;); &#125; BuildPipeline.BuildAssetBundles(&quot;AssetBundles&quot;, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows64); AssetDatabase.Refresh(); &#125; 对Scene的打包Scene打包跟资源打包无异，唯一需要注意的是：Scene只能与Scene打入同一个AssetBundle内，而无法与其他资源打入同一个AssetBundle。AssetBundle内的Scene需要在AssetBundle加载后，通过SceneManager来加载。 压缩方式 LZMA（Ziv-Markov chain algorithm）格式Unity打包成AssetBundle时的默认格式，会将序列化数据压缩成LZMA流，使用时需要整体解包。优点是打包后体积小，缺点是解包时间长，且占用内存。 LZ4格式5.3新版本添加的压缩格式，压缩率不及LZMA，但是不需要整体解压。LZ4是基于chunk的算法，加载对象时只有响应的chunk会被解压。 压缩格式在打包时通过AssetBundleOption参数选择。 AssetBundle资源加载使用 WWW 或者 AssetBundle 相关 API 加载，其中 AssetBundle 的 API 只能进行本地加载。AssetBundle.LoadfromMemory（byte[] bytes）用来对加密的Assetbundle进行读取，可以结合WWW使用。 123456789101112131415161718192021222324public class BuileAsset : MonoBehaviour &#123; //资源地址（Player.prefab是我的资源包的名称） private string path = &quot;File://F:/myUnityProject/AssetBundle/AssetBundles/Player.prefab&quot;; IEnumerator Start() &#123; WWW www = new WWW(path); yield return www; if (www == null) &#123; Debug.Log(&quot;路径内容为空&quot;); &#125; else &#123; AssetBundle asset = www.assetBundle; Object[] obj = asset.LoadAllAssets&lt;GameObject&gt;(); //实例化资源包中的游戏物体 foreach (var value in obj) &#123; Instantiate(value); &#125; www.Dispose(); &#125; &#125; AssetBundle资源卸载1AssetBundle.Unload(bool unloadAllLoadedObjects); AssetBundle唯一的一个卸载函数，传入的参数用来选择是否将已经从此AssetBundle中加载的资源一起卸载。另外，已经从AssetBundle中加载的资源可以通过Resources.UnloadAsset(Object)卸载。不过通过Resources.UnloadUnusedAssets()卸载从AssetBundle加载的资源时，要先将AssetBundle卸载后才能生效。","categories":[{"name":"总结","slug":"总结","permalink":"http://syfx.github.io/categories/总结/"}],"tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://syfx.github.io/tags/Unity3D/"}]},{"title":"Unity3D资源处理","slug":"Unity3D资源处理","date":"2019-05-20T12:28:23.000Z","updated":"2019-05-21T07:57:14.882Z","comments":true,"path":"2019/05/20/Unity3D资源处理/","link":"","permalink":"http://syfx.github.io/2019/05/20/Unity3D资源处理/","excerpt":"","text":"GUID与fileID(本地ID)Unity会为每个导入到Assets目录中的资源创建一个meta文件，文件中记录了GUID，GUID用来记录资源之间的引用关系。还有fileID（本地ID），用于标识资源内部的资源。资源间的依赖关系通过GUID来确定；资源内部的依赖关系使用fileID来确定。 InstanceID(实例ID)Unity为了在运行时，提升资源管理的效率，会在内部维护一个缓存表，负责将文件的GUID与fileID转换成为整数数值，这个数值在本次会话中是唯一的，称作实例ID(InstanceID)。程序启动时，实例ID缓存与所有工程内建的对象(例如在场景中被引用)，以及Resource文件夹下的所有对象，都会被一起初始化。如果在运行时导入了新的资源，或从AssetBundle中载入了新的对象，缓存会被更新，并为这些对象添加相应条目。实例ID仅在失效时才会被从缓存中移除，当提供了指定文件GUID和fileID的AssetBundle被卸载时会产生移除操作。卸载AssetBundle会使实例ID失效，实例ID与其文件GUID和fileID之间的映射会被删除以便节省内存。重新载入AssetBundle后，载入的每个对象都会获得新的实例ID。 资源的生命周期Object从内存中加载或卸载的时间点是定义好的。Object有两种加载方式：自动加载与外部加载。当对象的实例ID与对象本身解引用，对象当前未被加载到内存中，而且可以定位到对象的源数据，此时对象会被自动加载。对象也可以外部加载，通过在脚本中创建对象或者调用资源加载API来载入对象（例如：AssetBundle.LoadAsset）对象加载后，Unity会尝试修复任何可能存在的引用关系，通过将每个引用文件的GUID与FileID转化成实例ID的方式。一旦对象的实例ID被解引用且满足以下两个标准时，对象会被强制加载： 实例ID引用了一个没有被加载的对象。 实例ID在缓存中存在对应的有效GUID和本地ID。 如果文件GUID和本地ID没有实例ID，或一个已卸载对象的实例ID引用了非法的文件GUID和本地ID，则引用本身会被保留，但实例对象不会被加载。在Unity编辑器中表现为空引用，在运行的应用中，或场景视图里，空对象会以多种方式表示，取决于丢失对象的类型：网格会变得不可见，纹理呈现为紫红色等等。 MonoScripts一个MonoScripts含有三个字符串：程序集名称，类名称，命名空间。构建工程时，Unity会收集Assets文件夹中独立的脚本文件并编译他们，组成一个Mono程序库。Unity会将Assets目录中的语言分开编译，Assets/Plugins目录中的脚本同理。Plugin子目录之外的C#脚本会放在Assembly-CSharp.dll中。而Plugin及其子目录中的脚本则放置在Assembly-CSharp-firstpass.all中。这些程序库会被MonoScripts所引用，并在程序第一次启动时被加载。 资源文件夹Assets为Unity编辑器下的资源文件夹，Unity项目编辑时的所有资源都将置入此文件夹内。在编辑器下，可以使用以下方法获得资源对象： 1AssetDatabase.LoadAssetAtPath(&quot;Assets/x.txt&quot;); 注意：此方法只能在编辑器下使用，当项目打包后，在游戏内无法运作。参数为包含Assets内的文件全路径，并且需要文件后缀。Assets下的资源除特殊文件夹内，或者在会打入包内的场景中引用的资源，其余资源不会被打入包中。 Resources资源载入Assets下的特殊文件夹，此文件夹内的资源将会在项目打包时，全部打入包内，并能通过以下方法获得对象： 12Resources.Load(&quot;fileName&quot;); Resources.Load(&quot;fileName&quot;); 注意：函数内的参数为相对于Resource目录下的文件路径与名称,不包含后缀。Assets目录下可以拥有任意路径及数量的Resources文件夹，在运行时,Resources下的文件路径将被合并。例：Assets/Resources/test.txt与Assets/TestFloder/Resources/test.png在使用Resource.Load (“test”)载入时，将被视为同一资源，只会返回第一个符合名称的对象。如果使用Resource.Load(“test”)将返回text.txt；如果在Resources下有相同路径及名称的资源，使用以上方法只能获得第一个符合查找条件的对象，使用以下方法能或得到所有符合条件的对象： 12Object[] assets = Resources.LoadAll(&quot;fileName&quot;); TextAsset[] assets = Resources.LoadAll(&quot;fileName&quot;); 在工程进行打包后，Resource文件夹中的资源将进行加密与压缩，打包后的程序内将不存在Resource文件夹，故无法通过路径访问以及更新资源。在程序启动时会为Resource下的所有对象进行初始化，构建实例ID。随着Resource内资源的数量增加，此过程耗时的增加是非线性的。故会出现程序启动时间过长的问题，请密切留意Resource内的资源数量 卸载资源所有实例化后的 GameObject 可以通过 Destroy 函数销毁。请留意 Object 与 GameObject 之间的区别与联系Object 可以通过 Resources 中的相关 Api 进行卸载： 12Resources.UnloadAsset(Object); //卸载对应Object Resources.UnloadUnusedAssets(); //卸载所有没有被引用以及实例化的Object 注意以下情况： 12345Object obj = Resources.Load(&quot;MyPrefab&quot;); GameObject instance = Instantiate(obj) as GameObjct; ...Destroy(instance); Resources.UnloadUnusedAssets(); //卸载资源 此时UnloadUnusedAssets将不会生效，因为obj依然引用了MyPrefab，需要将obj = null，才可生效。 StreamingAssets 概述StreamingAssets 文件夹为流媒体文件夹，此文件夹内的资源将不会经过压缩与加密，原封不动的打包进游戏包内。在游戏安装时，StreamAssets 文件件内的资源将根据平台，移动到对应的文件夹内。 StreamingAssets 文件夹在 Android 与 IOS 平台上为只读文件夹。 你可以使用以下函数获得不同平台下的StreamingAssets文件夹路径： 1Application.streamingAssetsPath 参考以下各平台下 StreamingAssets 文件夹的等价路径，Application.dataPath 为程序安装路径。Android 平台下的路径比较特殊，请留意此路径的前缀，在一些资源读取的方法中是不必要的（eg：AssetBundle.LoadFromFile） Application.dataPath+”/StreamingAssets”//Windows OR MacOS Application.dataPath+”/Raw” //IOS “jar:file://“+Application.dataPath+”!/assets/“ //AndroidStreamingAssets文件夹下的文件在游戏中只能通过 IOStream 或者 WWW 的方式读取io方式： 1FileStream stream = File.Open(Application.streamingAssetsPath + &quot;/fileName&quot;, FileMode.Open); WWW方式（注意协议与不同平台下路径的区别）： 1234567private IEnumerator Start() &#123; WWW www = new WWW(Application.streamingAssetsPath + &quot;/Cube&quot;); yield return www; //将获取的web页面的内容作为字符串返回（只读） Debug.Log(www.text); &#125; AssetBundle特有的资源加载方式： 12//同步地从磁盘上的文件加载 AssetBundle.LoadFromFile(assetbundlePath+&quot;/name.unity3d&quot;); PersistentDataPath路径：Application.persistentDataPathUnity指定的一个可读写的外部文件夹，该路径因平台及系统配置不同而不同。可以用来保存数据及文件。该目录下的资源不会在打包时被打入包中，也不会自动被Unity导入及转换。该文件夹只能通过IOStream以及WWW的方式进行资源加载。 WWW载入资源WWW是一个Unity封装的网络下载模块，支持Http以及file两种URL协议，并会尝试将资源转换成Unity能使用的AssetsComponents（如果资源是Unity不支持的格式，则只能取出byte[]）。具体对应的格式参考第一章表格。WWW加载是异步加载方法。每次new WWW时，Unity都会启用一个线程去进行下载。通过此方式读取或者下载资源，会在内存中生成WebStream，WebStream为下载文件转换后的内容，占用内存较大。使用WWW.Dispose将终止仍在加载过程中的进程，并释放掉内存中的WebStream。 如果WWW不及时释放，将占用大量的内存。如果载入的为Assetbundle且进行过压缩，则还会在内存中占用一份AssetBundle解压用的缓冲区Deompresion Buffer,AssetBundle压缩格式的不同会影响此区域的大小。WWW.LoadFromCacheOrDownload静态方法 12int version = 1; WWW.LoadFromCacheOrDownload(PathURL+&quot;/fileName&quot;,version); 使用此方式加载，将先从硬盘上的存储区域查找是否有对应的资源，再验证本地Version与传入值之间的关系，如果传入的Version&gt;本地Version，则从传入的URL地址下载资源，并缓存到硬盘，替换掉现有资源，如果传入的Version&lt;=本地Version，则直接从本地读取资源；如果本地没有存储资源，则下载资源。此方法的存储路径无法设定以及访问。使用此方法载入资源，不会在内存中生成WebStream（其实已经将WebStream保存在本地），如果硬盘空间不够进行存储，将自动使用new WWW方法加载，并在内存中生成WebStream。在本地存储中，使用fileName作为标识符，所以更换URL地址而不更改文件名，将不会造成缓存资源的变更。保存的路径无法更改，也没有接口去获取此路径。","categories":[{"name":"总结","slug":"总结","permalink":"http://syfx.github.io/categories/总结/"}],"tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://syfx.github.io/tags/Unity3D/"}]},{"title":"c#高级知识点","slug":"c-高级知识点","date":"2019-04-24T11:28:09.000Z","updated":"2019-05-29T03:10:28.781Z","comments":true,"path":"2019/04/24/c-高级知识点/","link":"","permalink":"http://syfx.github.io/2019/04/24/c-高级知识点/","excerpt":"","text":"c#特性与反射特性 定义：在程序运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）行为信息的声明性标签。 看定义，一脸懵逼，那这玩意究竟有什么用呢？举个例子：比如我们有一个开发平台，向外部提供了API；然后，当我们更新时，想使用一个新的方法代替其中一个方法；这时我们总不能直接把老方法删了吧，但是我们又不想让人家用老方法了，怎么办呢？这时候，特性就可以帮助我们在人家调用老方法时提醒人。怎么用呢？呐，示例代码： 123456789[Obsolete(&quot;Don&apos;t use OldMethod(), use NewMethod()&quot;, false)]public void OldMethod()&#123; Console.WriteLine(&quot;老方法&quot;);&#125;public void NewMethod()&#123; Console.WriteLine(&quot;新方法&quot;);&#125; Obsolete是.Net提供的三个预定义特性之一，这个预定义特性标记了不应该被使用的程序实体。它可以让您通知编译器丢弃某个特定的目标元素。语法为：[Obsolete(message,iserror)] message：字符串参数，描述项目实体过时的原因以及该使用什么替代。 iserror，布尔参数。为 true 时，编译器把对该实体的使用当作一个错误。默认值是 false（当做警告）。 .Net提供了两种类型的特性：预定义特性，自定义特性。个人理解：预定义特性是在预处理阶段起作用的特性。 预定义特性除了Obsolete，另外两个预定义特性是AttributeUsage与Conditional。AttributeUsage语法如下： 12345[AttributeUsage( validon, AllowMultiple=allowmultiple, Inherited=inherited)] 这位的作用是描述了如何使用一个自定义特性。可以理解成用它来约束我们编写的自定义特性。看参数就知道了： validon：规定特性可“修饰”的语言元素(类、方法…)。它是枚举器 AttributeTargets 的值的组合，使用OR（|）运算法组合；默认值是 AttributeTargets.All。 allowmultiple：为该特性的 AllowMultiple 属性提供一个布尔值。为 true 时该特性是多用的（ 即我们的定制特性能被重复放置在同一个程序实体（语言元素）前多次。）。默认值是 false（单用的） inherited：为该特性的 Inherited 属性提供一个布尔值。为 true 时该特性可被派生类继承。默认值是 false（不被继承）；这里的继承指当被这个特性“修饰”的类被继承时，其子类是否也继承了此特性。示例代码： 1234567[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = true)]class MyHelpAttribure : Attribute&#123; ......&#125; 上述代码中，我们自定义了一个特性MyHelpAttribure，并用预定义特性AttributeUsage约束它只能放置在类和方法前面，可重复放置，可被继承。（自定义特性其实就是一个继承了System.Attribute类的类） ConditionalConditional 在命名空间 System.Diagnostics 下，语法如下：[Conditional(conditionalSymbol)] conditionalSymbol：字符串类型，为预处理标识符的名称。这个特性只能放置在特性和方法之前。 这个预定义特性标记了一个条件方法，其执行依赖于指定的预处理标识符，它会引起方法调用的条件编译。 和预编译指令 #if、#endif 作用相同。不同的是#if、#endif作用于代码段，Conditional作用于方法。示例代码： 1234567891011121314151617181920212223using System;namespace cSharpReview&#123; class Program &#123; [System.Diagnostics.Conditional(&quot;DEBUG&quot;)] void Method1() &#123; Console.WriteLine(&quot;Method1&quot;); &#125; void Method2() &#123; Console.WriteLine(&quot;Method2&quot;); &#125; static void Main(string[] args) &#123; Program pro = new Program(); pro.Method1(); pro.Method2(); Console.ReadKey(); &#125; &#125;&#125; 上面的代码在Debug环境里执行结果为：Method1Method2在Release环境里执行结果为：Method2因为在Debug环境下定义的有 预处理标识符 DEBUG。 自定义特性前面说过，自定义特性就是一个继承了System.Attribute的类。一般我们将自定义特性用于存储声明性的信息，可在运行时通过反射技术检索这些信息。下面，通过一个示例来了解一下自定义特性。 反射 定义：反射提供描述程序集、模块和类型的对象（Type 类型）。 可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型，然后调用其方法或访问其字段和属性。 如果代码中使用了特性，可以利用反射来访问它们。 通俗点讲，反射能够在获得对象的内部结构。可以理解成“给一个对象做b超”（这个对象是 Type 类型的对象实例，不是人啊，别想多了）。在此之前，要了解一些名词。 程序集、模块、与类型。.Net应用程序由“程序集”，“模块”，“类型”组成，程序集包含模块，模块包含类型。 命名空间与装配件的关系。名空间类似与Java的包，但又不完全等同，因为Java的包必须按照目录结构来放置，命名空间则不需要。装配件，是.Net应用程序执行的最小单位，编译出来的.dll、.exe都是一个装配件。一个程序集中可以有无数个名称不同的命名空间，不同程序集之间可以有名字相同的命名空间。关于装配件与程序集，是同一个概念（都是翻译惹得祸吧，英文：Assembly），这个不用纠结ヽ(ー_ー)ノ。 以上名词来自网络资料，如有不对，再做更改 System.Type 类是反射的中心。 当反射提出请求时，公共语言运行时为已加载的类型创建 Type。 可使用 Type 对象的方法、字段、属性和嵌套类来查找该类型的任何信息。继承关系：Object-&gt;MemberInfo-&gt;Type 获取对象的三种方式 1234Type t = typeof(String);string str = string.Empty;Type t = str.GetType();Type t = Type.GetType(&quot;System.String&quot;); 使用 Assembly.GetType 或 Assembly.GetTypes 从尚未加载的程序集中获取 Type 对象，传入所需类型的名称。 使用 Type.GetType 从已加载的程序集中获取 Type 对象。 使用 Module.GetType 和 Module.GetTypes 获取模块 Type 对象。 如何使用反射访问特性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//自定义特性类[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true)]class DebugInfo : Attribute&#123; private int bugNo; //调错编号 private string lastReview; //最后一次排错时间 private string message; //描述 public DebugInfo(int iNo, String sLR, String sMsg) &#123; bugNo = iNo; lastReview = sLR; message = sMsg; &#125; public int BugNo &#123; get &#123; return bugNo; &#125; &#125; public String LastReview &#123; get &#123; return lastReview; &#125; &#125; public String Message &#123; get &#123; return message; &#125; &#125;&#125;[DebugInfo(17, &quot;22/04/2019&quot;, &quot;fx&quot;)][DebugInfo(16, &quot;18/04/2019&quot;, &quot;fx&quot;)]class Test&#123; [DebugInfo(17, &quot;22/04/2019&quot;, &quot;fx&quot;)] void Method1() &#123; &#125; [DebugInfo(16, &quot;18/04/2019&quot;, &quot;fx&quot;)] public void Method2() &#123; &#125;&#125;class Program&#123; static void Main(string[] args) &#123; Type type = typeof(Test); ///1、遍历类Test的特性 foreach (Object obj in type.GetCustomAttributes(false)) &#123; DebugInfo dbInfo = (DebugInfo)obj; if(dbInfo != null) &#123; Console.WriteLine(&quot;bug no: &#123;0&#125;&quot;, dbInfo.BugNo); Console.WriteLine(&quot;last review: &#123;0&#125;&quot;, dbInfo.LastReview); Console.WriteLine(&quot;message: &#123;0&#125;&quot;, dbInfo.Message); &#125; &#125; ///2、遍历Test类中方法的特性 foreach(MethodInfo mi in type.GetMethods()) &#123; foreach (Object obj in mi.GetCustomAttributes(false)) &#123; DebugInfo dbInfo = (DebugInfo)obj; if (dbInfo != null) &#123; Console.WriteLine(&quot;bug no: &#123;0&#125;&quot;, dbInfo.BugNo); Console.WriteLine(&quot;last review: &#123;0&#125;&quot;, dbInfo.LastReview); Console.WriteLine(&quot;message: &#123;0&#125;&quot;, dbInfo.Message); &#125; &#125; &#125; Console.ReadKey(); &#125;&#125; 使用反射查看类型信息 12345678910111213141516171819class Program&#123; static void Main(string[] args) &#123; Type t = Type.GetType(&quot;System.String&quot;); ///获取所有成员(构造函数、 事件、 字段、 方法和属性)信息 foreach (MemberInfo mi in t.GetMembers()) &#123; Console.WriteLine(mi.Name); &#125; ///获取所有成员方法信息 foreach (MethodInfo mi in t.GetMethods()) &#123; Console.WriteLine(mi.Name); &#125; //...... Console.ReadKey(); &#125;&#125; 使用反射获取及调用构造方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Test&#123; string str = string.Empty; private Test() &#123; &#125; public Test(string str) &#123; this.str = str; &#125; public void Method() &#123; Console.WriteLine(str); &#125;&#125;class Program&#123; static void Main(string[] args) &#123; Type t = typeof(Test); //根据构造函数的参数类型获取构造函数，为空的话传入 Type.EmptyTypes; Type[] para = new Type[1]; para[0] = typeof(string); //获取有一个string参数的公有构造函数 ConstructorInfo ct = t.GetConstructor(para); //构造Object数组，作为传入的参数组合（无参设置为null） object[] ojbs = new object[1] &#123; &quot;fx&quot; &#125;; //调用构造函数创建对象 if(ct != null) &#123; object test = ct.Invoke(ojbs); ((Test)test).Method(); &#125; //获取无参数的私有构造函数 ConstructorInfo _ct = t.GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic, null, Type.EmptyTypes, null); if(_ct != null) &#123; object test = _ct.Invoke(null); ((Test)test).Method(); &#125; ///使用Activator生成对象 Object theObj2 = Activator.CreateInstance(t, &quot;fx&quot;); //调用有参构造函数 ((Test)theObj2).Method(); //调用 私有 无参构造函数 Object theObj3 = Activator.CreateInstance(t, true); ((Test)theObj3).Method(); Console.ReadKey(); &#125;&#125; BindingFlags是一个枚举类型，常用枚举值如下： BindingFlags.Public ： 指定公开成员将被包含在搜索中 BindingFlags.Static ：指定静态成员将被包含在搜索中 BindingFlags.NonPublic：指定非公开成员将被包含在搜索中 BindingFlags.Instance ：指定实例成员将被包含在搜索中 其它（方法、字段、属性等）的操作与此类似： MemberInfo类是用来获取所有成员 （构造函数、 事件、 字段、 方法和属性） 的类的相关信息的类的抽象基类。 使用Assembly定义和加载程序集，加载在程序集清单中列出模块，以及从此程序集中查找类型并创建该类型的实例。 使用Module了解包含模块的程序集以及模块中的类等，还可以获取在模块上定义的所有全局方法或其他特定的非全局方法。 使用ConstructorInfo了解构造函数的名称、参数、访问修饰符（如pulic 或private）和实现详细信息（如abstract或virtual）等。 使用MethodInfo了解方法的名称、返回类型、参数、访问修饰符（如pulic 或private）和实现详细信息（如abstract或virtual）等。 使用FiedInfo了解字段的名称、访问修饰符（如public或private）和实现详细信息（如static）等，并获取或设置字段值。 使用EventInfo了解事件的名称、事件处理程序数据类型、自定义属性、声明类型和反射类型等，添加或移除事件处理程序。 使用PropertyInfo了解属性的名称、数据类型、声明类型、反射类型和只读或可写状态等，获取或设置属性值。 使用ParameterInfo了解参数的名称、数据类型、是输入参数还是输出参数，以及参数在方法签名中的位置等。 反射的优缺点: 优点： 反射提高了程序的灵活性和扩展性。 降低耦合性，提高自适应能力。 它允许程序创建和控制任何类的对象，无需提前硬编码目标类。 缺点： 性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。 使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。 关于反射的使用，这里只做简单的介绍，深入学习的话请访问反射(c#)编程指南. c#属性（Property） 定义：属性是一种成员，它提供灵活的机制来读取、写入或计算私有字段的值。 属性可用作公共数据成员，但它们实际上是称为访问器的特殊方法。 这使得可以轻松访问数据，还有助于提高方法的安全性和灵活性。 访问器包括get和set，通过get来返回某个字段的值，在set中，使用关键字value为某个字段进行赋值。属性中至少有一个访问器，可以只有一个get或set访问器，或者既有get又有set访问器。可以用访问限制修饰符修饰访问器，不过限制级别要大于属性的限制修饰符。 限制级别：private &gt; internal和protected &gt; public 12345678910111213141516171819202122class Test&#123; //字段 private int field; //属性 public int Field &#123; get &#123; return field; &#125; set &#123; field = value; &#125; &#125;&#125;class Program&#123; static void Main(string[] args) &#123; Test test = new Test(); //通过属性为field赋值 test.Field = 66; //通过属性获取字段field的值 Console.WriteLine(&quot;Test.field：&#123;0&#125;&quot;, test.Field); Console.ReadKey(); &#125;&#125; 在一些情况下，属性 get 和 set 访问器仅为支持字段赋值或仅从其中检索值，而没有其它附加逻辑。 这是，通过使用自动实现的属性，既能简化代码，还能让 C# 编译器透明地提供支持字段（即我们不用显示声明字段了）。 123456789101112131415class Test&#123; //自动属性 public int Pro &#123; get; set; &#125;&#125;class Program&#123; static void Main(string[] args) &#123; Test test = new Test(); test.Pro = 66; Console.WriteLine(&quot;Test.Pro：&#123;0&#125;&quot;, test.Pro); Console.ReadKey(); &#125;&#125; 深入学习请访问：属性(c#) 索引器 定义：索引器允许类或结构的实例像数组一样进行索引。 无需显式指定类型或实例成员，即可设置或检索索引值。 类似于属性，不同之处在于索引器的的访问器需要使用参数。 下面是一个简单索引器的使用案例： 1234567891011121314151617181920212223242526272829class collection&#123; static int Count = 100; private string[] arr = new string[Count]; public string this[int i] &#123; get &#123; if(i &gt;= 0 &amp;&amp; i &lt; 100) return arr[i]; return null; &#125; set &#123; if (i &gt;= 0 &amp;&amp; i &lt; 100) arr[i] = value; &#125; &#125;&#125;class Program&#123; static void Main() &#123; var stringCollection = new collection(); stringCollection[0] = &quot;fx&quot;; Console.WriteLine(stringCollection[0]); Console.ReadKey(); &#125;&#125; 当然，我们可以在泛型类中来使用索引器。 123456789101112131415161718192021class SampleCollection&lt;T&gt;&#123; private T[] arr = new T[100]; public T this[int i] &#123; get &#123; return arr[i]; &#125; set &#123; arr[i] = value; &#125; &#125;&#125;class Program&#123; static void Main() &#123; var stringCollection = new SampleCollection&lt;string&gt;(); stringCollection[0] = &quot;Hello, World&quot;; Console.WriteLine(stringCollection[0]); Console.ReadKey(); &#125;&#125; 索引器也可以被重载。 123456789101112131415161718192021222324252627282930313233343536373839class collection&#123; private string[] arr = new string[100]; public string this[int i] &#123; get &#123; return arr[i]; &#125; set &#123; arr[i] = value; &#125; &#125; //重载索引器 public int this[string val] &#123; get &#123; int index = 0; while (index &lt; 100) &#123; if (arr[index] == val) &#123; return index; &#125; index++; &#125; return -1; &#125; &#125;&#125;class Program&#123; static void Main() &#123; var stringCollection = new collection(); stringCollection[0] = &quot;fx&quot;; Console.WriteLine(stringCollection[0]); Console.WriteLine(stringCollection[&quot;fx&quot;]); Console.ReadKey(); &#125;&#125; 关于更多请访问索引器(c#) c#委托与事件委托 定义：委托是一种引用类型，表示对具有特定参数列表和返回类型的方法的引用。 在实例化委托时，你可以将其实例与任何具有兼容参数和返回类型的方法相关联。 并能通过委托实例调用方法。 委托具有以下属性： 委托类似于 C++ 函数指针，但委托完全面向对象，不像 C++ 指针会记住函数，委托会同时封装对象 + 实例和方法。 委托允许将方法作为参数进行传递。 委托可用于定义回调方法。 委托可以链接在一起；例如，可以对一个事件调用多个方法。 声明一个委托： 1public delegate int DgName(int para1, string para2); 实例化委托并简单使用： 1234567891011121314151617class Program&#123; public delegate int DgName(int para1); public int Method(int para1) &#123; return para1 / 2; &#125; static void Main() &#123; Program pro = new Program(); //实例化一个委托myDg DgName myDg = pro.Method; //通过委托调用pro.Method Console.WriteLine(myDg(66)); //33 Console.ReadKey(); &#125;&#125; 上面说过，委托允许将方法作为参数进行传递，因此，我们还可以这样使用委托。 12345678910111213141516171819202122class PrintString&#123; // 委托声明 public delegate void DgName(string s); public static void WriteToScreen(string str) &#123; Console.WriteLine(&quot;The String is: &#123;0&#125;&quot;, str); &#125; // 该方法把委托作为参数，并使用它调用方法 public static void sendString(DgName ps) &#123; ps(&quot;Hello World&quot;); &#125; static void Main(string[] args) &#123; //可以这样实例化委托变量 DgName ps1 = new DgName(WriteToScreen); sendString(ps1); Console.ReadKey(); &#125;&#125; 委托对象可使用加法赋值运算符（“+”或“+=”）进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。使用委托的这个有用的特点，您可以创建一个委托被调用时要调用的方法的调用列表。这被称为委托的多播（multicasting），也叫组播。 若要删除调用列表中的方法，使用减法运算符或减法赋值运算符（“-”或“-=”）。 123456789101112131415161718192021222324252627282930313233343536class Program&#123; public delegate void Dlg(); public static void DogCry() &#123; Console.WriteLine(&quot;汪汪汪~&quot;); &#125; public static void CatCry() &#123; Console.WriteLine(&quot;喵喵~&quot;); &#125; public static void SheepCry() &#123; Console.WriteLine(&quot;咩 ~&quot;); &#125; public static void AnimalCry(Dlg dlg) &#123; dlg(); &#125; static void Main() &#123; Dlg dlg =DogCry; dlg += CatCry; Dlg anoDlg = new Dlg(SheepCry); dlg = dlg + anoDlg; AnimalCry(dlg); /** * 输出： * 汪汪汪~ * 喵喵~ * 咩 ~ */ Console.ReadKey(); &#125;&#125; 更多请访问委托(c#) 事件 定义：类或对象可以通过事件向其他类或对象通知发生的相关事情。 发送（或 引发）事件的类称为“发行者（发布器）” ，接收（或 处理）事件的类称为“订户（订阅器）” 。 发布器（publisher） 是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器类的对象调用这个事件，并通知其他的对象。 订阅器（subscriber） 是一个接受事件并提供事件处理程序的对象。在发布器（publisher）类中的委托调用订阅器类中的方法（事件处理程序）。 由上面的定义可以看出，事件，实际上就是.Net对观察这模式的应用。 在类中声明事件之前，必须要先声明用于该事件的委托。例： 123public delegate void Cry();//基于委托声明事件public event Cry MouseRun; 编写一个实例：当老鼠跑时，狗叫，猫叫并追赶老鼠；因为在这个设计模型中，当老鼠跑时要通知猫追赶它，通知狗叫，因此老鼠类就是“发布器”，狗类和猫类就是“订阅器”。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455using System;namespace StudyNotes&#123; //；老鼠类 class Mouse &#123; public delegate void Cry(); //基于委托声明事件 public event Cry MouseRun; //老鼠跑 public void Run() &#123; //向“订阅器”发送消息 MouseRun(); &#125; &#125; //狗类 class Dog &#123; public void Cry() &#123; Console.WriteLine(&quot;狗：猫赶紧抓老鼠去！&quot;); &#125; &#125; //猫类 class Cat &#123; public void RunAndCry() &#123; Console.WriteLine(&quot;猫：小老鼠，哪里跑！&quot;); &#125; &#125; class Program &#123; static void Main() &#123; Mouse mouse = new Mouse(); Dog dog = new Dog(); Cat cat = new Cat(); //猫和狗“订阅”老鼠的跑事件 mouse.MouseRun += dog.Cry; mouse.MouseRun += cat.RunAndCry; //老鼠跑事件发生 mouse.Run(); /** * 输出： * 狗：猫赶紧抓老鼠去！ * 猫：小老鼠，哪里跑！ * */ Console.ReadKey(); &#125; &#125;&#125; 跟多关于事件(c#)","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://syfx.github.io/categories/编程语言/"}],"tags":[{"name":"c#","slug":"c","permalink":"http://syfx.github.io/tags/c/"}]},{"title":".NET与c#","slug":"NET与c","date":"2019-04-19T00:26:16.000Z","updated":"2019-05-28T12:32:09.510Z","comments":true,"path":"2019/04/19/NET与c/","link":"","permalink":"http://syfx.github.io/2019/04/19/NET与c/","excerpt":"","text":"一、什么是.NET.NET是一个微软搭造的开发者平台，它主要包括： 支持(面向)该平台的编程语言(如C#、Visual Basic、C++/CLI、F#、IronPython、IronRuby…) 用于该平台下开发人员的技术框架体系(即 .NET实现) 用于支持开发人员开发的软件工具(即SDK，如VS2017、VS Code等) .NET实现Microsoft 积极开发和维护的主要 .NET实现 有4个：.NET Framework、.NET Core、Mono 和 UWP。每个 .NET实现 都具有以下组件： 一个或多个运行时。 .NET运行时 运行时是用于托管程序的执行环境。 操作系统属于运行时环境，但不属于 .NET 运行时。 下面是 .NET 运行时的一些示例： .NET Framework 公共语言运行时 (CLR) .NET Core 核心公共语言运行时 (CoreCLR) 适用于通用 Windows 平台的 .NET Native 用于 Xamarin.iOS、Xamarin.Android、Xamarin.Mac 和 Mono 桌面框架的 Mono 运行时 实现 .NET Standard 并且可实现其他 API 的类库。 示例：.NET Framework 基类库、.NET Core 基类库。 .NET Standard .NET Standard 是一组所有 .NET 平台都应实现的 API。 更正式地说，它是构成协定统一集（这些协定是编写代码的依据）的特定 .NET API 组。 这些协定在每个 .NET实现 中实现。 这可实现不同 .NET实现 间的可移植性，有效地使代码可在任何位置运行。 可选择包含一个或多个应用程序框架。 示例：ASP.NET、Windows 窗体…(包含在 .NET Framework 中) 可包含开发工具。 某些开发工具在多个实现之间共享。 .NET架构结构 1、CTS-通用类型系统(Common Type System) .NET实现对语言不可知。 这意味着程序员可以使用可编译为 IL 的任意语言进行编写代码。而且这些通过不同语言进行编写的代码进行交互(即跨语言操作)。 跨语言操作：比如，c#和vb是.NET下两个不同的语言，不过在c#中写的类可以在vb中当做自家写的类一样正常使用。 为透明地执行此操作，必须使用某种通用方式描所有受支持类型。 这正是 CTS 的职责。 其功能如下： 建立用于跨语言执行的框架。 提供面向对象的模型，支持在 .NET 实现上实现各种语言。 定义处理类型时所有语言都必须遵守的一组规则。 提供包含应用程序开发中使用的基本基元数据类型（如 Boolean、Byte、Char 等）的库。 2、CLS-公共语言规范(Common Language Specification) 为实现完全互操作性情景，代码中创建的所有对象都必须依赖于使用它的语言（即其调用方）的某些共性。 由于存在多种不同语言，因此 .NET 在公共语言规范 (CLS) 中指定了这些共性。然后定义了一组规则，开发者都遵守这个规则来编码，那么代码就能被任意.NET平台支持的语言所通用。而与其说是规则，不如说它是一组语言互操作的标准规范，这就是CLS。 注意：CLS 遵从性的规则仅适用于组件的公共接口，而非其私有实现。 3、CLR-公共语言运行 时(或库)(Common Language Runtime) 这里指的是 .NET Framework 的运行时。可以将CLR看成一个在 执行时 管理代码 的代理（托管代码），它提供核心服务（如内存管理（GC）、线程管理和远程处理），而且还强制实施严格的类型安全以及可确保安全性和可靠性的其他形式的代码准确性。事实上，代码管理的概念是 运行时 的基本原则。 托管：以垃圾回收器（GC）为例，在c#中，内存分配和释放的工作本应该是我们做的，现在这些工作却让GC帮你做了，这就是“托管”的概念。因此，C#被称为托管语言。C#编写的代码也就称为托管代码,C#生成的模块称为托管模块等。从这个角度来看，那些脱离了.NET提供的诸如垃圾回收器这样的环境管制，就是对应的 非托管了。 CLR管理内存、线程执行、代码执行、代码安全验证、编译以及其他系统服务。这些功能是在CLR上运行的托管代码所固有的。这套环境及体系之完善，以至于就像一个小型的系统一样，所以通常形象的称CLR为”.NET虚拟机”。 .NET程序的编译执行 对于用非托管语言(c/c++)编写的程序源代码，编译时翻译器将源码翻译为本地 机器语言，以文件形式保存在硬盘上；运行时，操作系统将文件读出到内存，然后CPU从内存中取出指令执行。 对于托管代码，编译时将源码翻译为微软中间语言（IL）代码，运行的时候通过JIT（即时编译器）翻译为本地机器语言，同时.NET代码运行时有一个CLR环境来管理程序。 翻译器与解释器： 在编译时翻译器将源代码翻译成机器语言保存到文件中（例如C/C++）；执行效率高，不过难以移植。 在运行时解释器对源代码逐行进行翻译和执行（例如Python）；执行效率较低，不过易于移植。 二、C#简介1、 C#及其特点 C#是微软公司在2000年7月发布的一种全新且简单、安全、面向对象的程序设计语言，是专门为.NET的应用而开发的语言。它吸收了C++、Visual Basic、Delphi、Java等语言的优点，体现了当今最新的程序设计技术的功能和精华。C#继承了C语言的语法风格，同时又继承了C++的面向对象特性。不同的是，C#的对象模型已经面向Internet进行了重新设计，使用的是.NET框架的类库；C#不再提供对指针类型的支持，使得程序不能随便访问内存地址空间，从而更加健壮；C#不再支持 多重继承，避免了以往类层次结构中由于多重继承带来的可怕后果。.NET框架为C#提供了一个强大的、易用的、逻辑结构一致的程序设计环境。同时，公共语言运行时（Common Language Runtime）为C#程序语言提供了一个托管的运行时环境，使程序比以往更加稳定、安全。总结一下，c#特点有： 语言简洁。 保留了C++的强大功能。 快速应用开发功能。 语言的自由性。 强大的Web服务器控件。 支持跨平台。 与XML相融合。 2、 c#存在哪些缺点呢？ 不适合开发高性能的程序：因为中间语言和编译过程，比C/C++等语言会慢一些，还有就是内存自动回收机制导致难以立即释放不需要的内存，不采用(不建议)内联函数和析构函数。 Windows平台以外支持有限： 因为除Windows外，还没有其他操作系统上的稳定版本的.Net Framework环境，提供给.Net 程序来运行。 3、 c#与其它语言的比较 C#与C++的比较 编译目标：C++代码直接编译为本地可执行代码，而C#默认编译为中间语言（IL）代码，执行时再通过Just-In-Time将需要的模块临时编译成本地代码。 内存管理：C++需要显式地删除动态分配给堆的内存，而C#不需要这么做，C#采用垃圾回收机制自动在合适的时机回收不再使用的内存。 指针：C++中大量地使用指针，而C#使用对类实例的引用，如果确实想在C#中使用指针，必须声明该内容是非安全的。不过，一般情况下C#中没有必要使用指针。 字符串处理：在C#中，字符串是作为一种基本数据类型来对待的，因此比C++中对字符串的处理要简单得多。 库：C++依赖于以继承和模板为基础的标准库，C#则依赖于.NET基库。 C++允许类的多继承，而C#只允许类的单继承，而通过接口实现多继承。 C#与Java的比较 C#面向对象的程度比Java高。 C#中的基本类型都是面向对象的。 C#具有比Java更强大的功能。 C#语言的执行速度比Java快。 4、值类型与引用类型，装箱与拆箱 在c#中，值类型的变量直接储存数据，数据存在栈中，执行复制操作时，复制了一个新的数据给另一个变量，两个数据相互独立；而引用类型持有的是数据的引用，在栈上开辟一小块内存储存一个地址，地址指向堆中实际储存数据的内存（相当于c++中的指针，只是c#做了一些工作使这个指针与它指向的对象更紧密的联系在一起了）。 数据从值类型转换为引用类型的过程被称为“装箱”，从引用类型转换为值类型的过程被称为“拆箱”。装箱与拆箱操作比较费时，应该尽量避免装箱拆箱操作。 值类型与引用类型的分类 .NET中六个重要的概念：栈、堆、值类型、引用类型、装箱和拆箱：https://www.cnblogs.com/edisonchou/p/3947170.html 什么是.NET：https://www.cnblogs.com/1996V/p/9037603.html#net3 注：图片来自网上","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://syfx.github.io/categories/编程语言/"}],"tags":[{"name":".NET","slug":"NET","permalink":"http://syfx.github.io/tags/NET/"},{"name":"c#","slug":"c","permalink":"http://syfx.github.io/tags/c/"}]},{"title":"最短路径算法Floyd与Dijkstra","slug":"最短路径算法Floyd与Dijkstra","date":"2019-04-17T13:30:37.000Z","updated":"2019-05-29T05:46:46.745Z","comments":true,"path":"2019/04/17/最短路径算法Floyd与Dijkstra/","link":"","permalink":"http://syfx.github.io/2019/04/17/最短路径算法Floyd与Dijkstra/","excerpt":"","text":"一、弗洛伊德算法（Floyd） Floyd算法的思想比较简单，它的核心代码只有5行； 12345for (int k = 0; k &lt; G.vCount; ++k) for (int i = 0; i &lt; G.vCount; ++i) for (int j = 0; j &lt; G.vCount; ++j) if (G.arcs[i][j] &gt; G.arcs[i][k] + G.arcs[k][j]) G.arcs[i][j] = G.arcs[i][k] + G.arcs[k][j]; 对于一个有向图G： 我们可以认为当前二维数组中的值表示的是两个顶点之间的直接路径长度（即中间不经过其它顶点进行中转时的路径）。这个直接路径并不一定是最短路径。例如：G[1][3] = 6表示从1到3的直接路径长度为6，当我们引入2号顶点作为中转点时，（即先从顶点1走到顶点2，再从顶点2走到顶点3），从顶点1到3的路径长度可以更短，为G[1][2] + G[2][3] = 5; 上述思想的代码实现非常简单： 1234567891011121314void Floyd(Graph G)&#123; for (int k = 0; k &lt; G.vCount; ++k) &#123; for (int i = 0; i &lt; G.vCount; ++i) &#123; for (int j = 0; j &lt; G.vCount; ++j) &#123; if (G.arcs[i][j] &gt; G.arcs[i][k] + G.arcs[k][j]) G.arcs[i][j] = G.arcs[i][k] + G.arcs[k][j]; &#125; &#125; &#125; cout &lt;&lt; \"任意两点间的最短距离为：\" &lt;&lt; endl; //打印最终结果 ShowGraph(G);&#125; 这段代码中，最外层的循环用来控制当前允许经过哪个点进行中转。内层的两个循环表示当经过此中转点时一个顶点到其他所有顶点的距离是否能更短，若能更短，则更新最短距离。用一句话概括就是：从i号顶点到j号顶点只经过前k号顶点的最短路径(比如当要经过k-1顶点进行中转时，图中的储存的路径已经是经过前k-1号顶点时的最短路径了)，这其实是一种“动态规划”的思想（可以根据 斐波那契数列 想象一下这个思想）。 由代码不难看出，Floyd算法的时间复杂度为O(n^3),因为要储存两两顶点间的最短路径，所以空间复杂度为O(n^2)（我在这里没有使用辅助空间，直接在原图中进行操作了）。 二、迪杰斯特拉算法（Dijkstra） Dijkstra算法是一种“单源最短路径算法”（求一个顶点(源点)到其余各个顶点的最短路径），它是一种采用贪婪策略（在对问题求解时，总是做出在当前看来是最好的选择）实现的算法。 对于有向图G： 在算法中，我们声明一个dis数组用来储存源点到其余顶点的的最短路径的“预估值”。以0号顶点为源点，有： 在dis表中选择到源点“预估值”最小的顶点（不包括源点本身），为dis[1] = 2;选择1号顶点后，dis[1]的值就可以从“预估值”变成“确定值”了；为什么呢？因为目前到源点最近的顶点为1号顶点，且图中边的权重都是正数（此算法不适用于带负权图），因此，不可能找到一个中转点使得从源点到1号顶点的路径更短。这样的话，我们就还需要使用一个数组book来标记源点到当前点的最短路径是否为确定值（一般使用两个列表来分别储存“预估值”与“确定值”）。 确定源点到1号顶点的最短路径之后，我们对1号顶点的所有出边进行松弛：对于1号顶点，有一条出边1-&gt;2，我们讨论当通过1号顶点进行中转时，源点到2号顶点的路径是否能更短，即比较dis[2]与dis[1] + G[1][2]的大小，如果更短，则更新dis[2]的值。这一过程称为边的松弛。对1号顶点的所有出边松弛完毕后，继续在“预估值”中选取最小的值执行边松弛操作，直到所有“预估值”变为“确定值”。 代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344void Dijkstra(Graph G, int origin)&#123; //dis：储存源点到其它点的最短距离，book：用来做标记，标记到当前点到源点的最短距离是否已被确定 int *dis = new int[G.vCount], *book = new int[G.vCount]; int i = 0, j = 0, k = 0, s = 0, min = MaxInt; for (i = 0; i &lt; G.vCount; ++i) &#123; //GetSub(G,origin)：获取源点在顶点表中的下标 s = GetSub(G, origin); dis[i] = G.arcs[s][i]; &#125; //初始化标记 for (i = 0; i &lt; G.vCount; ++i) &#123; book[i] = 0; &#125; //设置源点到源点的最短距离为已确定 book[s] = 1; //确定源点到dis表里的所有顶点的最短距离，算法核心 for (i = 1; i &lt; G.vCount; ++i) &#123; min = MaxInt; //在未确定到源点最短距离的顶点中找到离源点最近的顶点 for (j = 1; j &lt; G.vCount; ++j) &#123; if (book[j] == 0 &amp;&amp; dis[j] &lt; min) &#123; min = dis[j]; s = j; &#125; &#125; //设置s点到源点的最短距离为已知 book[s] = 1; //对当前顶点的出边进行松弛 for (k = 0; k &lt; G.vCount; ++k) &#123; //判断下标为s的顶点到下标为k的顶点间是否存在边，若存在，对其进行松弛操作 if (G.arcs[s][k] &lt; MaxInt) &#123; if (dis[k] &gt; dis[s] + G.arcs[s][k]) &#123; dis[k] = dis[s] + G.arcs[s][k]; &#125; &#125; &#125; &#125; //打印最短路径 for (i = 0; i &lt; G.vCount; ++i) &#123; cout &lt;&lt; \"点\" &lt;&lt; origin &lt;&lt; \"到\" &lt;&lt; G.vexs[i] &lt;&lt; \"的最短距离为：\" &lt;&lt; dis[i] &lt;&lt; endl; &#125;&#125; Dijkstra算法的时间复杂度为O(n^2)，在对算法的优化方面，可以使用最小堆在来实现查找最小“预估值”操作，若数据较多，且图为稀疏图时，通过邻接表来储存边，也能在一定程度上优化此算法的性能。 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;iostream&gt;using namespace std;const int Num = 50;const int MaxInt = 32767;struct Graph &#123; int vexs[Num]; //顶点表 int arcs[Num][Num]; //边表 int vCount; //顶点数量 int aCount; //边数量&#125;;//获取值在顶点表中下标int GetSub(Graph G, int value)&#123; int i; for (i = 0; i &lt; G.vCount; ++i) &#123; if (G.vexs[i] == value) break; &#125; return i;&#125;//创建图（邻接矩阵）void CreatMap(Graph &amp;G)&#123; int t1, t2, w; //输入顶点信息 for (int i = 0; i &lt; G.vCount; ++i) &#123; cin &gt;&gt; G.vexs[i]; &#125; for (int i = 0; i &lt; G.vCount; ++i) for (int j = 0; j &lt; G.vCount; ++j) &#123; G.arcs[i][j] = MaxInt; if (i == j) G.arcs[i][j] = 0; &#125; for (int i = 0; i &lt; G.aCount; ++i) &#123; cin &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; w; int s1 = GetSub(G, t1); int s2 = GetSub(G, t2); if (s1 != G.vCount &amp;&amp; s2 != G.vCount) &#123; G.arcs[s1][s2] = w; //G.arcs[s2][s1] = w; //无向图 &#125; &#125;&#125;//打印图void ShowGraph(Graph G) &#123; for (int i = 0; i &lt; G.vCount; ++i) &#123; for (int j = 0; j &lt; G.vCount; ++j) &#123; cout &lt;&lt; G.arcs[i][j] &lt;&lt; \"\\t\"; &#125; cout &lt;&lt; endl; &#125;&#125;//弗洛伊德算法void Floyd(Graph G)&#123; for (int k = 0; k &lt; G.vCount; ++k) &#123; for (int i = 0; i &lt; G.vCount; ++i) &#123; for (int j = 0; j &lt; G.vCount; ++j) &#123; if (G.arcs[i][j] &gt; G.arcs[i][k] + G.arcs[k][j]) G.arcs[i][j] = G.arcs[i][k] + G.arcs[k][j]; &#125; &#125; &#125; cout &lt;&lt; \"任意两点间的最短距离为：\" &lt;&lt; endl; //打印最终结果 ShowGraph(G);&#125;/*迪杰斯特拉算法G：图origin：源点（起点）*/void Dijkstra(Graph G, int origin)&#123; //dis：储存源点到其它点的最短距离，book：用来做标记，标记到当前点到源点的最短距离是否已被确定 int *dis = new int[G.vCount], *book = new int[G.vCount]; int i = 0, j = 0, k = 0, s = 0, min = MaxInt; for (i = 0; i &lt; G.vCount; ++i) &#123; //GetSub(G,origin)：获取源点在顶点表中的下标 s = GetSub(G, origin); dis[i] = G.arcs[s][i]; &#125; //初始化标记 for (i = 0; i &lt; G.vCount; ++i) &#123; book[i] = 0; &#125; //设置源点到源点的最短距离为已确定 book[s] = 1; //确定源点到dis表里的所有顶点的最短距离，算法核心 for (i = 1; i &lt; G.vCount; ++i) &#123; min = MaxInt; //在未确定到源点最短距离的顶点中找到离源点最近的顶点 for (j = 1; j &lt; G.vCount; ++j) &#123; if (book[j] == 0 &amp;&amp; dis[j] &lt; min) &#123; min = dis[j]; s = j; &#125; &#125; //设置s点到源点的最短距离为已知 book[s] = 1; //对当前顶点的出边进行松弛 for (k = 0; k &lt; G.vCount; ++k) &#123; //判断下标为s的顶点到下标为k的顶点间是否存在边，若存在，对其进行松弛操作 if (G.arcs[s][k] &lt; MaxInt) &#123; if (dis[k] &gt; dis[s] + G.arcs[s][k]) &#123; dis[k] = dis[s] + G.arcs[s][k]; &#125; &#125; &#125; &#125; //打印最短路径 for (i = 0; i &lt; G.vCount; ++i) &#123; cout &lt;&lt; \"点\" &lt;&lt; origin &lt;&lt; \"到\" &lt;&lt; G.vexs[i] &lt;&lt; \"的最短距离为：\" &lt;&lt; dis[i] &lt;&lt; endl; &#125;&#125;int main()&#123; Graph G; cin &gt;&gt; G.vCount &gt;&gt; G.aCount; CreatMap(G); ShowGraph(G); Floyd(G); Dijkstra(G, 0); system(\"pause\"); return 0;&#125;/*10 130 1 2 3 4 5 6 7 8 90 1 30 6 60 4 51 2 2 1 9 92 3 13 6 34 5 35 6 26 7 26 9 37 8 68 9 8*/","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://syfx.github.io/categories/数据结构与算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://syfx.github.io/tags/算法/"},{"name":"最短路径","slug":"最短路径","permalink":"http://syfx.github.io/tags/最短路径/"},{"name":"图","slug":"图","permalink":"http://syfx.github.io/tags/图/"}]},{"title":"常用排序算法","slug":"常用排序算法","date":"2019-04-04T12:11:15.000Z","updated":"2019-05-29T03:52:23.105Z","comments":true,"path":"2019/04/04/常用排序算法/","link":"","permalink":"http://syfx.github.io/2019/04/04/常用排序算法/","excerpt":"","text":"常用排序算法 常用算法分类 常用算法性能分析 后三个算法中的 k 表示桶的数量 稳定/不稳定：若i&lt;j,a[i]=a[j],排完序后a[i]与a[j]的相对位置不发生变化(即仍然i&lt;j)，则称算法是稳定的，反之不稳定。这种特性在一些情况下还是有用的，例如对按学生姓名排好序的列表再按成绩排序时，可以保证成绩相同的学生是按照姓名排序的。在位：如果一个算法不需要额外的储存空间（除了个别储存单元外），我们把它称为是在位的。 1、冒泡排序（Bubble Sort） 冒泡排序的基本思想是：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。如果对n个数按从小到大排序的话，就要执行n-1趟“冒泡”操作，每执行一趟都将剩余列表中的最大值交换到最后。 123456789101112131415void bubblesort(int *array, int length)&#123; int temp; //执行length-1趟\"冒泡\"操作 for (int i = 0; i &lt; length - 1; ++i) &#123; //在剩余数列中对满足条件的两个数执行交换操作 for (int j = 0; j &lt; length - i - 1; ++j) &#123; if (array[j] &gt; array[j + 1]) &#123; temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125;&#125; 冒泡排序是一种基于蛮力法的算法，因此在处理较多的数据时，使用冒泡排序显然不是一个好的选择。通过这样可以对冒泡排序的性能进行少许提升：若在一次循环中没有进行元素交换的操作，就表示列表已经有序，可以直接结束算法了。（这样最好情况下时间复杂度就是O(n)了） 2、快速排序（Quick Sort） 快速排序是最常用的排序算法，它是基于二分思想（分治法）的一种排序，要求升序排列时； 在要排序的数列中找一个基准值（pivot） 然后将数列中小于基准值的数放到基准值左边，大于基准值的数放到基准值的右边 递归的对基准值左边和右边的数列执行上述步骤 对数列6 1 2 7 9 3 4 5 10 8执行1、2步骤图示：注意 j 先出发 12345678910111213141516171819202122232425void quicksort(int* array, int left, int right)&#123; int i, j, t, temp; if (left &gt; right) return; temp = array[left]; //设置基准值 i = left; j = right; while (i != j) &#123; //先让 j--,因为基准值在最左边，先 j-- 可以保证 i，j 相遇处的值绝对小于基准值 while (array[j] &gt;= temp &amp;&amp; i &lt; j) j--; while (array[i] &lt;= temp &amp;&amp; i &lt; j) i++; if (i &lt; j) &#123; t = array[i]; array[i] = array[j]; array[j] = t; &#125; &#125; array[left] = array[i]; array[i] = temp; quicksort(array, left, i - 1); //排序基准值左边的数列 quicksort(array, i + 1, right); //排序基准值右边的数列&#125; 算法处理过程： 快速排序之所以比较快，是因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样只能在相邻的数之间进行交换，交换的距离就大得多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下（例如以两端为基准点对有序列表再次排序时），即分裂点位于数列的两端时，仍是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的；最好情况下，即分裂点在中间时，时间复杂度为O(nlogn)。对于快速算法的优化，包括以下几个方面： 更好的基准选择方法（如 三平均分区法，以最左边、最右边和中间的元素的中值作为基准值）； 当子数组足够小时改用更简单的排序算法； 避免递归（非递归快速排序）； 3、选择排序（Selection Sort） 选择排序也是蛮力法在排序方面的一种应用。选择排序开始时，我们扫描整个列表找到值最小的元素与第一个元素交换，然后从第二个元素开始扫描整个列表，找到最小值与第二个元素进行交换，直到从第n-1个元素开始扫描整个列表找到最小值与第n-1位元素进行交换。 1234567891011121314void SelectionSort(int* array, int len)&#123; int temp, minIndex; for (int i = 0; i &lt; len - 1; ++i) &#123; int minIndex = i; for (int j = i + 1; j &lt; len; ++j) &#123; if (array[minIndex] &gt; array[j]) minIndex = j; &#125; temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; &#125;&#125; 无论输入的数列是怎样的，选择排序的时间复杂度都是O(n^2),然而，键的交换次数仅为O(n)。 4、插入排序（Insertion Sort） 插入排序是一种通过减一技术(减治法)实现的排序算法。 减治技术利用了一个问题给定实例的解和同样问题较小实例的解之间的某种关系。一旦建立 了这种关系，我们就可以从顶至下(递归)或从底至上(非递归)地来运用该关系。 插入排序就建立了这种关系：假设一个列表的前n-1项已经有序，我们可以通过把第n项元素插入到这个较小规模的有序列表中，得到最终的有序列表。假设当前要插入的元素为temp，我们从右到左扫描这个有序的子数组，遇到第一个小于等于temp的元素，然后把temp插入到该元素后面。 12345678910111213141516171819202122232425262728293031//插入排序void InsertionSort(int* array, int len)&#123; int temp, preIndex; for (int i = 1; i &lt; len; ++i) &#123; temp = array[i]; //储存当前要向有序链表中插入的元素的值 preIndex = i; while (preIndex &gt; 0 &amp;&amp; temp &lt; array[preIndex - 1]) &#123; array[preIndex] = array[preIndex - 1]; preIndex--; &#125; array[preIndex] = temp; &#125;&#125;//插入排序（递归）void InsertionSort2(int* array, int len)&#123; if (len == 1) return; InsertionSort2(array, len - 1); int preIndex, temp; temp = array[len - 1]; preIndex = len - 1; while (preIndex &gt; 0 &amp;&amp; temp &lt; array[preIndex - 1]) &#123; array[preIndex] = array[preIndex - 1]; --preIndex; &#125; array[preIndex] = temp;&#125; 在最坏情况下，temp &lt; array[preIndex - 1]的执行次数达到最大（比如是个递减的列表(相对而言，上述代码是升序排序)），这是算法复杂度为O(n^2)。然而，对于有序数组这种最优输入，该算法有着非常好的性能。对于升序排序来说，当输入的列表为升序列表时，temp &lt; array[preIndex - 1]只需执行n次，即时间复杂度为O(n)。因此，当输入数列基本有序时，插入排序能够有更好的性能 5、希尔排序（Shell Sort） 希尔排序又称“缩小增量排序”，希尔排序从“减少记录个数”和“序列基本有序”两个方面对直接插入排序进行了改进。在希尔排序中，对列表进行分组，对每组记录进行直接插入排序，经过几次分组之后，整个列表中的记录都“基本有序”了，这时在对整体进行一次直接插入排序。希尔排序通过相隔某个“增量”对记录进行分组。 123456789101112131415161718void ShellSort(int* array, int len)&#123; int temp, preIndex; //增量（grp）为1时，对整个数组进行直接插入排序， //此时的数列基本上是排好序的了。 for (int grp = len / 2; grp &gt; 0; grp /= 2) &#123; //对每组进行插入排序 for (int i = grp; i &lt; len; ++i) &#123; preIndex = i - grp; temp = array[i]; while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; temp) &#123; array[preIndex + grp] = array[preIndex]; preIndex -= grp; &#125; array[preIndex + grp] = temp; &#125; &#125;&#125; 希尔排序只能用于顺序结构，不能用于链式结构，增量序列可以有各种取法，但应该使增量序列的值没有除1之外的公因子，并且最后一个增量的值必须为1，记录总的比较次数和移动次数比直接插入排序要少，记录个数越多，效果越明显，因此，希尔排序更适合初始记录无须、数据量较大时的情况。 6、堆排序（Heap Sort） 堆排序是一种树型选择排序，在排序过程中，将待排序序列看成一棵完全二叉树。利用完全二叉树中双亲结点与孩子结点之间的内在关系，在当前序列中选择最大（或最小）的记录。通过大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征，来选择当前序列中的最大（或最小）的记录。 堆的定义（1 &lt;= i &lt;= n/2）（1）ki &gt;= k2i且ki &gt;= k2i+1 （2）ki &lt;= ki且ki &lt;= ki+1按堆的定义将带排序序列调整为大根堆，交换r[1]与r[n],调整剩余数列为大顶堆（即只需将当前堆顶元素向下调整即可），直到堆中只剩一个元素为止。 123456789101112131415161718192021222324252627282930313233343536//向下调整void SiftDown(int *array, int n, int i)&#123; //如果当前结点至少存在一个孩子结点，比较它与孩子结点的大小 while ((2 * i + 1) &lt;= n) &#123; int t = i; if (array[t] &lt; array[2 * i + 1]) t = 2 * i + 1; if ((2 * i + 2) &lt;= n &amp;&amp; array[t] &lt; array[2 * i + 2]) t = 2 * i + 2; //当前结点比它的孩子结点小，进行交换 if (t != i) &#123; int temp = array[t]; array[t] = array[i]; array[i] = temp; i = t; //当前结点的索引变为t &#125; //当前结点比它两个孩子结点的值大，结束调整 else break; &#125;&#125;void HeapSort(int *array, int n)&#123; //（初始化堆）从最后一个非叶结点的结点开始依次进行向上调整 for (int i = n / 2; i &gt;= 0; --i) &#123; SiftDown(array, n, i); &#125; //将堆顶元素放到最后，并在剩余的 n-- 数内对新的堆顶元素向下调整 while (n &gt;= 0) &#123; int temp = array[n]; array[n] = array[0]; array[0] = temp; SiftDown(array, --n, 0); &#125;&#125; 对于堆排序，初建堆时比较次数较多，因此记录较少时不宜采用，当记录较多时较为高效。 7、归并排序（Merge Sort） 归并排序就是将两个或者两个以上的有序列表合成一个有序列表的过程。将2个有序表合成一个有序表的过程称为2-路归并。对一个有n个记录的列表进行归并排序时，可以将列表看成是n个有序的子序列，每个序列的长度为1。然后两两合并得到n/2个长度为2或1的有序子序列，再两两合并，直到得到一个长度为n的有序序列为止。在归并时，分别从两个要归并的序列中得到最小的值，放到一个新的列表中，重复这个过程直到其中一个列表为空，然后将非空列表中的剩余部分直接复制到新列表中。 1234567891011121314151617181920212223242526272829303132void merge(int *array, int L_left, int L_right, int R_left, int R_right)&#123; //申请一个新数组用来储存排好序的数组 int *temp = new int[R_right - L_left + 1]; int i = L_left, j = R_left, k = 0; //将两数组中的数据有序归并到temp中 while (i &lt;= L_right &amp;&amp; j &lt;= R_right) &#123; temp[k++] = (array[i] &lt; array[j]) ? array[i++] : array[j++]; &#125; //将左数组或者右数组中剩余的有序数列归并到temp中 while (i &lt;= L_right) &#123; temp[k++] = array[i++]; &#125; while (j &lt;= R_right) &#123; temp[k++] = array[j++]; &#125; //将排好序的数列替换到原数列中 k = 0; for (i = L_left; i &lt;= R_right; ++i) &#123; array[i] = temp[k++]; &#125; //释放临时开辟的空间 delete[] temp;&#125;void MergeSort(int *array, int left, int right)&#123; if (left + 1 &lt;= right) &#123; MergeSort(array, left, (right + left) / 2); MergeSort(array, (right + left) / 2 + 1, right); merge(array, left, (right + left) / 2, (right + left) / 2 + 1, right); &#125;&#125; 用顺序表实现归并排序时，需要和待排序记录个数相等的辅助储存空间，因此空间复杂度为O(n)，归并排序可用于练市结构，且不需要附加的储存空间。 以上排序算法测试源代码： https://github.com/syfx/Sort/blob/master/Sort/Sort.cpp","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://syfx.github.io/categories/数据结构与算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://syfx.github.io/tags/算法/"}]},{"title":"链表相关操作","slug":"链表相关操作","date":"2019-04-04T04:14:47.000Z","updated":"2019-05-23T01:15:30.131Z","comments":true,"path":"2019/04/04/链表相关操作/","link":"","permalink":"http://syfx.github.io/2019/04/04/链表相关操作/","excerpt":"","text":"链表相关操作 求单链表中结点的个数 将单链表反转 查找单链表中的倒数第K个结点（k &gt; 0） 查找单链表的中间结点 从尾到头打印单链表 已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序 判断两个单链表是否相交 求两个单链表相交的第一个结点 判断一个单链表中是否有环 已知一个单链表中存在环，求进入环中的第一个结点 给出一单链表头指针pHead和一结点指针pToBeDeleted，O(1)时间复杂度删除结点pToBeDeleted 链表结构 1234567891011121314151617181920212223242526 typedef struct List &#123; int val; List* next;&#125;*myList;//创建链表myList CreatList(unsigned int length)&#123; if (length == 0) return NULL; myList head, tail, temp; head = new List(); head-&gt;next = NULL; tail = head; //在32位系统中size_t是4字节的，而在64位系统中，size_t是8字节的，这样利用该类型可以增强程序的可移植性。 for (size_t i = 0; i &lt; length; ++i)&#123; temp = new List(); cin &gt;&gt; temp-&gt;val; temp-&gt;next = NULL; tail-&gt;next = temp; tail = temp; &#125; temp = head; head = head-&gt;next; delete temp; return head;&#125; 1、求单链表中结点的个数 因为要求链表中结点的个数，因此只能遍历整个链表以确定结点个数。(；´д｀)ゞ 123456789int Length(myList head)&#123; int length = 0; while (head) &#123; length++; head = head-&gt;next; &#125; return length;&#125; 2、将单链表反转 当链表中节点个数大于1时，保存链表的头结点为oldHead指针（因为反转后这就不是头指针了），如果oldHead的后继结点不为空的话，使用指针temp储存这个结点，然后赋值oldHead的后继结点为其后继结点(即temp)的后继结点，然后将temp的后继结点设置为head结点，赋值head为temp； 123456789101112void ReverseList(myList &amp;head)&#123; if (head == NULL || head-&gt;next == NULL) return; myList temp, oldHead = head; while (oldHead-&gt;next) &#123; temp = oldHead-&gt;next; oldHead-&gt;next = temp-&gt;next; temp-&gt;next = head; head = temp; &#125;&#125; 3、查找单链表中的倒数第K个结点（k &gt; 0） 使用两个指针left，right，先让right指向正数第k个结点，然后让left结点从头结点与right指针一同向后移动。当right指向最后一个结点时，left指向的就是倒数第k个结点。 12345678910111213141516myList FindCountBackwardsK(myList head, unsigned int k) &#123; if (head == NULL) return NULL; myList left = head, right = head; for (size_t i = 1; i &lt; k; ++i)&#123; right = right-&gt;next; if (!right) return NULL; &#125; while (right &amp;&amp; right-&gt;next)&#123; right = right-&gt;next; left = left-&gt;next; &#125; return left;&#125; 4、查找单链表的中间结点 使用快慢指针，快指针每次向后移动两个结点的距离，慢指针每次向后移动一个指针距离，当快指针为空时，慢指针指向的结点便是中间结点。 12345678910111213myList FindMiddleNode(myList head)&#123; myList left = head, right = head; if (head == NULL) return NULL; while (right-&gt;next)&#123; right = right-&gt;next-&gt;next; if (right == NULL) break; left = left-&gt;next; &#125; return left;&#125; 5、从尾到头打印单链表 由从尾到头可以很容易想到能够使用递归或者栈来实现。使用递归时，在遇到链表尾结点时返回，然后打印结点的值。 1234567891011121314151617181920212223//从尾到头打印单链表（递归）void PrintListFromTailToHead(myList head)&#123; if (head == NULL) return; PrintListFromTailToHead(head-&gt;next); cout &lt;&lt; head-&gt;val &lt;&lt; endl;&#125;//从尾到头打印单链表（通过栈）void PrintListFromTailToHeadByStack(myList head)&#123; stack&lt;myList&gt; sta; while (head)&#123; sta.push(head); head = head-&gt;next; &#125; while (!sta.empty())&#123; cout &lt;&lt; sta.top()-&gt;val &lt;&lt; \" \"; sta.pop(); &#125; cout &lt;&lt; endl;&#125; 6、已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序 可是使用归并排序的思想；选择值较小的头结点作为新的头结点，然后遍历两个链表，将值较小的结点合并到新链表中，遍历此链表的指针向后移位，另一个指针不做处理；当一个链表为空后，将不为空的链表合并到新链表中。 12345678910111213141516171819202122232425262728293031323334353637myList MergeOrderedLists(myList head1, myList head2)&#123; if (head1 == NULL) return head2; if (head2 == NULL) return head1; myList newHead =NULL; if (head1-&gt;val &gt;= head2-&gt;val) &#123; newHead = head2; head2 = head2-&gt;next; &#125; else &#123; newHead = head1; head1 = head1-&gt;next; &#125; newHead-&gt;next = NULL; myList temp = newHead; while ( head1 &amp;&amp; head2)&#123; if (head1-&gt;val &lt; head2-&gt;val) &#123; temp-&gt;next = head1; head1 = head1-&gt;next; &#125; else &#123; temp-&gt;next = head2; head2 = head2-&gt;next; &#125; temp = temp-&gt;next; temp-&gt;next = NULL; &#125; if (head1 == NULL) &#123; temp-&gt;next = head2; &#125; else &#123; temp-&gt;next = head1; &#125; return newHead;&#125; 7、判断两个单链表是否相交 从这点出发：若两个两链表相交，则这两个链表的尾结点必然相同。因此，我们可以分别遍历链表以得到他们的尾结点，然后判断两个尾结点的地址是否相同即可。 123456789101112131415bool IsIntersect(myList head1, myList head2)&#123; if (head1 == NULL || head2 == NULL) return false; while (head1-&gt;next) &#123; head1 = head1-&gt;next; &#125; while (head2-&gt;next) &#123; head2 = head2-&gt;next; &#125; //若相交则两个链表的最后一个节点必然完全相等 if (head1 == head2) return true; return false;&#125; 8、求两个单链表相交的第一个结点 两链表相交，求相交的第一个结点：先遍历两个链表，分别得到两个链表的长度。（储存一下尾结点，顺便判断一下两个链表是否相交）。求相交的第一个结点时，先让一个指针从长链表的头结点向前移动abs(len1-len2)个距离，然后让另一个指针从短链表头结点出发与这个指针一同向后移动，当两个指针首次指向同一个结点时，这个结点便是两个单链表相交的第一个结点。 12345678910111213141516171819202122232425262728293031323334myList FirstIntersectNode(myList head1, myList head2)&#123; if (head1 == NULL || head2 == NULL) return NULL; int len1 = 1, len2 = 1; myList temp1 = head1, temp2 = head2; while (temp1-&gt;next) &#123; len1++; temp1 = temp1-&gt;next; &#125; while (temp2-&gt;next) &#123; len2++; temp2 = temp2-&gt;next; &#125; //判断两链表是否相交 if (temp1 != temp2) return NULL; //保证head1是两者中较长的链表 if (len1 &lt; len2) &#123; temp1 = head1; head1 = head2; head2 = temp1; &#125; for (int i = 0; i &lt; abs(len1 - len2); ++i) &#123; head1 = head1-&gt;next; &#125; while (head2) &#123; if (head1 == head2) return head1; head1 = head1-&gt;next; head2 = head2-&gt;next; &#125; return NULL;&#125; 9、判断一个单链表中是否有环 可以使用快慢指针来判断单链表中是否存在环：使用两个指针fast、slow，slow每次向后移动一个结点的距离，fast每次向后移动两个结点的距离。若链表存在环的话，两个指针必然会相遇。 123456789101112131415bool IsCircularList(myList head)&#123; if (head == NULL &amp;&amp; head-&gt;next == NULL) return false; myList temp1 = head, temp2 = head; //temp1和temp2都不为空 while (temp1 &amp;&amp; temp2 &amp;&amp; temp2-&gt;next) &#123; temp1 = temp1-&gt;next; temp2 = temp2-&gt;next-&gt;next; if (temp1 == temp2) return true; &#125; return false;&#125; 10、已知一个单链表中存在环，求进入环中的第一个结点 设链表头距离环入口的长度为L，快慢指针相遇的位置为cross，该位置距离环入口的长度为S。考虑快慢指针移动的距离，慢指针走了L+S，快指针走了L+S+nR(n表示两只镇相遇前快指针走的圈数)。由于快指针的速度是慢指针的两倍，相同时间下快指针走过的路程就是慢指针的两倍，所以有2(L+S)=L+S+nR，化简得L+S=nR当n=1时，即快指针在相遇之前多走了一圈，即L+S=R，也就是L=R−S，因此可以使用两个指针，一个指针从链表头部移动，一个从快慢指针第一次相遇处的后个指针开始移动，每次移动一个节点的距离，则两指针相等时所指向的结点就是进入环的第一个结点。 12345678910111213141516171819202122myList CircularListEntrance(myList head)&#123; if (head == NULL) return NULL; myList fast = head, slow = head; while (slow &amp;&amp; fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; //第一次相交 if (slow == fast) &#123; fast = head; while (slow != fast) &#123; //这里让指向第一次相遇处的指针先走 slow = slow-&gt;next; fast = fast-&gt;next; &#125; return slow; &#125; &#125; return NULL;&#125; 11、给出一单链表头指针pHead和一节点指针pToBeDeleted，O(1)时间复杂度删除结点pToBeDeleted 因为每个结点的储存结构都是相同的，因此，当pToBeDeleted不是尾结点时，可以将pToBeDeleted下个节点储存的数据复制到pToBeDeleted结点中，然后进行删除pToBeDeleted-next的操作即可。当pToBeDeleted为尾结点时，就需要遍历整个链表找到pToBeDeleted结点的前驱结点了。不过时间复杂度总体上讲为O(1); 12345678910111213141516171819202122232425void DeleteNode(myList head, myList pToBeDeleted)&#123; if (head == NULL) return; if (pToBeDeleted-&gt;next != NULL) &#123; myList temp = pToBeDeleted-&gt;next; pToBeDeleted-&gt;val = temp-&gt;val; pToBeDeleted-&gt;next = temp-&gt;next; delete temp; temp = NULL; &#125; else &#123; if (head == pToBeDeleted) &#123; delete pToBeDeleted; head = NULL; pToBeDeleted = NULL; &#125; while (head-&gt;next != pToBeDeleted) &#123; head = head-&gt;next; &#125; head-&gt;next = NULL; delete pToBeDeleted; pToBeDeleted = NULL; &#125;&#125; 测试源码：https://github.com/syfx/List/blob/master/lIST/Main.cpp","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://syfx.github.io/categories/数据结构与算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://syfx.github.io/tags/算法/"},{"name":"链表","slug":"链表","permalink":"http://syfx.github.io/tags/链表/"},{"name":"数据结构","slug":"数据结构","permalink":"http://syfx.github.io/tags/数据结构/"}]},{"title":"递归创建二叉树时为什么要传指针的引用？","slug":"递归创建二叉树时为什么要传指针的引用？","date":"2019-03-27T13:43:20.000Z","updated":"2019-04-26T01:07:22.813Z","comments":true,"path":"2019/03/27/递归创建二叉树时为什么要传指针的引用？/","link":"","permalink":"http://syfx.github.io/2019/03/27/递归创建二叉树时为什么要传指针的引用？/","excerpt":"","text":"复习了一下二叉树的知识，想用C++实现一颗二叉树，没想到竟然在创建二叉树时忽略了点东西。本来的惯性思维是：用指针做参数传递时，指针指向的值会被同步改变。。于是调用创建树的方法时，只是传递了空的指针，然后在函数中为指针开辟空间，递归创建二叉树。 然后遍历二叉树时发现二叉树为空。这是为什么呢？上面惯性思维所想的的确没有错，它是对的；那为什么创建的树为空呢？那是因为，我们在创建树时，在创建方法中改变的不仅是指针指向的值，还有指针本身的值。错误的创建代码为： 12345678910111213void CreatTree(BiTree*p)&#123; char ch; cin &gt;&gt; ch; if (ch == '#') p = NULL; else &#123; p = new BiTree(); p-&gt;value = ch; CreatTree(p-&gt;lift); CreatTree(p-&gt;right); &#125;&#125; 在上述代码中，当使用new关键字开辟空间后（new关键在在自由储存区申请一快内存，它返回一个指向这块内存的指针），我们又改变了这个指针指向的值；因此，在这里指针本身和指针指向的值都发生了改变。因此，当我们创建二叉树时，应该使用指针的引用或者二级指针。示例代码如下： 堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。我们可以重载new关键字改用其他内存作为自由储存区。 1234567891011121314151617181920212223242526272829//使用二级指针做参数void CreatTree(BiTree**p) &#123; char ch; cin &gt;&gt; ch; if (ch == '#') *p = NULL; else &#123; *p = new BiTree(); (*p)-&gt;value = ch; CreatTree(&amp;(*p)-&gt;lift); CreatTree(&amp;(*p)-&gt;right); &#125;&#125;//使用指针的引用做参数void CreatTree(BiTree* &amp;p)&#123; char ch; cin &gt;&gt; ch; if (ch == '#') p = NULL; else &#123; p = new BiTree(); p-&gt;value = ch; CreatTree(p-&gt;lift); CreatTree(p-&gt;right); &#125;&#125;","categories":[{"name":"随笔","slug":"随笔","permalink":"http://syfx.github.io/categories/随笔/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://syfx.github.io/tags/C/"},{"name":"二叉树","slug":"二叉树","permalink":"http://syfx.github.io/tags/二叉树/"},{"name":"指针","slug":"指针","permalink":"http://syfx.github.io/tags/指针/"}]},{"title":"设计模式之观察者模式","slug":"设计模式之观察者模式","date":"2019-03-25T12:16:26.000Z","updated":"2019-04-26T02:22:36.742Z","comments":true,"path":"2019/03/25/设计模式之观察者模式/","link":"","permalink":"http://syfx.github.io/2019/03/25/设计模式之观察者模式/","excerpt":"","text":"#观察这模式（Observer Pattern） 观察模式是一种行为模式，定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 观察者模式包含以下四个角色： 抽象目标类：所有具体目标的父类，约束目标类应实现的接口。 具体目标类：实现具体的功能，并在某个事件发生时通知所有观察自己的观察者。 观察者类：观察者的抽象基类，约束观察者类应实现的接口。 具体观察者类：继承自观察者类，实现具体功能。 举例说明，在游戏中，当主角击败BOSS时（即BOSS死亡事件发生），通知 动画管理类播放胜利动画，音效管理类播放胜利音乐。在这个例子中，存在具体目标类BOSS，具体观察者类动画管理类，音效管理类。代码设计如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879using System;using System.Collections.Generic;namespace ObserverPattern&#123; //抽象目标类 abstract class Subject &#123; //目标类的观察类列表 protected List&lt;Observer&gt; obsLists = new List&lt;Observer&gt;(); //抽象注册方法 public abstract void AddObs(Observer obs); //抽象移除方法 public abstract void RemoveObs(Observer obs); //抽象通知方法 public abstract void Notify(); &#125; //抽象观察者类 abstract class Observer &#123; public abstract void Update(); &#125; //boss类 class BOSS : Subject &#123; public override void AddObs(Observer obs) &#123; obsLists.Add(obs); &#125; public override void RemoveObs(Observer obs) &#123; obsLists.Remove(obs); &#125; public override void Notify() &#123; Console.WriteLine(&quot;BOSS死亡！&quot;); foreach(Observer obs in obsLists) &#123; obs.Update(); &#125; &#125; &#125; class AnimatorManager : Observer &#123; public override void Update() &#123; Console.WriteLine(&quot;我是胜利动画！&quot;); &#125; &#125; class AudioManager : Observer &#123; public override void Update() &#123; Console.WriteLine(&quot;我是胜利音乐！&quot;); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; Subject sub = new BOSS(); Observer obs1 = new AnimatorManager(); Observer obs2 = new AudioManager(); //注册事件 sub.AddObs(obs1); sub.AddObs(obs2); //BOSS死亡 sub.Notify(); /** * 输出： * BOSS死亡！ * 我是胜利动画！ * 我是胜利音乐！ * */ Console.ReadKey(); &#125; &#125;&#125; 模式分析： 优点： 观察者模式在只是在观察者和观察者之间建立一个抽象的耦合，因此对业务的逻辑进行了解耦。 使用观察者模式建立一套触发机制，支持广播通讯，被观察者会向所有的登记过的观察者发出通知。 缺点： 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 使用场景： 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。 一个对象必须通知其他对象，而并不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。","categories":[{"name":"编程模式","slug":"编程模式","permalink":"http://syfx.github.io/categories/编程模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://syfx.github.io/tags/设计模式/"}]},{"title":"设计模式之单例模式","slug":"设计模式之单例模式","date":"2019-03-20T06:32:57.000Z","updated":"2019-04-26T02:23:04.643Z","comments":true,"path":"2019/03/20/设计模式之单例模式/","link":"","permalink":"http://syfx.github.io/2019/03/20/设计模式之单例模式/","excerpt":"","text":"单例模式（Singleton Pattern） 单例模式又称单件模式/单态模式，是常用的设计模式之一。单例模式要求其实例对象只能在系统中存在一个。许多时候整个系统只需要拥有一个的全局对象，使用单例模式有利于我们协调系统整体的行为。 单例模式三要素 必须确保一个类只有一个实例 它必须自行创建这个实例 必须自行向整个系统提供这个实例 代码分析（c#） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253namespace Singleton&#123; /* 空间换时间 声明属性时直接将它初始化 缺点：在没有使用时内存已经分配，（如果此单例类未被使用）就造成了空间浪费。 */ class SimpleSingle &#123; private static _mySingle = new SimpleSingle(); public static mySingle&#123; get&#123;return _mySingle;&#125; &#125; &#125; /* 饿汉式 时间换空间 缺点，因为要判断属性是否为null，因此是线程不安全的。 可能一个线程刚进入判断后，CPU被另外一个线程抢占而导致生成多个实例。 */ class Single &#123; private static _mySingle; public static mySingle&#123; get&#123; if(_mySingle == null) _mySingle = new Single(); return _mySingle; &#125; &#125; &#125; /* 懒汉式 使用互斥锁保证线程安全 */ class MySingleton &#123; static public Mutex mutex = new Mutex(); //创建互斥锁对象 static private MySingleton _instance; static public MySingleton instance &#123; get &#123; mutex.WaitOne(); //申请互斥锁 if (_instance == null) _instance = new MySingleton(); mutex.ReleaseMutex(); //释放锁资源 return instance; &#125; &#125; //私有化构造函数 private MySingleton() &#123; &#125; &#125;&#125; 单例模式分析 单例模式保证一个类仅有一个实例，并提供了一个访问它的全局访问点；单例模式拥有一个私有构造函数，确保用户不能再外界实例化它；该模式中还存在一个静态私有变量和一个静态公有工厂方法，在这个工厂方法中确保实例化自己一次，将对象保存到静态成员变量中。 单例模式的优缺点 优点： 提供了对唯一实例的受访控制。单例类封装了它的唯一实例，所以它可以严格控制客户如何访问它。 节约系统资源。在系统中只存在一个对象。 允许可变数量的实例，可以基于单例模式进行扩展，在其工厂方法（获取实例的成员方法）中做控制以用来获取指定数目的实例。 缺点： 单例模式在扩展时有很大的困难，因为单例模式没有抽象层（抽象父类）。 单例类职责过重，在一定程度上违背了“单一职责原则”。它既充当了工厂角色，提供了工厂方法（获取自己的实例）；又充当了产品角色，有自己的业务逻辑；讲产品的创建与自身功能融合到了一起。 滥用单例时将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收（c#、Java等语言具有垃圾自动回收机制），这将导致对象状态的丢失。 适用场景 单例模式只允许创建一个对象，因此节省内存，加快对象访问速度，因此在对象需要被公用的场合适合使用。如： 需要频繁实例化然后销毁的对象。 创建对象时耗时过多或者耗资源过多，但又经常用到的对象。 有状态的工具类对象。 频繁访问数据库或文件的对象。 单例模式的经典使用场景： 资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。 控制资源的情况下，方便资源之间的互相通信。如线程池等。 注意事项 使用时不能用反射模式创建单例，否则会实例化一个新的对象。 使用饿汉单例模式时注意线程安全问题。 单例模式中构造方法都是私有的，因而是不能被继承，有些单例模式可以被继承（如登记式模式）。","categories":[{"name":"编程模式","slug":"编程模式","permalink":"http://syfx.github.io/categories/编程模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://syfx.github.io/tags/设计模式/"}]},{"title":"设计模式之工厂模式","slug":"设计模式之工厂模式","date":"2019-03-18T10:56:15.000Z","updated":"2019-04-26T02:23:55.933Z","comments":true,"path":"2019/03/18/设计模式之工厂模式/","link":"","permalink":"http://syfx.github.io/2019/03/18/设计模式之工厂模式/","excerpt":"","text":"设计模式之工厂模式(Factory Pattern) 工厂模式是最常用的设计模式之一，它属于创建型设计模式；工厂模式 提供了一种创建对象的最好方式 （如果你有更好的方式就当我没说）；它的主要作用是让对象的创建与对象的使用分离开来，即使用单独的类来 封装创建实例的逻辑。工厂模式又可以细分为： 简单工厂模式 工厂方法模式 抽象工厂模式 1、简单工厂模式(Simple Factory Pattern) 又称为静态工厂方法(Static Factory Method)模式；在简单工厂模式中，通常包含一个静态方法，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 简单工厂模式包含以下几种角色： 工厂：负责创建所有具体产品类的实例，工厂类中的静态方法要能够被其它类直接在外界调用，以获得产品对象。 抽象产品类：是所有具体产品的父类，负责定义其它具体产品的所共有的公共接口（子类共有的行为） 具体产品类：继承自抽象产品类，是工厂角色的创建目标。 如果上面说的不好理解的话，那就来个栗子消化一下吧。 在一个游戏中，有三种小怪： MobA 、MobB 、Mobc ;在游戏中，他们都可以攻击主角。这时候，我们就可以使用简单工厂模式来控制它们的 出场（实例生成）。 首先，我们应该创建一个抽象怪物类 Mob ，让上面那三个小怪类继承自Mob。然后用Mob当做工厂中静态方法的返回对象。不太懂得话，就看看代码吧（c#）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071namespace FactoryPattern&#123; //怪物工厂 class MobFactory &#123; //获取对象实例的静态方法 public static Mob GetMob(string mobName) &#123; switch (mobName) &#123; case &quot;MobA&quot;: return new MobA(); case &quot;MobB&quot;: return new MobB(); case &quot;MobC&quot;: return new MobC(); default: return null; &#125; &#125; &#125; ////使用接口实现抽象类会更好 //interface I_Mob //&#123; // //定义攻击接口（规定每个继承自此抽象类的怪物都能进行攻击） // void Attack(); //&#125; //抽象怪物类 abstract class Mob &#123; //定义攻击接口（规定每个继承自此抽象类的怪物都能进行攻击） public abstract void Attack(); &#125; //小怪A class MobA : Mob &#123; //重写Acctak方法 public override void Attack() &#123; Console.WriteLine(&quot;MobA 进行攻击&quot;); &#125; &#125; //小怪B class MobB : Mob &#123; //重写Acctak方法 public override void Attack() &#123; Console.WriteLine(&quot;MobB 进行攻击&quot;); &#125; &#125; //小怪C class MobC : Mob &#123; //重写Acctak方法 public override void Attack() &#123; Console.WriteLine(&quot;MobC 进行攻击&quot;); &#125; &#125; class Test &#123; static void Main(string[] args) &#123; Mob mob = MobFactory.GetMob(&quot;MobA&quot;); mob.Attack(); //MobA进行攻击 mob = MobFactory.GetMob(&quot;MobB&quot;); mob.Attack(); //MobB进行攻击 Console.ReadKey(); &#125; &#125;&#125; 简单工厂模式分析 将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。 对于简单工厂模式，由于其方法是静态的，因此使用起来比较方便。 简单工厂模式虽然满足单一职则原则，不过工厂类的职责相对过重，而且增加新的产品时需要修改工厂类的判断逻辑，不符合开闭原则。 模式优缺点及使用场景 优点 简单工厂模式实现了对责任的分割，它提供了专门的工厂类用于创建对象，降低系统的耦合度。 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可。 缺点 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 使用场景 当需要创建的对象较少且以后基本上不要增加新的对象时，用这个工厂方式还是不错的。 2、工厂方法模式(Factory Pattern) 又被称多态性工厂模式。在这个模式中，不再使用一个类创建所有的产品实例，而是实现一个抽象的工厂父类角色，然后为每个产品都实现一个具体的工厂子类，抽象工厂父类角色，仅负责给出具体工厂子类必须实现的接口，而具体的创建对象的逻辑在子类中实现。 工厂方法模式包含的角色： 抽象工厂类：所有具体工厂的父类，规定工厂子类应实现哪些接口。 具体工厂类：继承自抽象工厂类，用于创建一个特定的产品。 抽象产品类：所有具体产品的父类，负责定义其它具体产品的所共有的公共接口 具体产品类：继承自抽象产品类，是具体工厂类角色的创建目标。 根据上述例子实现的具体代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081namespace FactoryPattern&#123; //怪物接口 interface Mob &#123; void Attack(); &#125; //小怪A class MobA : Mob &#123; //重写Acctak方法 public void Attack() &#123; Console.WriteLine(&quot;MobA 进行攻击&quot;); &#125; &#125; //小怪B class MobB : Mob &#123; //重写Acctak方法 public void Attack() &#123; Console.WriteLine(&quot;MobB 进行攻击&quot;); &#125; &#125; //小怪C class MobC : Mob &#123; //重写Acctak方法 public void Attack() &#123; Console.WriteLine(&quot;MobC 进行攻击&quot;); &#125; &#125; //抽象工厂接口 interface Factory &#123; Mob GetMob(); &#125; //创建怪物A的工厂 class MobA_Factory : Factory &#123; public Mob GetMob() &#123; return new MobA(); &#125; &#125; //创建怪物B的工厂 class MobB_Factory : Factory &#123; public Mob GetMob() &#123; return new MobB(); &#125; &#125; //创建怪物C的工厂 class MobC_Factory : Factory &#123; public Mob GetMob() &#123; return new MobC(); &#125; &#125; class Test &#123; static void Main(string[] args) &#123; //获得小怪A Factory factory = new MobA_Factory(); Mob mob = factory.GetMob(); mob.Attack(); //获得小怪B factory = new MobB_Factory(); mob = factory.GetMob(); mob.Attack(); Console.ReadKey(); &#125; &#125;&#125; 工厂方法模式分析 在这个模式中，将每个具体产品的创建细节分配给每个具体的工厂来实现，这样做不仅使工厂方法具有简单工厂方法的优点，还解决了简单工厂模式职责过重的问题。不过由于每个产品类都要对应一个工厂类，因此使用此模式时，会在一定程度上增加系统的复杂性。 优点 工厂方法模式除了具有简单工厂模式的优点外，还具有以下优点： 进一步的细化了工厂类的职责，真正的实现了在创建实例这块的高内聚、低耦合。 当一个工厂出现问题时不会影响到其他工厂，提高了程序的健壮性。 提高了程序的灵活性，当新添加一个产品时，只需添加一个产品类和相应产品的工厂类即可。 缺点 要为每个产品类创建具体工厂，增加了代码量。（个人感觉有其优点相比，这点缺点可以忽略了） 应用场景 产品等级结构与产品族 产品等级结构：即产品的继承结构，如在上面所用到的例子中，抽象怪物类Mob与小怪MobA、小怪MobB、小怪MobC之间便构成了一个产品等级结构，抽象怪物类是父类，而不同种类的小怪是其子类。 产品族：在抽象工厂模式中会提到，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。 3、抽象工厂模式 抽象工厂模式是当有多个抽象产品时所使用的一种工厂模式。它和工厂方法模式很像，可以把工厂方法模式当成是产品族为1时的抽象工厂模式。 抽象工厂模式包含的角色： 抽象工厂类：所有具体工厂的父类，实现对具体工厂的规范。 具体工厂类：继承自抽象工厂类，用于创建某个产品族中的的产具体产品。 抽象产品类：所有具体产品的父类，负责定义其它具体产品的所共有的公共接口 具体产品类：继承自抽象产品类，是具体工厂类角色的创建目标之一。 修改一下上面那个例子，除了怪物类外，现在还要新添加一个武器类，武器类中包括武器WpA、WpB、WpC；怪物MobA使用WpA，怪物MobB使用WpB，怪物MobC使用WpC；使用抽象工厂模式实现怪物和武器生成的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139//怪物接口interface Mob&#123; void Attack();&#125;//小怪Aclass MobA : Mob&#123; //重写Acctak方法 public void Attack() &#123; Console.WriteLine(&quot;MobA 进行攻击&quot;); &#125;&#125;//小怪Bclass MobB : Mob&#123; //重写Acctak方法 public void Attack() &#123; Console.WriteLine(&quot;MobB 进行攻击&quot;); &#125;&#125;//小怪Cclass MobC : Mob&#123; //重写Acctak方法 public void Attack() &#123; Console.WriteLine(&quot;MobC 进行攻击&quot;); &#125;&#125;//武器接口interface Wp&#123; //攻击加成 void AtkAdd();&#125;//武器WpAclass WpA : Wp&#123; public void AtkAdd() &#123; Console.WriteLine(&quot;MobA专属武器，MobA提高了攻击力&quot;); &#125;&#125;//武器WpAclass WpB : Wp&#123; public void AtkAdd() &#123; Console.WriteLine(&quot;MobB专属武器，MobB提高了攻击力&quot;); &#125;&#125;//武器WpCclass WpC : Wp&#123; public void AtkAdd() &#123; Console.WriteLine(&quot;MobC专属武器，MobC提高了攻击力&quot;); &#125;&#125;//工厂接口interface Factory&#123; //获取怪物实例的方法 Mob GetMob(); //获取武器实例的方法 Wp GetWp();&#125;//A类怪物武器产品族工厂class A_Factory : Factory&#123; //获取怪物实例的方法 public Mob GetMob() &#123; return new MobA(); &#125; //获取武器实例的方法 public Wp GetWp() &#123; return new WpA(); &#125;&#125;//A类怪物武器产品族工厂class B_Factory : Factory&#123; //获取怪物实例的方法 public Mob GetMob() &#123; return new MobB(); &#125; //获取武器实例的方法 public Wp GetWp() &#123; return new WpB(); &#125;&#125;//A类怪物武器产品族工厂class C_Factory : Factory&#123; //获取怪物实例的方法 public Mob GetMob() &#123; return new MobC(); &#125; //获取武器实例的方法 public Wp GetWp() &#123; return new WpC(); &#125;&#125;class Test&#123; static void Main(string[] args) &#123; //A类产品族工厂 Factory factory = new A_Factory(); Mob moba = factory.GetMob(); Wp wpa = factory.GetWp(); wpa.AtkAdd(); moba.Attack(); //B类产品族工厂 factory = new C_Factory(); Mob mobb = factory.GetMob(); Wp wpb = factory.GetWp(); wpb.AtkAdd(); mobb.Attack(); Console.ReadKey(); &#125;&#125; 抽象工厂模式分析 抽象工厂模式符合单一职责原则、开闭原则、里氏替换原则、依赖倒置原则。它为具有多个产品结构的程序提供了一种获得产品实例的方法。 抽象工厂的优缺点 优点： 工厂方法模式除了具有简单工厂模式的优点外，还具有以下优点： 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 增加新的产品族时很方便，只需添加生产相应产品族实例的工厂即可，无须修改已有系统。 缺点： 当增加新的产品等级结构时，需要对抽象工厂和具体工厂类进行修改，不符合开闭原则。","categories":[{"name":"编程模式","slug":"编程模式","permalink":"http://syfx.github.io/categories/编程模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://syfx.github.io/tags/设计模式/"}]},{"title":"STL-map和multimap","slug":"STL-map和multimap","date":"2019-03-17T11:07:58.000Z","updated":"2019-04-26T02:25:25.613Z","comments":true,"path":"2019/03/17/STL-map和multimap/","link":"","permalink":"http://syfx.github.io/2019/03/17/STL-map和multimap/","excerpt":"","text":"简介 map与multimap是键值对容器，支持根据键查找值。multimap可以储存重复的键，而前者只能储存唯一的键。使用两者之前要包含时头文件为实现快速查找，map与multimap的内部结构看起来像二叉树，这意味着在map或multimap中插入数据时将对其进行排序；因此，位于map中特定位置的元素不能替换为值不同的新元素。 map及multimap的实例化 实例化map和multimap的语法如下： 12345#include &lt;iostream&gt;using namespace std;...map&lt;keyType, valueType, Predicate = std::less&lt;keyType&gt;&gt; mapObject;multimap&lt;keyType, valueType, Predicate = std::less&lt;keyType&gt;&gt; multimapObject; 其中Predicate可图换为自定义谓词———一个实现了operator()的类或结构。例： 123456789//实现从大到小排序的谓词template&lt;typename KeyType&gt;struct ReverseSort&#123; bool operator()(const KeyType&amp; key1, const KeyType&amp; key2) &#123; return (key1 &gt; key2); &#125;&#125; 插入元素 在两种容器之中插入元素时，都可以使用成员函数insert:map&lt;int, string&gt; mapInt_StringmapInt_String.insert(make_pair(0, &quot;Number One&quot;));mapInt_String.insert(pair&lt;int, string&gt;(2, &quot;Number Two&quot;)); std::pair主要作用是将两个数据组合成一个数据，两个数据可以是同一类型或者不同类型。pair实质上是一个结构体，其主要的两个成员变量是first和second，这两个变量可以直接使用。初始化一个pair可以使用构造函数，也可以使用std::make_pair函数。make_pair函数的定义如下： template pair make_pair(T1 a, T2 b) { return pair(a, b); }在需要pair类型做参数的位置，可以直接调用make_pair生成pair对象。mark_pair可以接受隐式的类型转换，这样可以获得更高的灵活度。但是这样会出现如下问题：例如有如下两个定义： `std::pair&lt;int, float&gt;(1, 1.1);` `std::make_pair(1, 1.1);` 使用构造函数生成的pair对象的second变量是float类型，而用make_pair生成的pair对象的second变量将是double类型。 查找元素 可使用成员方法find在这两个容器中查找元素。find返回一个迭代器：auto iPairFind = mapInt_String.find(key);使用迭代器iPairFind之前，要检查该迭代器：if(iPairFind != mapInt_String.end()) 注意：在multimap中，因为key值不唯一，因此在使用find查找元素时，返回的迭代器指向首次查找得到的元素。如果想得到所有值，应该使用multimap::count()确定有多少值与指定的key对应。 删除元素 使用成员函数erase对来删除元素。 通过指定的key来删除元素：mapObject.erase(key); 删除迭代器指向的元素：mapObject.erase(iElement); 使用迭代器指定边界，删除指定范围内的所有元素：mapObject.erase(iLowBound, iUpperBound); std::unordered_map与std::unordered_multimap 从C++11起，STL支持散列映射——std::unordered_map,使用时需包含头文件&lt;unordered_map&gt;unordered_map的的平均插入和删除时间是固定的，查找元素的时间也是固定的。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://syfx.github.io/categories/编程语言/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://syfx.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://syfx.github.io/tags/STL/"}]},{"title":"OpenGL简介及其环境配置","slug":"OpenGL简介及其环境配置","date":"2019-03-17T01:21:13.000Z","updated":"2019-04-26T02:26:09.631Z","comments":true,"path":"2019/03/17/OpenGL简介及其环境配置/","link":"","permalink":"http://syfx.github.io/2019/03/17/OpenGL简介及其环境配置/","excerpt":"","text":"涉及内容简介 OpenGL一般它被认为是一个API(Application Programming Interface, 应用程序编程接口)，包含了一系列可以操作图形、图像的函数。然而，OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范。具体的实现是由驱动开发商针对特定显卡实现的。GLFW(Graphics Library Framework)GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。可认为是符合OpenGL规范的具体的库。GLAD由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。所以任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。GLAD用来帮助开发者解决这个问题。（不用自己手动编写代码查询函数了） 渲染（render）：它表示计算机从模型创建最终图像的过程。 编译环境配置 GLFW只是实现了OpenGL规范的具体库中的一个，其他比较流行的还有GLUT，SDL，SFML；我选择使用GLFW。 下载GLFW源文件：官网（需翻墙）打开后点击Source Package按钮进行下载。 下载cMake：官网（需翻墙）打开后选择32位的下载就行。 下载按钮长这样cmake-3.14.0-win32-x86.zip cMake: CMake是一个工程文件生成工具。用户可以使用预定义好的CMake脚本，根据自己的选择（像是Visual Studio, Code::Blocks, Eclipse）生成不同IDE的工程文件。 1、下载好cMake并安装成功后，打开cMake；点击Browsere Source…按钮选择glfw压缩包解压后的整个文件夹 2、点击 Browsere Build… 选择一个文件夹（最好新建一个空的）来存放编译后的文件。 3、点击 Configure (设置)按钮。选择工程的生成器，由于我们使用的是Visual Studio 2015，我们选择 Visual Studio 14 选项（因为Visual Studio 2015的内部版本号是14）。 4、点击 Finish (完成)按钮保存设置。保存之后，点击Generate(生成)按钮，生成的工程文件会在你第二步选择的文件夹中（假设这个文件夹名为build）。 5、在build文件夹中点击 GLFW.sln 打开项目，然后对其进行编译。 6、编译通过后在bulid/src/Debug文件夹中找到库 glfw3.lib （注意我们用的是第3版） 7、推荐建立一个新的目录包含所有的第三方库文件和头文件，每次新建一个工程时都需要指定这些文件夹。可以使用一个单独的文件夹，里面包含libs和include文件夹，在这里存放OpenGL工程用到的所有第三方库和头文件。将第6步的库 glfw3.lib 放到libs文件夹下。 打开GLAD:官网（再翻次吧） GLAD是在线服务，将语言(Language)设置为C/C++，在API选项中，选择3.3以上的OpenGL(gl)版本（我们的教程中将使用3.3版本，但更新的版本也能正常工作）。之后将模式(Profile)设置为Core，并且保证生成加载器(Generate a loader)的选项是选中的。现在可以先（暂时）忽略拓展(Extensions)中的内容。都选择完之后，点击生成(Generate)按钮来生成库文件。GLAD现在应该提供给你了一个zip压缩文件，包含两个头文件目录，和一个glad.c文件。将两个头文件目录（glad和KHR）复制到你的 include 文件夹中，可以将glad.c文件储存到你的include文件夹下（便于寻找）。 经过上面的操作我们已经得到了OpenGL工程中所需要的库和头文件了（bulid文件夹下的所有东西，一定要保存好）；接下来开始配置开发环境吧。 使用VS创建一个Visual C++ 常规空项目。打开 解决方案资源管理器 在项目名称上点击右键——&gt;属性，然后在配置属性下选择VC++目录，编辑 包含目录 和 库目录 分别选择我们的 build 文件夹中的 include 目录和 libs 目录。 在配置属性下选择链接器——&gt;输入，编辑附加依赖项，输入格式为：opengl32.lib 回车 glfw3.lib 然后点击确定按钮。 在配置属性页面确定修改后，环境配置便结束了。在当前项目中新建一个.cpp文件，将下面的代码复制过去，若果能编译且运行成功的话，恭喜你，OK了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;using namespace std;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow* window);int main()&#123; glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); GLFWwindow* window = glfwCreateWindow(800, 600, \"SUCCESS\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create the windows\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; while (!glfwWindowShouldClose(window)) &#123; processInput(window); glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); glfwSwapBuffers(window); glfwPollEvents(); &#125; glfwTerminate(); return 0;&#125;void framebuffer_size_callback(GLFWwindow* windows, int width, int height) &#123; glViewport(0, 0, width, height);&#125;void processInput(GLFWwindow* window) &#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123; glfwSetWindowShouldClose(window, true); &#125;&#125;","categories":[],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://syfx.github.io/tags/OpenGL/"}]},{"title":"STL-set和multiset","slug":"STL-set和multiset","date":"2019-03-16T03:14:26.000Z","updated":"2019-04-26T02:27:30.882Z","comments":true,"path":"2019/03/16/STL-set和multiset/","link":"","permalink":"http://syfx.github.io/2019/03/16/STL-set和multiset/","excerpt":"","text":"简介 使用set与multiset时需要包含头文件 &lt;set>set与multiset让使用者能够在容器中快速查找键（键是储存在一维容器中的值），set和multiset的区别在于set中键值要求唯一，后者可以重复。set与multiset的内部结构像是二叉树，插入与素时要对元素进行排序，因此，相对于vector，list那些容器，set与multiset在插入新元素时效率较低（有额外排序开销），在元素查找方面效率较高。因此，它们适用于那些需要频繁查找的程序中。 set与multiset操作相似，下面的介绍以set为例。 实例化set 实例化一个特定类型的set,以int类型为例： 1set&lt;int&gt; intSet; set与multiset在元素插入时对其进行排序，默认使用std::less对插入数据进行排序。要创建二元谓词，可在类中定义一个operator()： 1234567891011121314151617181920212223template&lt;typename T&gt;struct SortStandard&#123; //从大到小排序 bool operator()(const T&amp; lhs, const T&amp; rhs) &#123; return (lhs &gt; rhs); &#125;&#125;;int main()&#123; //指定排序规则的初始化操作 set&lt;int, SortStandard&lt;int&gt;&gt; intSet; return 0;&#125;&gt;也可以使用另外一个set或者两个set迭代器对其进行初始化：set&lt;int, SortStandard&lt;int&gt;&gt; intSet;set&lt;int&gt; intSet1(intSet.cbegin(), intSet.cend());//这里不能用intSet初始化intSet，因为他们两个排序方式不一样set&lt;int&gt; intSet2(intSet1);&gt;**注意：** 上面代码中不能用intSet初始化intSet，因为他们的排序方式不同。 插入元素 12345678910111213&gt;使用成员函数insert()进行元素插入操作。 set&lt;int&gt; intSet;intSet.insert(-1);intSet.insert(600);intSet.insert(66);set&lt;int&gt; intSet1;intSet1.insert(intSet.cbegin(), intSet.cend());auto pos = ++intSet1.begin();//报错//*pos = 16; 无论使用begin()还是cbegin()获得的迭代器，都不等对*pos进行赋值操作，因为set不允许改变其内元素的值。set也不能使用 [] 操作符获取元素的值；可以使用迭代器来获取元素值。 删除元素 关联容器都提供了成员函数erase()。1、根据键删除值：setObject.erase(key);2、传入一个迭代器，删除迭代器指向的值：setObject.erase(iElement);3、使用迭代器指定边界，删除边界内的所有元素：setObject.erase(iLowerBound, iUpperBound); 1234567set&lt;int&gt; intSet;intSet.insert(-1);intSet.insert(600);intSet.insert(66);intSet.erase(66);intSet.erase(++intSet.begin(), intSet.end()); 当multiset存在多个相同的值时，用setObject.erase(key)删除值时，会将他们全部删除。 123456multiset&lt;int&gt; intSet;intSet.insert(66);intSet.insert(600);intSet.insert(66);intSet.erase(66); C++11 在C++11中，新增加了散列集合unordered_set和unordered_multiset；它们相对于set和multiset进一步的改善了性能。他们使用散列函数来计算排序索引。 使用时添加头文件&lt;unordered_set> 注意，将对象储存到set或multiset中时，别忘了在类中实现运算符&lt;和==，前者将成为排序谓词，后者用于find()函数。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://syfx.github.io/categories/编程语言/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://syfx.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://syfx.github.io/tags/STL/"}]},{"title":"STL-list和forward_list","slug":"STL-list和forward-list","date":"2019-03-16T01:31:38.000Z","updated":"2019-04-26T01:18:24.205Z","comments":true,"path":"2019/03/16/STL-list和forward-list/","link":"","permalink":"http://syfx.github.io/2019/03/16/STL-list和forward-list/","excerpt":"","text":"list的特点 在list开头、中间、末尾插入数据，所需时间都是固定的，将元素从list中产出所需的时间是固定的。插入或者删除元素后，指向list中其他元素的迭代器仍然有效。不过搜索速度比vector慢，因为元素没有储存在连续的内存单元中。 插入元素 使用成员函数push_back()和push_front在list末尾和开头插入元素，使用成员函数insert在list中插入元素。 12345678910111213list&lt;int&gt; intList(3, 6);intList.push_front(5);intList.push_back(7);//在迭代器指向的位置添加一个元素intList.insert(intList.begin(), 4);//在迭代器指向的位置添加指定数量的某个元素intList.insert(intList.end(), 2, 8);//在迭代器指向的位置插入某个容器两个迭代器之间的元素list&lt;int&gt; anoList(2, 9);intList.insert(intList.end(), anoList.begin(), anoList.end()); 删除元素 使用list::erase()来删除list中的元素，他有两个重载版本，一个版本接受一个迭代器并删除迭代器指向的元素，另一个接受两个迭代器参数并删除指定范围内的所有元素。 元素反转和排序 使用list的成员方法reverse()和sort()对list进行反转和排序，执行者两个操作后之前指向元素的迭代器仍然有效。 1234567891011121314151617181920212223242526272829 list&lt;int&gt; intList; intList.push_back(7); intList.push_front(5); intList.push_back(6); auto int6 = --intList.end(); //6 list&lt;int&gt;::const_iterator int7 = ++intList.begin(); //7 //反转 intList.reverse(); //排序 intList.sort(); cout &lt;&lt; *int6 &lt;&lt; endl; //6 cout &lt;&lt; *int7 &lt;&lt; endl; //7 ``` &gt;其中排序方法sort()还有一个重载版本，接受一个二元谓词作为参数： ```c++ //从大到小排序 bool MySortStandard(const int&amp; lsh, const int&amp; rsh) &#123; return (lsh &gt; rsh); &#125; int main() &#123; ...... //排序 intList.sort(MySortStandard); ...... &#125; STL forward_list 从c++11起，可以使用单向链表forward_list;使用时需要包含头文件 &lt;forward_list&gt;使用forward时，只能使用push_front()函数在开头插入元素，其他操作与list很像。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://syfx.github.io/categories/编程语言/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://syfx.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://syfx.github.io/tags/STL/"}]},{"title":"STL-vector","slug":"STL-vector","date":"2019-03-15T01:47:32.000Z","updated":"2019-04-26T01:07:58.218Z","comments":true,"path":"2019/03/15/STL-vector/","link":"","permalink":"http://syfx.github.io/2019/03/15/STL-vector/","excerpt":"","text":"STL vector 使用vector时需要包含头文件&lt;vector> vector的特点vector动态数组类：1、无论数组中存在多少元素，在数组末尾添加新元素时所需时间都是固定的。2、在数组中间添加或者删除元素时，与该元素后面的元素个数成正比。3、储存的元素是动态的，vector类负责管理内存。 vector的初始化 下面的代码介绍了vector的几种初始化方法。 1234567891011121314//默认初始化vector&lt;int&gt; intVec;//初始化时设置至少包含的元素数（并没有限制大小），每个元素初始值默认为0vector&lt;int&gt; intVec1(10);//同上，并设置每个元素的初始化值vector&lt;int&gt; intVec2(10, 66);//使用另外一个vector来初始化vector&lt;int&gt; intVec3(intVec2);//使用另一个vector的两个迭代器来初始化vector&lt;int&gt; intVec4(intVec2.cbegin(), intVec2.cbegin() + 5); cbegin()和cend()是C++11新增的，它们返回一个const的迭代器，不能用于修改元素。 vector插入元素 使用成员函数push_back()在容器末尾插入元素；使用insert()在指定位置插入元素。 1234567891011121314vector&lt;int&gt; intVec(5);intVec.push_back(66);cout &lt;&lt; intVec.size() &lt;&lt; endl; //6//在指定位置插入元素intVec.insert(intVec.begin(), 67);//在指定位置插入指定个数的某个元素intVec.insert(intVec.begin(), 2, 66);//在指定位置插入另一个vector的内容(使用迭代器指定范围)vector&lt;int&gt; anoVec(3, 65);intVec.insert(intVec.begin(), anoVec.begin(), anoVec.end()); 使用insert插入元素时，效率较低，与其特点有关。 访问vector中的元素 使用下标用算符[]访问元素，超出容器边界时结果不确定。使用成员方法at()访问元素，超出容器边界时将会报错。使用迭代器访问元素。 12345678910111213141516171819vector&lt;int&gt; intVec;intVec.push_back(64);intVec.push_back(65);intVec.push_back(66);//使用 [] 访问元素for (size_t i = 0; i &lt; intVec.size(); ++i) &#123; cout &lt;&lt; intVec[i] &lt;&lt; endl;&#125;//使用 at() 访问元素for (size_t i = 0; i &lt; intVec.size(); ++i) &#123; cout &lt;&lt; intVec.at(i) &lt;&lt; endl;&#125;//使用迭代器访问元素for (vector&lt;int&gt;::const_iterator pos = intVec.begin() ; pos != intVec.end() ; ++pos)&#123; cout &lt;&lt; *pos &lt;&lt; endl;&#125; 删除vector中的元素 使用pop_back()从vector中删除元素所需要的时间是固定的。不能使用偏移位置和元素数删除指定个数的元素。 12345678910111213vector&lt;int&gt; intVec;intVec.push_back(64);intVec.push_back(65);intVec.push_back(66);//删除vector末尾的元素intVec.pop_back();//删除迭代器指向的元素intVec.erase(intVec.begin());//删除两个迭代器之间的元素intVec.erase(intVec.begin(), intVec.begin() + 2); 大小和容量的区别 可以通过成员函数size()和capacity()来获取vector的大小和容量。容量总是大于等于大小，当当前容量不足时，重新分配容量时，会分配比当前所需容量更大的容量（比如容量满时再插入数据时，可能会分配两个元素的容量，或者更多）。可使用成员函数reserve(number),设置当前容器的容量（如果传入的number小于size的话，默认使用size的值。） STL deque 发音：/dek/使用时要包含头文件 deque与vector极其相似，只是可以使用成员函数push_front()和pop_frone()在开头插入和删除元素。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://syfx.github.io/categories/编程语言/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://syfx.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://syfx.github.io/tags/STL/"}]},{"title":"STL-string","slug":"STL-string","date":"2019-03-13T07:09:44.000Z","updated":"2019-04-26T02:34:39.048Z","comments":true,"path":"2019/03/13/STL-string/","link":"","permalink":"http://syfx.github.io/2019/03/13/STL-string/","excerpt":"","text":"STL简介标准模板库是一组模板类和函数，向程序员提供了： 用于储存信息的容器 用于访问容器储存的信息的迭代器 用于操作容器内容的算法 其中，容器又包含： 顺序容器 std::vector——与动态数组类似，在最后插入数据。 std::deque——与std::vector类似，允许在开头添加或删除数据。 std::list——与双向链表类似。 std::forward_list——类似于std::list，不过是单向链表。 关联容器 std::set——储存各不相同的值，在插入时进行排序。（对数复杂度）std::unordered_set——c++11新增的，与set相同。（复杂度为常数） std::map——储存键值对，并根据唯一的键排序。（对数复杂度）std::unordered_map——c++11新增的，与map相同。（复杂度为对数） std::multiset——与set类似，但值不需要是唯一的。std::unordered_multiset——c++11新增的，与unordered_set类似。但值不需要是唯一的。 std::multimap——与map类似，不要求键是唯一的。std::unordered_multimap——c++11新增的，与unordered_map类似。不要求键是唯一的。 容器适配器 std::stack：以LIFO(后进先出)的方式储存元素。 std::queue：以FIFO(先进先出)的方式储存元素。 std::priority_queue：以特定顺序储存元素。 下文再介绍时，省略了std:: STL迭代器 指针是最简单的迭代器，让该指针指向数组中的第一个元素，然后递增指针以获得下一个元素。STL中的迭代器是模板类，在某种程度上，可以将它理解成泛型指针。 STL算法 为程序员提供的查找、排序、反转等功能的模板函数。使用STL算法时，要包含标准头文件 常用STL算法如下： std::find: 在集合中查找值。 std::find_if: 根据用户指定的谓词在集合中查找值。 std::reverse: 反转集合中的元素的排序。 std::remove_if: 根据用户定义的谓词将元素从集合中删除。 std::transform: 使用用户定义的变换函数对容器中的元素进行变换。 使用迭代器在容器和算法之间交互 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int main() &#123; vector&lt;int&gt; IntArray; IntArray.push_back(123); IntArray.push_back(1997); IntArray.push_back(917); IntArray.push_back(2019); IntArray.push_back(6666); //使用迭代器遍历容器元素 //for (vector&lt;int&gt;::iterator IA = IntArray.begin(); // IA &lt; IntArray.end(); ++IA) &#123; // cout &lt;&lt; *IA &lt;&lt; endl; //&#125; //使用迭代器遍历容器元素，此处所使用了auto让编译器自动判断类型 for (auto iArrayWalker = IntArray.begin(); iArrayWalker &lt; IntArray.end(); ++iArrayWalker)&#123; cout &lt;&lt; *iArrayWalker &lt;&lt; endl; &#125; //使用find算法在容器中查找元素1997，查到末尾时（end()）还没找到，便返回end()的地址 //vector&lt;int&gt;::iterator value = find(IntArray.begin(), IntArray.end(), 1997); auto value = find(IntArray.begin(), IntArray.end(), 1997); //判断是否找到元素1997 if (value != IntArray.end()) &#123; cout &lt;&lt; \"value: \" &lt;&lt; *value &lt;&lt; endl; //获取1997在容器中的位置，及到begin()的距离 int index = distance(IntArray.begin(), value); cout &lt;&lt; \"index: \" &lt;&lt; index &lt;&lt; endl; &#125; getchar(); return 0;&#125; 由上述代码可以看出，迭代器就是获得的是容器中元素的地址；因此，在某种程度上可以将它理解为泛型指针。 STL string类 std::stirng与std::wstring是STL库中一个帮助程序员用于字符串操作的容器类。使用时要包含头文件。以std::string为例来介绍这个类的用法。 实例化string 12345678910111213const char* C_StyleString = \"Hello String\";const char* cString = \"Hello String\";//使用构造函数初始化string str(cString);//使用等号初始化string str1 = cString;//使用string类型数据初始化string strCopy(cString);//使用某个字符串的前n位初始化string str2(\"Hello String\", 5);//使用指定数量的字符初始化string str3(6, 'a'); //str3 = aaaaaa//string str3(6, 'adf'); //str3 = ffffff 访问string的内容 1234567891011121314151617181920//通过[]访问元素for (int i = 0; i &lt; str.length(); ++i) &#123; cout &lt;&lt; str[i] &lt;&lt; endl;&#125;//通过迭代器访问for (string::const_iterator pos = str.begin() ; pos != str.end() ; ++pos)&#123; //*pos = 'h'; //报错，pos指向的值是const类型的，不可更改 cout &lt;&lt; *pos &lt;&lt; endl;&#125;//通过迭代器访问for (string::iterator pos = str.begin() ; pos != str.end() ; ++pos)&#123; *pos = '6'; //不报错 cout &lt;&lt; *pos &lt;&lt; endl;&#125; 上面代码中使用迭代器时，使用了一个新的迭代器const_iterator,使用它时，迭代器的值可变，但迭代器指向的值的值不可被改变。 字符串拼接 使用+=或者成员函数append()来拼接字符串。 123456string str4 = \"Hello \";string str5 = \"World \";string str6(\"Beautiful!\");str4 += str5; //str4 = Hello World str4.append(str6); //str4 = Hello World Beautiful! 字符/子字符串查找 可以使用string中的成员函数find来查找字符或者子字符串。查找成功返回字符的索引或子字符串首个字符的索引。查找失败返回string::npos（实际值为-1）。 12345678910string str6 = \"Hello World\";//从索引为0初的字符往后进行查找int index = str6.find(\"World\", 0); cout &lt;&lt; index &lt;&lt; endl; //6//查找str6中所有 l 的索引size_t charPos = str6.find('l', 0);while (charPos != string::npos) &#123; cout &lt;&lt; charPos &lt;&lt; endl; //2 3 9 charPos = str6.find('l', ++charPos);&#125; size_t在32位架构上是4字节，在64位架构上是8字节，在不同架构上进行编译时需要注意这个问题。而int在不同架构下都是4字节；且int为带符号数，size_t为无符号数。 字符串截短可以使用成员函数erase()来删除字符串中的字符。使用方法如下： 1string myStr = \"Life is always like this.\"; 在给定偏移位置（索引值）和指定数目时删除字符。 12//删除索引在 区间[14,19) 内的字符串myStr.erase(14,5); //Life is always this. 删除迭代器iChar指向的字符。 12auto iChar = find(myStr.begin(), myStr.end(), '.');myStr.erase(iChar); //Life is always like this 删除两个迭代器指定范围内的字符串。 1myStr.erase(++myStr.begin(), myStr.end()); //L 使用成员方法clear()时，经清楚全部内容并重置string对象。 字符串反转 使用泛型算法std::reverse()对字符串进行反转。(注意不是成员方法)reverse接收两个参数，起始迭代器、终止迭代器，然后将对两个迭代器之间的内容进行反转。 12string myStr = \"Life is always like this.\";reverse(++myStr.begin(), myStr.end()); //L.siht ekil syawla si efi 字符串大小写转换 使用算法std::transform()进行大小写转换。(注意不是成员方法)transform(first, last, r_first, trans)接收四个参数：开始迭代器、终止迭代器、开始迭代器、要执行的变换。要执行转大写操作时 trans = toupper, 要执行转小写操作时 trans = tolower。 12345string myStr = \"life is always like this.\";transform(++myStr.begin(), myStr.end(), ++myStr.begin(), toupper);//——&gt;lIFE IS ALWAYS LIKE THIS.transform(++myStr.begin(), myStr.end(), ++myStr.begin(), tolower);//——&gt;life is always like this. 如果要编写的应用程序需要更好的支持非拉丁字符，如中文与日文时，应使用std::wstring。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://syfx.github.io/categories/编程语言/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://syfx.github.io/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://syfx.github.io/tags/STL/"}]},{"title":"c++模板","slug":"c-模板","date":"2019-03-13T06:50:32.000Z","updated":"2019-04-26T02:35:39.391Z","comments":true,"path":"2019/03/13/c-模板/","link":"","permalink":"http://syfx.github.io/2019/03/13/c-模板/","excerpt":"","text":"模板可能是c++中最强大最强大却最少被使用（或被理解）的特性之一了；我们可以用模板来定义一种适用于不同类型的对象的行为这就像是用#define定义的一个返回两个数中最大值的宏函数那样#define MAX_NUM(a, b) ((a) &gt; (b) ? (a) : (b))这里的a，b可以是int类型、也可以是其他类型；与“”宏函数不同的是宏不是类型安全的，而模板是类型安全的 模板函数/类声明语法 12template &lt;参数列表&gt; 模板函数/类的声明 参数列表中包含关键字typename，它定义了参数objectTyep，objectType是一个占位符，当对象实例化模板时（创建类实例时）将使用指定的对象类型替换它： 123456789101112131415161718192021222324252627282930313233//模板函数 template &lt;typename T&gt; const T&amp; GetMax(const T&amp; num1, const T&amp; num2) &#123; if(num1 &lt; num2) return num2; return num1; &#125; //模板类 template &lt;typename T1, typename T2&gt; class Template &#123; private: T1 m_Obj1; T2 m_Obj2; public: Template(T1 obj1, T2 obj2): m_Obj1(obj1), m_Obj2(obj2)&#123; &#125; void print()&#123; cout &lt;&lt; m_Obj1 &lt;&lt; \" \" &lt;&lt; m_Obj2 &lt;&lt; endl; &#125; &#125;; int main() &#123; Template&lt;int, float&gt; tem(66, 66.6); tem.print(); cout &lt;&lt; GetMax&lt;float&gt;(25.5, 123) &lt;&lt; endl; cout &lt;&lt; GetMax(25.5, 123.0) return 0; &#125; 上述代码中实例化Template类时，将T1指定为int类型，将T2指定为float类型（显式指定）。第一次调用模板函数时，将T指定为float类型；第二次调用时却没有指定类型，但这样也是正确的，这时候，模板函数会自动判断数据的类型（隐式指定）。不过，对于模板类，必须要显式指定其类型。 声明包含多个参数的模板声明包含多个参数的模板时, 参数之间用逗号隔开：template &lt; typename T1, typename T2,...., typename Tn &gt; 声明包含默认参数的模板声明包含默认参数的模板时, 可将它初始化成默认类型：template &lt; typename T1 = int, ... , typename tn = int &gt; *模板类和静态成员在普通的类中，类成员被定义成静态的话，该静态成员被所有实例共享；在模板类中，也类似这样，只不过是被同类型的具体化的实例所共享的： 123456789101112131415161718192021222324252627282930template &lt;typename T&gt;class Template&#123;private: T m_Obj1; static int T_Num; public: static int getT_Num() &#123; return T_Num; &#125; static void setT_Num(const int&amp; num) &#123; T_Num = num; &#125;&#125;;//静态成员变量的初始化template &lt;typename T&gt;int Template&lt;T&gt;::T_Num = 0; int main()&#123; Template&lt;int&gt;::setT_Num(1997); Template&lt;float&gt;::setT_Num(917); cout &lt;&lt; Template&lt;int&gt;::getT_Num() &lt;&lt; endl; //1997 cout &lt;&lt; Template&lt;float&gt;::getT_Num() &lt;&lt; endl; //917 return 0; &#125; 上述代码中两次输出结果分别是1997、917。你该懂了吧c++中的静态成员变量在c++的类中，如果存在静态成员变量的话，必须对它进行初始化,格式如下：&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt; = &lt;值&gt; 模板类中的静态成员变量的初始化格式：（参考上述代码的初始化）template&lt;参数&gt; &lt;数据类型&gt;&lt;类名&lt;参数&gt;&gt;::&lt;静态数据成员名&gt; = &lt;值&gt; c++11使用static_assert执行编译阶段的检查（类似assert宏）static_assert是c++11中新加的功能（有的编译器不支持），它是一种编译断言，能够在不满足条件时禁止编译。使用格式：static _assert(表达式, &quot;表达式为假时输出的错误信息&quot;) 12345678910111213template &lt;typename T&gt;class CanNotInt&#123;public: CanNotInt()&#123; static_assert(sizeof(T) != sizeof(int), \"No int please\"); &#125;&#125;;int main()&#123; CanNotInt&lt;int&gt; test; return 0;&#125; 上述代码编译时会报错。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://syfx.github.io/categories/编程语言/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://syfx.github.io/tags/C/"}]},{"title":"c++宏","slug":"c-宏","date":"2019-03-13T06:50:12.000Z","updated":"2019-09-03T14:17:09.552Z","comments":true,"path":"2019/03/13/c-宏/","link":"","permalink":"http://syfx.github.io/2019/03/13/c-宏/","excerpt":"","text":"前言C++主要有三个编译阶段：预处理、转译成目的码和链接（最后的两个阶段一般才视为真正的“编译”）。 预处理器 预处理器：在编译之前运行的工具,会根据预编译指令对源代码进行“加工”，实际编译的源码是经过预处理器处理过的。预处理器编译指令是向预处理器发出的命令，总是以符号#开头。根据程序员的指示，决定编译器实际要编译的文本内容。比如：对于一个宏#define PI 3.1415，在编译之前，预处理器会在代码中找到 PI 并将它替换为 3.1415 。 使用#define定义常量 语法： #define identifer(标识符) value(值)栗子： #define PI 3.1415 #define NICKNAME \"f_x\" #define THIS_IS_DOUBLE double #define THIS_IS_FOR for 预处理器对宏指定的文本进行简单的替换，因此可以用宏来编写简单的函数栗子： #define PI 3.1415 #define AREA_CIRCLE(r) ( PI * (r) * (r)) 为什么要使用这么多括号？ 对于上面的宏AREA_CIRCLE,若在代码中这样使用cout &lt;&lt; AREA_CIRCLE(4+6);使用括号时，经预处理器处理后：cout &lt;&lt; (3.1415 * (4 + 6) * (4 + 6))不使用括号时：cout &lt;&lt; 3.1415 * 4 + 6 * 4 + 6你懂。。 宏的其他作用 避免头文件的多次包含假设有两个头文件class1.h,class2.h,当我们不得不让两个类相互包含时，对预处理器来说，这样会造成递归问题；为了避免这种问题，可以使用宏和预处理器编译指令#ifndef（if-not-define）和endif。 #ifndef HEADER2_H_H //如果宏HEADER2_H_H未定义 #define HEADER2_H_H //定义宏HEADER2_H_H #include &lt;class2.h&gt; class class1 { ...... }; #endif #ifndef HEADER1_H_H //如果宏HEADER1_H_H未定义 #define HEADER1_H_H //定义宏HEADER1_H_H #include &lt;class1.h&gt; class class2 { ...... }; #endif 预处理器进行死板的文本替换，这可以减轻程序员的负担，当并不是能减轻编译器的负担。其次，对于宏PI，我们没有太大的控制权，其类型是double还是float？答案是都不是。在预处理器看来，PI就是3.1415，根本不知道其数据类型。所以定义常量时 const 是更好的选择const double PI = 3.14215;define与const的区别 起作用的阶段不同：#define在预处理阶段起作用； const在编译或者运行阶段起作用； 起作用的方式不同：#define进行简单的文本替换，不能进行类型检查；const定义的常量有对应的数据类型； 储存方式不同：#define定义的宏常量在内存中有多个备份，而const定义的常量在内存中只有一个备份； const常量可用于调试，而#define定义的常量不能用于调试（预处理阶段被替换掉了）；","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://syfx.github.io/categories/编程语言/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://syfx.github.io/tags/C/"}]},{"title":"算法时间复杂度的计算","slug":"算法时间复杂度的计算","date":"2018-11-27T02:06:27.000Z","updated":"2019-06-05T01:21:00.699Z","comments":true,"path":"2018/11/27/算法时间复杂度的计算/","link":"","permalink":"http://syfx.github.io/2018/11/27/算法时间复杂度的计算/","excerpt":"","text":"一般用大写O()来表示算法的时间复杂度写法，通常叫做大O记法。一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。 大O推导法：用常数1取代运行时间中的所有加法常数在修改后的运行函数中，只保留最高阶项如果最高阶项存在且不是1，则去除与这个项相乘的常数 示例： 12345678910111213n++; /*执行次数为1*/function(n); /*执行次数为n*/int i,j;for(i = 0 ; i &lt; n ; i++)&#123; /*执行次数为nXn*/ for(j = 0; j &lt; n; j++)&#123; function(i); &#125;&#125;for(i = 0 ; i &lt; n ; i++)&#123; /*执行次数为n(n+1)/2*/ for(j = i ; j &lt; n ; j++)&#123; /*时间复杂度为O(1)的程序*/ &#125; &#125; 它的执行次数f(n) = 1 + n + n^2 + n(n+1)/2,根据推导大O阶的方法，最终它的时间复杂度为：O(n^2) 时间复杂度所耗费的时间是：O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n2) &lt; O(n3) &lt;O(2n) &lt; O(n!) &lt;O(nn)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://syfx.github.io/categories/数据结构与算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://syfx.github.io/tags/算法/"}]},{"title":"计算机操作系统学习笔记","slug":"operating-system","date":"2018-11-08T00:43:04.000Z","updated":"2019-05-22T02:37:11.598Z","comments":true,"path":"2018/11/08/operating-system/","link":"","permalink":"http://syfx.github.io/2018/11/08/operating-system/","excerpt":"","text":"简介可以把操作系统比作是电脑上的“政府”，主要的只能是与硬件交互，管理资源。好的操作系统应有的特点：公平（资源分配上），高效，稳定，安全，方便。主要分类有：单处理器系统，所处理器系统，集群系统；嵌入式系统，多媒体系统；单任务系统，多任务系统…… 常见操作系统 windows:Windows系列操作系统是微软公司在二十世纪九十年代研制成功的图形化工作界面操作系统，俗称“视窗”。优点： 易用性高，生态圈完善，兼容性高； 硬件丰富； 游戏娱乐性强； 图形化界面较为完善；缺点： 安全性低； 系统漏洞较多；（因为是闭源的，参与测试的人少） 稳定性差；（蓝屏） Unix基础的操作系统，包含两个主要的部分：核心名为Darwin，是以FreeBSD源代码和Mach微核心为基础，由苹果公司和独立开发者社区协力开发；优点： 安全性高； mac下没有很多win下多余的东西，没有磁盘碎片，不用整理硬盘，不用分区，几乎没有死机，不用关机，基本没用过进程管理器。所有和使用无关的东西，都被藏起来，用户很容易学习和使用； 设置简单； 稳定性高，BUG较少；缺点： 兼容性差；（较windows而言，其实也不差） Linux: Linux是一套免费使用和自由传播的类Unix操作系统，是一个多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。优点： 安全、易维护、稳定； 软件自由、开源； 低成本、低配置要求；缺点： 应用软件较少； 图形界面不够好； UNIX: UNIX是一个强大的多用户、多任务操作系统，支持多处理器架构、属于分时操作系统。优点： 开源； 将所有设备用文件标识，可使用与处理文件相同的命令和系统调用集访问设备。 具有可移植行。缺点： UNIX系统的标准I/O库相对其底层的系统调用接口已变得越来越复杂了。 传统的UNIX内核不够灵活，不具备很好的可扩充性。大部分代码也很难复用。 Android：Android是一种以Linux为基础的开放源代码的操作系统，主要用于便携式设备。优点： 开放性强、具有丰富的硬件选择。缺点： 对硬件要求较高。 安全性较低。 iOS: iOS与苹果的Mac OS X操作系统一样，属于类Unix的商业操作系统。优点： 流畅的操作体验、丰富的应用程序、精美的系统界面、较高的安全性。缺点： 系统封闭，权限控制严格，用户受限制多。 FreeBSD：FreeBSD是一种类UNIX操作系统，是由经过BSD、386BSD和4.4BSD发展而来的Unix的一个重要分支。FreeBSD 提供先进的网络、性能、安全以及兼容性，这些特性在其他现代操作系统上仍有所缺失，即使是一些最好的商业操作系统。优点： 强大的网络性能； 先进的嵌入式平台； 可以运行大量的程序； 易于安装及使用； 开源 VxWork：VxWorks操作系统是美国WindRiver公司于1983年设计开发的一种嵌入式实时操作系统(RTOS)，是嵌入式开发环境的关键组成部分。它以其良好的可靠性和卓越的实时性被广泛地应用在通信、军事、航空、航天等高精尖技术及实时性要求极高的领域中，如卫星通讯、军事演习、弹道制导、飞机导航等。优点： 稳定、可靠性； 实时性； 可裁剪行；","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://syfx.github.io/tags/操作系统/"}]}]}