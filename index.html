<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="fx"><meta name="copyright" content="fx"><title>懂得越多，为难得越少 | fx's study notes</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">fx</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">21</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">fx's study notes</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">fx's study notes</div><div id="site-sub-title">懂得越多，为难得越少</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/21/c-多线程/">c#多线程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-21</time><div class="content"></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/21/c-委托与事件/">c#委托与事件</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-21</time><div class="content"></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/21/c-属性与索引器/">c#属性与索引器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-21</time><div class="content"></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/21/C-特性与反射/">C#特性与反射</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-21</time><div class="content"></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/19/NET与c/">.NET与c#</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-19</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/NET/">.NET</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/c/">c#</a></span><div class="content"><h3 id="一、什么是-NET"><a href="#一、什么是-NET" class="headerlink" title="一、什么是.NET"></a>一、什么是.NET</h3><p>.NET是一个微软搭造的开发者平台，它主要包括：   </p>
<ol>
<li>支持(面向)该平台的编程语言(如C#、Visual Basic、C++/CLI、F#、IronPython、IronRuby…)   </li>
<li>用于该平台下开发人员的技术框架体系(<strong>即 .NET实现</strong>)   </li>
<li>用于支持开发人员开发的软件工具(即SDK，如VS2017、VS Code等)   </li>
</ol>
<blockquote>
<ul>
<li>.NET实现<br>Microsoft 积极开发和维护的主要 .NET实现 有4个：.NET Framework、.NET Core、Mono 和 UWP。<br>每个 .NET实现 都具有以下组件：<ol>
<li>一个或多个运行时。    <ul>
<li>.NET运行时<br>  运行时是用于托管程序的执行环境。 操作系统属于运行时环境，但不属于 .NET 运行时。 下面是 .NET 运行时的一些示例：<ul>
<li>.NET Framework 公共语言运行时 (CLR)</li>
<li>.NET Core 核心公共语言运行时 (CoreCLR)</li>
<li>适用于通用 Windows 平台的 .NET Native</li>
<li>用于 Xamarin.iOS、Xamarin.Android、Xamarin.Mac 和 Mono 桌面框架的 Mono 运行时</li>
</ul>
</li>
</ul>
</li>
<li>实现 .NET Standard 并且可实现其他 API 的类库。 示例：.NET Framework 基类库、.NET Core 基类库。  <ul>
<li>.NET Standard<br>  .NET Standard 是一组由 .NET 实现的基类库实现的 API。 更正式地说，它是构成协定统一集（这些协定是编写代码的依据）的特定 .NET API 组。 这些协定在每个 .NET实现 中实现。 这可实现不同 .NET实现 间的可移植性，有效地使代码可在任何位置运行。  </li>
</ul>
</li>
<li>可选择包含一个或多个应用程序框架。 示例：ASP.NET、Windows 窗体…(包含在 .NET Framework 中)</li>
<li>可包含开发工具。 某些开发工具在多个实现之间共享。   </li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="NET架构结构"><a href="#NET架构结构" class="headerlink" title=".NET架构结构"></a>.NET架构结构</h4><p><img src="http://p.qpic.cn/pic_wework/1948211503/e9efe5f95612423a370ff2bd921d91a831e60fed1ac22fa4/0" alt=""></p>
<h4 id="1、CTS-通用类型系统-Common-Type-System"><a href="#1、CTS-通用类型系统-Common-Type-System" class="headerlink" title="1、CTS-通用类型系统(Common Type System)"></a>1、CTS-通用类型系统(Common Type System)</h4><blockquote>
<p>.NET实现对语言不可知。 <strong>这意味着程序员可以使用可编译为 IL 的任意语言进行编写代码。而且这些通过不同语言进行编写的代码进行交互(即跨语言操作)</strong>。   </p>
<blockquote>
<p>跨语言操作：比如，c#和vb是.NET下两个不同的语言，不过在c#中写的类可以在vb中当做自家写的类一样正常使用。   </p>
</blockquote>
<p>为透明地执行此操作，必须使用某种通用方式描所有受支持类型。 这正是 CTS 的职责。 其功能如下：      </p>
<ul>
<li>建立用于跨语言执行的框架。   </li>
<li>提供面向对象的模型，支持在 .NET 实现上实现各种语言。   </li>
<li>定义处理类型时所有语言都必须遵守的一组规则。   </li>
<li>提供包含应用程序开发中使用的基本基元数据类型（如 Boolean、Byte、Char 等）的库。  </li>
</ul>
</blockquote>
<h4 id="2、CLS-公共语言规范-Common-Language-Specification"><a href="#2、CLS-公共语言规范-Common-Language-Specification" class="headerlink" title="2、CLS-公共语言规范(Common Language Specification)"></a>2、CLS-公共语言规范(Common Language Specification)</h4><blockquote>
<p>为实现完全互操作性情景，代码中创建的所有对象都必须依赖于使用它的语言（即其调用方）的某些共性。 由于存在多种不同语言，因此 .NET 在公共语言规范 (CLS) 中指定了这些共性。然后定义了一组规则，开发者都遵守这个规则来编码，那么代码就能被任意.NET平台支持的语言所通用。<br>而与其说是规则，不如说它是一组语言互操作的标准规范，这就是CLS。</p>
<blockquote>
<p>注意：<strong>CLS 遵从性的规则仅适用于组件的公共接口，而非其私有实现。</strong></p>
</blockquote>
</blockquote>
<h4 id="3、CLR-公共语言运行-时-或库-Common-Language-Runtime"><a href="#3、CLR-公共语言运行-时-或库-Common-Language-Runtime" class="headerlink" title="3、CLR-公共语言运行 时(或库)(Common Language Runtime)"></a>3、CLR-公共语言运行 时(或库)(Common Language Runtime)</h4><blockquote>
<p>这里指的是 .NET Framework 的运行时。<br>可以将CLR看成一个在 执行时 <strong>管理代码</strong> 的代理（<strong>托管代码</strong>），它提供核心服务（如内存管理（GC）、线程管理和远程处理），而且还强制实施严格的类型安全以及可确保安全性和可靠性的其他形式的代码准确性。事实上，代码管理的概念是 运行时 的基本原则。</p>
<blockquote>
<p>托管：以垃圾回收器（GC）为例，在c#中，内存分配和释放的工作本应该是我们做的，现在这些工作却让GC帮你做了，这就是“托管”的概念。<br>因此，C#被称为托管语言。C#编写的代码也就称为托管代码,C#生成的模块称为托管模块等。<br>从这个角度来看，那些脱离了.NET提供的诸如垃圾回收器这样的环境管制，就是对应的 非托管了。</p>
</blockquote>
<p>CLR管理内存、线程执行、代码执行、代码安全验证、编译以及其他系统服务。这些功能是在CLR上运行的托管代码所固有的。这套环境及体系之完善，以至于就像一个小型的系统一样，所以通常形象的称CLR为”.NET虚拟机”。</p>
</blockquote>
<h4 id="NET程序的编译执行"><a href="#NET程序的编译执行" class="headerlink" title=".NET程序的编译执行"></a>.NET程序的编译执行</h4><blockquote>
<ul>
<li>对于用非托管语言(c/c++)编写的程序源代码，编译时翻译器将源码翻译为本地 机器语言，以文件形式保存在硬盘上；运行时，操作系统将文件读出到内存，然后CPU从内存中取出指令执行。    </li>
<li>对于托管代码，编译时将源码翻译为微软中间语言（IL）代码，运行的时候通过JIT（即时编译器）翻译为本地机器语言，同时.NET代码运行时有一个CLR环境来管理程序。   <blockquote>
<p>翻译器与解释器：   </p>
<ul>
<li>在编译时<strong>翻译器</strong>将源代码翻译成机器语言保存到文件中（例如C/C++）；执行效率高，不过难以移植。   </li>
<li>在运行时<strong>解释器</strong>对源代码逐行进行翻译和执行（例如Python）；执行效率较低，不过易于移植。   </li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p><img src="http://p.qpic.cn/pic_wework/1948211503/01070d1133a261b41edd9346720be2c008e98d1b93db163c/0" alt="">   </p>
<h3 id="二、C-简介"><a href="#二、C-简介" class="headerlink" title="二、C#简介"></a>二、C#简介</h3><h4 id="1、-C-及其特点"><a href="#1、-C-及其特点" class="headerlink" title="1、 C#及其特点"></a>1、 C#及其特点</h4><blockquote>
<p>C#是微软公司在2000年7月发布的一种全新且<strong>简单、安全、面向对象</strong>的程序设计语言，是专门为.NET的应用而开发的语言。它吸收了C++、Visual Basic、Delphi、Java等语言的优点，体现了当今最新的程序设计技术的功能和精华。C#继承了C语言的语法风格，同时又继承了C++的面向对象特性。不同的是，C#的对象模型已经面向Internet进行了重新设计，使用的是.NET框架的类库；<strong>C#不再提供对指针类型的支持，使得程序不能随便访问内存地址空间，从而更加健壮；C#不再支持 多重继承，避免了以往类层次结构中由于多重继承带来的可怕后果</strong>。.NET框架为C#提供了一个强大的、易用的、逻辑结构一致的程序设计环境。同时，公共语言运行时（Common Language Runtime）为C#程序语言提供了一个托管的运行时环境，使程序比以往更加稳定、安全。<br>总结一下，c#特点有：    </p>
<ul>
<li>语言简洁。   </li>
<li>保留了C++的强大功能。   </li>
<li>快速应用开发功能。   </li>
<li>语言的自由性。   </li>
<li>强大的Web服务器控件。   </li>
<li>支持跨平台。   </li>
<li>与XML相融合。   </li>
</ul>
</blockquote>
<h4 id="2、-c-存在哪些缺点呢？"><a href="#2、-c-存在哪些缺点呢？" class="headerlink" title="2、 c#存在哪些缺点呢？"></a>2、 c#存在哪些缺点呢？</h4><blockquote>
<ul>
<li>不适合开发高性能的程序：因为中间语言和编译过程，比C/C++等语言会慢一些，还有就是内存自动回收机制导致难以立即释放不需要的内存，不采用(不建议)内联函数和析构函数。   </li>
<li>Windows平台以外支持有限： 因为除Windows外，还没有其他操作系统上的稳定版本的.Net Framework环境，提供给.Net 程序来运行。</li>
</ul>
</blockquote>
<h4 id="3、-c-与其它语言的比较"><a href="#3、-c-与其它语言的比较" class="headerlink" title="3、 c#与其它语言的比较"></a>3、 c#与其它语言的比较</h4><blockquote>
<ul>
<li>C#与C++的比较      <ul>
<li>编译目标：C++代码直接编译为本地可执行代码，而C#默认编译为中\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\间语言（IL）代码，执行时再通过Just-In-Time将需要的模块临时编译成本地代码。   </li>
<li>内存管理：C++需要显式地删除动态分配给堆的内存，而C#不需要这么做，C#采用垃圾回收机制自动在合适的时机回收不再使用的内存。   </li>
<li>指针：C++中大量地使用指针，而C#使用对类实例的引用，如果确实想在C#中使用指针，必须声明该内容是非安全的。不过，一般情况下C#中没有必要使用指针。   </li>
<li>字符串处理：在C#中，字符串是作为一种基本数据类型来对待的，因此比C++中对字符串的处理要简单得多。   </li>
<li>库：C++依赖于以继承和模板为基础的标准库，C#则依赖于.NET基库。</li>
<li>C++允许类的多继承，而C#只允许类的单继承，而通过接口实现多继承。</li>
</ul>
</li>
<li>C#与Java的比较<ul>
<li>C#面向对象的程度比Java高。   </li>
<li>C#中的基本类型都是面向对象的。   </li>
<li>C#具有比Java更强大的功能。   </li>
<li>C#语言的执行速度比Java快。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="4、值类型与引用类型，装箱与拆箱"><a href="#4、值类型与引用类型，装箱与拆箱" class="headerlink" title="4、值类型与引用类型，装箱与拆箱"></a>4、值类型与引用类型，装箱与拆箱</h4><blockquote>
<ul>
<li>在c#中，<strong>值类型</strong>的变量直接储存数据，数据存在栈中，执行复制操作时，复制了一个新的数据给另一个变量，两个数据相互独立；而<strong>引用类型</strong>持有的是数据的引用，在栈上开辟一小块内存储存一个地址，地址指向堆中实际储存数据的内存（相当于c++中的指针，只是c#做了一些工作使这个指针与它指向的对象更紧密的联系在一起了）。   </li>
<li>数据从值类型转换为引用类型的过程被称为<strong>“装箱”</strong>，从引用类型转换为值类型的过程被称为<strong>“拆箱”</strong>。装箱与拆箱操作比较费时，应该尽量避免装箱拆箱操作。</li>
</ul>
</blockquote>
<p><strong>值类型与引用类型的分类</strong><br><img src="http://p.qpic.cn/pic_wework/1948211503/fafcf6eaab4a7774885510cc4dd684254710f43750315fcb/0" alt=""></p>
<p>.NET中六个重要的概念：栈、堆、值类型、引用类型、装箱和拆箱：<br><a href="https://www.cnblogs.com/edisonchou/p/3947170.html" target="_blank" rel="noopener">https://www.cnblogs.com/edisonchou/p/3947170.html</a>   </p>
<p>什么是.NET：<br><a href="https://www.cnblogs.com/1996V/p/9037603.html#net3" target="_blank" rel="noopener">https://www.cnblogs.com/1996V/p/9037603.html#net3</a></p>
<p><strong>注：</strong>图片来自网上</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/17/最短路径算法Floyd与Dijkstra/">最短路径算法Floyd与Dijkstra</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-17</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/算法/">算法</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/最短路径/">最短路径</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/图/">图</a></span><div class="content"><h3 id="一、弗洛伊德算法（Floyd）"><a href="#一、弗洛伊德算法（Floyd）" class="headerlink" title="一、弗洛伊德算法（Floyd）"></a>一、弗洛伊德算法（Floyd）</h3><blockquote>
<p>Floyd算法的思想比较简单，它的核心代码只有5行；</p>
</blockquote>
<pre><code>for (int k = 0; k &lt; G.vCount; ++k)
    for (int i = 0; i &lt; G.vCount; ++i)
        for (int j = 0; j &lt; G.vCount; ++j)
            if (G.arcs[i][j] &gt; G.arcs[i][k] + G.arcs[k][j])
                G.arcs[i][j] = G.arcs[i][k] + G.arcs[k][j];
</code></pre><p> 对于一个有向图G：<br> <img src="http://p.qpic.cn/pic_wework/1948211503/c8cec3d80ab6b3b9e5d697e65a4cfbf9f23b6b3a2a6272f0/0" alt=""></p>
<blockquote>
<p>我们可以认为当前二维数组中的值表示的是两个顶点之间的直接路径长度（即中间不经过其它顶点进行中转时的路径）。这个直接路径并不一定是最短路径。<br>例如：G[1][3] = 6表示从1到3的直接路径长度为6，当我们引入2号顶点作为中转点时，（即先从顶点1走到顶点2，再从顶点2走到顶点3），从顶点1到3的路径长度可以更短，为G[1][2] + G[2][3] = 5;</p>
</blockquote>
<p><strong>上述思想的代码实现非常简单：</strong></p>
<pre><code>void Floyd(Graph G)
{
    for (int k = 0; k &lt; G.vCount; ++k) {
        for (int i = 0; i &lt; G.vCount; ++i) {
            for (int j = 0; j &lt; G.vCount; ++j) {
                if (G.arcs[i][j] &gt; G.arcs[i][k] + G.arcs[k][j])
                    G.arcs[i][j] = G.arcs[i][k] + G.arcs[k][j];
            }
        }
    }
    cout &lt;&lt; &quot;任意两点间的最短距离为：&quot; &lt;&lt; endl;
    //打印最终结果
    ShowGraph(G);
}
</code></pre><blockquote>
<p>这段代码中，最外层的循环用来控制当前允许经过哪个点进行中转。内层的两个循环表示<strong>当经过此中转点时一个顶点到其他所有顶点的距离是否能更短</strong>，若能更短，则更新最短距离。用一句话概括就是：<strong>从i号顶点到j号顶点只经过前k号顶点的最短路径</strong>(比如当要经过k-1顶点进行中转时，图中的储存的路径已经是经过前k-1号顶点时的最短路径了)，这其实是一种“动态规划”的思想（可以根据 <strong>斐波那契数列</strong> 想象一下这个思想）。</p>
</blockquote>
<p>由代码不难看出，Floyd算法的时间复杂度为O(n^3),因为要储存两两顶点间的最短路径，所以空间复杂度为O(n^2)（我在这里没有使用辅助空间，直接在原图中进行操作了）。</p>
<h3 id="二、迪杰斯特拉算法（Dijkstra）"><a href="#二、迪杰斯特拉算法（Dijkstra）" class="headerlink" title="二、迪杰斯特拉算法（Dijkstra）"></a>二、迪杰斯特拉算法（Dijkstra）</h3><blockquote>
<p>Dijkstra算法是一种“单源最短路径算法”（求一个顶点(源点)到其余各个顶点的最短路径），它是一种采用<strong>贪婪策略</strong>（在对问题求解时，总是做出在当前看来是最好的选择）实现的算法。 </p>
</blockquote>
<p> 对于有向图G：<br><img src="http://p.qpic.cn/pic_wework/1948211503/c8cec3d80ab6b3b9e5d697e65a4cfbf9f23b6b3a2a6272f0/0" alt=""></p>
<blockquote>
<p>在算法中，我们声明一个dis数组用来储存源点到其余顶点的的最短路径的“预估值”。以0号顶点为源点，有：    </p>
</blockquote>
<p><img src="http://p.qpic.cn/pic_wework/1948211503/d4d2dfc447ed7b3a3f9b73c399bc945848a023b66c121091/0" alt=""></p>
<blockquote>
<p>在dis表中选择到源点“预估值”最小的顶点（不包括源点本身），为dis[1] = 2;选择1号顶点后，dis[1]的值就可以从“预估值”变成“确定值”了；为什么呢？因为目前到源点最近的顶点为1号顶点，且图中边的权重都是正数（此算法不适用于带负权图），因此，不可能找到一个中转点使得从源点到1号顶点的路径更短。<br>这样的话，我们就还需要使用一个数组book来标记源点到当前点的最短路径是否为确定值（一般使用两个列表来分别储存“预估值”与“确定值”）。     </p>
</blockquote>
<p><img src="http://p.qpic.cn/pic_wework/1948211503/b4b2bfa455b687c5b64bc652096a40a12dab663aab792e89/0" alt=""></p>
<blockquote>
<p>确定源点到1号顶点的最短路径之后，我们对1号顶点的所有出边进行松弛：对于1号顶点，有一条出边1-&gt;2，我们讨论当通过1号顶点进行中转时，源点到2号顶点的路径是否能更短，即比较dis[2]与dis[1] + G[1][2]的大小，如果更短，则更新dis[2]的值。这一过程称为边的松弛。<br>对1号顶点的所有出边松弛完毕后，继续在“预估值”中选取最小的值执行边松弛操作，直到所有“预估值”变为“确定值”。</p>
</blockquote>
<p><strong>代码实现如下：</strong></p>
<pre><code>void Dijkstra(Graph G, int origin)
{
    //dis：储存源点到其它点的最短距离，book：用来做标记，标记到当前点到源点的最短距离是否已被确定
    int *dis = new int[G.vCount], *book = new int[G.vCount];
    int i = 0, j = 0, k = 0, s = 0, min = MaxInt;
    for (i = 0; i &lt; G.vCount; ++i) {
        //GetSub(G,origin)：获取源点在顶点表中的下标
        s = GetSub(G, origin);
        dis[i] = G.arcs[s][i];
    }
    //初始化标记
    for (i = 0; i &lt; G.vCount; ++i) {
        book[i] = 0;
    }
    //设置源点到源点的最短距离为已确定
    book[s] = 1;
    //确定源点到dis表里的所有顶点的最短距离，算法核心
    for (i = 1; i &lt; G.vCount; ++i) {
        min = MaxInt;
        //在未确定到源点最短距离的顶点中找到离源点最近的顶点
        for (j = 1; j &lt; G.vCount; ++j) {
            if (book[j] == 0 &amp;&amp; dis[j] &lt; min) {
                min = dis[j];
                s = j;
            }
        }
        //设置s点到源点的最短距离为已知
        book[s] = 1;
        //对当前顶点的出边进行松弛
        for (k = 0; k &lt; G.vCount; ++k) {
            //判断下标为s的顶点到下标为k的顶点间是否存在边，若存在，对其进行松弛操作
            if (G.arcs[s][k] &lt; MaxInt) {
                if (dis[k] &gt; dis[s] + G.arcs[s][k]) {
                    dis[k] = dis[s] + G.arcs[s][k];
                }
            }
        }
    }
    //打印最短路径
    for (i = 0; i &lt; G.vCount; ++i) {
        cout &lt;&lt; &quot;点&quot; &lt;&lt; origin &lt;&lt; &quot;到&quot; &lt;&lt; G.vexs[i] &lt;&lt; &quot;的最短距离为：&quot; &lt;&lt; dis[i] &lt;&lt; endl;
    }

}
</code></pre><blockquote>
<p>Dijkstra算法的时间复杂度为O(n^2)，在对算法的优化方面，可以使用最小堆在来实现查找最小“预估值”操作，若数据较多，且图为稀疏图时，通过邻接表来储存边，也能在一定程度上优化此算法的性能。</p>
</blockquote>
<p><strong>完整代码：</strong></p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

const int Num = 50;
const int MaxInt = 32767;
struct Graph {
    int vexs[Num];                        //顶点表
    int arcs[Num][Num];            //边表
    int vCount;                            //顶点数量
    int aCount;                            //边数量
};

//获取值在顶点表中下标
int GetSub(Graph G, int value)
{
    int i;
    for (i = 0; i &lt; G.vCount; ++i) {
        if (G.vexs[i] == value)
            break;
    }
    return i;
}
//创建图（邻接矩阵）
void CreatMap(Graph &amp;G)
{
    int t1, t2, w;
    //输入顶点信息
    for (int i = 0; i &lt; G.vCount; ++i) {
        cin &gt;&gt; G.vexs[i];
    }
    for (int i = 0; i &lt; G.vCount; ++i)
        for (int j = 0; j &lt; G.vCount; ++j) {
            G.arcs[i][j] = MaxInt;
            if (i == j)
                G.arcs[i][j] = 0;
        }

    for (int i = 0; i &lt; G.aCount; ++i) {
        cin &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; w;
        int s1 = GetSub(G, t1);
        int s2 = GetSub(G, t2);
        if (s1 != G.vCount &amp;&amp; s2 != G.vCount) {
            G.arcs[s1][s2] = w;
            //G.arcs[s2][s1] = w;            //无向图        
        }    
    }
}
//打印图
void ShowGraph(Graph G) 
{
    for (int i = 0; i &lt; G.vCount; ++i) {
        for (int j = 0; j &lt; G.vCount; ++j) {
            cout &lt;&lt; G.arcs[i][j] &lt;&lt; &quot;\t&quot;;
        }
        cout &lt;&lt; endl;
    }
}

//弗洛伊德算法
void Floyd(Graph G)
{
    for (int k = 0; k &lt; G.vCount; ++k) {
        for (int i = 0; i &lt; G.vCount; ++i) {
            for (int j = 0; j &lt; G.vCount; ++j) {
                if (G.arcs[i][j] &gt; G.arcs[i][k] + G.arcs[k][j])
                    G.arcs[i][j] = G.arcs[i][k] + G.arcs[k][j];
            }
        }
    }
    cout &lt;&lt; &quot;任意两点间的最短距离为：&quot; &lt;&lt; endl;
    //打印最终结果
    ShowGraph(G);
}


/*
迪杰斯特拉算法
G：图
origin：源点（起点）
*/
void Dijkstra(Graph G, int origin)
{
    //dis：储存源点到其它点的最短距离，book：用来做标记，标记到当前点到源点的最短距离是否已被确定
    int *dis = new int[G.vCount], *book = new int[G.vCount];
    int i = 0, j = 0, k = 0, s = 0, min = MaxInt;
    for (i = 0; i &lt; G.vCount; ++i) {
        //GetSub(G,origin)：获取源点在顶点表中的下标
        s = GetSub(G, origin);
        dis[i] = G.arcs[s][i];
    }
    //初始化标记
    for (i = 0; i &lt; G.vCount; ++i) {
        book[i] = 0;
    }
    //设置源点到源点的最短距离为已确定
    book[s] = 1;

    //确定源点到dis表里的所有顶点的最短距离，算法核心
    for (i = 1; i &lt; G.vCount; ++i) {
        min = MaxInt;
        //在未确定到源点最短距离的顶点中找到离源点最近的顶点
        for (j = 1; j &lt; G.vCount; ++j) {
            if (book[j] == 0 &amp;&amp; dis[j] &lt; min) {
                min = dis[j];
                s = j;
            }
        }
        //设置s点到源点的最短距离为已知
        book[s] = 1;
        //对当前顶点的出边进行松弛
        for (k = 0; k &lt; G.vCount; ++k) {
            //判断下标为s的顶点到下标为k的顶点间是否存在边，若存在，对其进行松弛操作
            if (G.arcs[s][k] &lt; MaxInt) {
                if (dis[k] &gt; dis[s] + G.arcs[s][k]) {
                    dis[k] = dis[s] + G.arcs[s][k];
                }
            }
        }
    }

    //打印最短路径
    for (i = 0; i &lt; G.vCount; ++i) {
        cout &lt;&lt; &quot;点&quot; &lt;&lt; origin &lt;&lt; &quot;到&quot; &lt;&lt; G.vexs[i] &lt;&lt; &quot;的最短距离为：&quot; &lt;&lt; dis[i] &lt;&lt; endl;
    }

}

int main()
{
    Graph G;
    cin &gt;&gt; G.vCount &gt;&gt; G.aCount;
    CreatMap(G);
    ShowGraph(G);
    Floyd(G);
    Dijkstra(G, 0);
    system(&quot;pause&quot;);
    return 0;
}


/*
10 13
0 1 2 3 4 5 6 7  8 9
0 1 3
0 6 6
0 4 5
1 2 2 
1 9 9
2 3 1
3 6 3
4 5 3
5 6 2
6 7 2
6 9 3
7 8 6
8 9 8
*/
</code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/04/常用排序算法/">常用排序算法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-04</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/算法/">算法</a></span><div class="content"><h2 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h2><blockquote>
<p>常用算法分类</p>
</blockquote>
<p><img src="http://p.qpic.cn/pic_wework/1948211503/aaac57a57a48b9b14644657fdd9edc9ea7fe380cd2fc0316/0" alt=""></p>
<blockquote>
<p>常用算法性能分析</p>
</blockquote>
<p><img src="http://p.qpic.cn/pic_wework/1948211503/fdfb00f2ed8b878e504b553a62d32a0a37b1b041127d1e3b/0" alt=""><br><strong>后三个算法中的 k 表示桶的数量</strong></p>
<blockquote>
<p><strong>稳定/不稳定</strong>：若i&lt;j,a[i]=a[j],排完序后a[i]与a[j]的相对位置不发生变化(即仍然i&lt;j)，则称算法是稳定的，反之不稳定。这种特性在一些情况下还是有用的，例如对按学生姓名排好序的列表再按成绩排序时，可以保证成绩相同的学生是按照姓名排序的。<br><strong>在位</strong>：如果一个算法不需要额外的储存空间（除了个别储存单元外），我们把它称为是在位的。</p>
</blockquote>
<h3 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h3><blockquote>
<p><strong>冒泡排序的基本思想是：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。</strong><br>如果对n个数按从小到大排序的话，就要执行<strong>n-1</strong>趟“冒泡”操作，每执行一趟都将剩余列表中的最大值交换到最后。</p>
</blockquote>
<pre><code>void bubblesort(int *array, int length)
{
    int temp;
    //执行length-1趟&quot;冒泡&quot;操作
    for (int i = 0; i &lt; length - 1; ++i) {
        //在剩余数列中对满足条件的两个数执行交换操作
        for (int j = 0; j &lt; length - i - 1; ++j) {
            if (array[j] &gt; array[j + 1]) {
                temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
}
</code></pre><blockquote>
<p>冒泡排序是一种基于<strong>蛮力法</strong>的算法，因此在处理较多的数据时，使用冒泡排序显然不是一个好的选择。通过这样可以对冒泡排序的性能进行少许提升：<br>若在一次循环中没有进行元素交换的操作，就表示列表已经有序，便可以直接结束算法了。</p>
</blockquote>
<h3 id="2、快速排序（Quick-Sort）"><a href="#2、快速排序（Quick-Sort）" class="headerlink" title="2、快速排序（Quick Sort）"></a>2、快速排序（Quick Sort）</h3><blockquote>
<p>快速排序是最常用的排序算法，它是基于二分思想（分治法）的一种排序，要求升序排列时；   </p>
<ol>
<li>在要排序的数列中找一个<strong>基准值（pivot）</strong>   </li>
<li>然后将数列中小于基准值的数放到基准值左边，大于基准值的数放到基准值的右边   </li>
<li>递归的对基准值左边和右边的数列执行上述步骤</li>
</ol>
</blockquote>
<ul>
<li><strong>对数列6 1 2 7 9 3 4 5 10 8执行1、2步骤图示：</strong><br>注意 j 先出发</li>
</ul>
<p><img src="http://p.qpic.cn/pic_wework/1948211503/95936b9a7523aa20e8865abe483f9edb9b569e0d2b88d22d/0" alt=""><br><img src="http://p.qpic.cn/pic_wework/1948211503/b7b149b8c08ca64c8596fc2000bb43870d29849da5b0c48c/0" alt=""><br><img src="http://p.qpic.cn/pic_wework/1948211503/b4b24abbe6212cbd83084f7fc5b618ed65b603308cd5bc16/0" alt=""><br><img src="http://p.qpic.cn/pic_wework/1948211503/93956d9c3576f77fc1431ef3e288c211f8643a5ed84ce2fc/0" alt=""></p>
<pre><code>void quicksort(int* array, int left, int right)
{
    int i, j, t, temp;
    if (left &gt; right)
        return;
    temp = array[left];        //设置基准值
    i = left;
    j = right;
    while (i != j) {
        //先让 j--,因为基准值在最左边，先 j-- 可以保证 i，j 相遇处的值绝对小于基准值
        while (array[j] &gt;= temp &amp;&amp; i &lt; j)
            j--;
        while (array[i] &lt;= temp &amp;&amp; i &lt; j)
            i++;
        if (i &lt; j) {
            t = array[i];
            array[i] = array[j];
            array[j] = t;
        }
    }
    array[left] = array[i];
    array[i] = temp;
    quicksort(array, left, i - 1);            //排序基准值左边的数列
    quicksort(array, i + 1, right);            //排序基准值右边的数列
}
</code></pre><ul>
<li><strong>算法处理过程：</strong><br><img src="http://p.qpic.cn/pic_wework/1948211503/383ec6374f53a5adbb69f3894db5ede63256cf30883a84eb/0" alt=""></li>
</ul>
<blockquote>
<p>快速排序之所以比较快，是因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样只能在相邻的数之间进行交换，交换的距离就大得多了。因此总的比较和交换次数就少了，速度自然就提高了。<br>当然在最坏的情况下（例如以两端为基准点对<strong>有序</strong>列表再次排序时），即分裂点位于数列的两端时，仍是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的；最好情况下，即分裂点在中间时，时间复杂度为O(nlogn)。<br>对于快速算法的优化，包括以下几个方面：</p>
<ul>
<li>更好的基准选择方法（如 三平均分区法，以最左边、最右边和中间的元素的中值作为基准值）；   </li>
<li>当子数组足够小时改用更简单的排序算法；   </li>
<li>避免递归（非递归快速排序）；</li>
</ul>
</blockquote>
<h3 id="3、选择排序（Selection-Sort）"><a href="#3、选择排序（Selection-Sort）" class="headerlink" title="3、选择排序（Selection Sort）"></a>3、选择排序（Selection Sort）</h3><blockquote>
<p>选择排序也是蛮力法在排序方面的一种应用。选择排序开始时，我们扫描整个列表找到值最小的元素与第一个元素交换，然后从第二个元素开始扫描整个列表，找到最小值与第二个元素进行交换，直到从第n-1个元素开始扫描整个列表找到最小值与第n-1位元素进行交换。</p>
</blockquote>
<pre><code>void SelectionSort(int* array, int len)
{
    int temp, minIndex;
    for (int i = 0; i &lt; len - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j &lt; len; ++j) {
            if (array[minIndex] &gt; array[j])
                minIndex = j;
        }
        temp = array[i];
        array[i] = array[minIndex];
        array[minIndex] = temp;
    }
}
</code></pre><blockquote>
<p>无论输入的数列是怎样的，选择排序的时间复杂度都是O(n^2),然而，键的交换次数仅为O(n)。   </p>
</blockquote>
<h3 id="4、插入排序（Insertion-Sort）"><a href="#4、插入排序（Insertion-Sort）" class="headerlink" title="4、插入排序（Insertion Sort）"></a>4、插入排序（Insertion Sort）</h3><blockquote>
<p>插入排序是一种通过<strong>减一技术(减治法)</strong>实现的排序算法。   </p>
<ul>
<li>减治技术利用了一个问题给定<strong>实例的解</strong>和同样问题<strong>较小实例的解</strong>之间的某种关系。一旦建立     了这种关系，我们就可以<strong>从顶至下(递归)</strong>或<strong>从底至上(非递归)</strong>地来运用该关系。 </li>
</ul>
<p>插入排序就建立了这种关系：假设一个列表的前n-1项已经有序，我们可以通过把第n项元素插入到这个较小规模的有序列表中，得到最终的有序列表。<br>假设当前要插入的元素为temp，我们从右到左扫描这个有序的子数组，遇到第一个小于等于temp的元素，然后把temp插入到该元素后面。</p>
</blockquote>
<pre><code>//插入排序
void InsertionSort(int* array, int len)
{
    int temp, preIndex;
    for (int i = 1; i &lt; len; ++i) {
        temp = array[i];            //储存当前要向有序链表中插入的元素的值
        preIndex = i;
        while (preIndex &gt; 0 &amp;&amp; temp &lt; array[preIndex - 1]) {
            array[preIndex] = array[preIndex - 1];
            preIndex--;
        }
        array[preIndex] = temp;
    }
}

//插入排序（递归）
void InsertionSort2(int* array, int len)
{
    if (len == 1)
        return;
    InsertionSort2(array, len - 1);

    int preIndex, temp;
    temp = array[len - 1];
    preIndex = len - 1;
    while (preIndex &gt; 0 &amp;&amp; temp &lt; array[preIndex - 1]) {
        array[preIndex] = array[preIndex - 1];
        --preIndex;
    }
    array[preIndex] = temp;
}
</code></pre><p>在最坏情况下，temp &lt; array[preIndex - 1]的执行次数达到最大（比如是个递减的列表(相对而言，上述代码是升序排序)），这是算法复杂度为O(n^2)。然而，对于有序数组这种最优输入，该算法有着非常好的性能。对于升序排序来说，当输入的列表为升序列表时，temp &lt; array[preIndex - 1]只需执行n次，即时间复杂度为O(n)。因此，当输入数列<strong>基本有序</strong>时，插入排序能够有更好的性能</p>
<h3 id="5、希尔排序（Shell-Sort）"><a href="#5、希尔排序（Shell-Sort）" class="headerlink" title="5、希尔排序（Shell Sort）"></a>5、希尔排序（Shell Sort）</h3><blockquote>
<p>希尔排序又称“缩小增量排序”，希尔排序从“减少记录个数”和“序列基本有序”两个方面对直接插入排序进行了改进。在希尔排序中，对列表进行分组，对每组记录进行直接插入排序，经过几次分组之后，整个列表中的记录都“基本有序”了，这时在对整体进行一次直接插入排序。<br>希尔排序通过相隔某个“增量”对记录进行分组。</p>
</blockquote>
<pre><code>void ShellSort(int* array, int len)
{
    int temp, preIndex;
    //增量（grp）为1时，对整个数组进行直接插入排序，
    //此时的数列基本上是排好序的了。
    for (int grp = len / 2; grp &gt; 0; grp /= 2) {
        //对每组进行插入排序
        for (int i = grp; i &lt; len; ++i) {
            preIndex = i - grp;
            temp = array[i];
            while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; temp) {
                array[preIndex + grp] = array[preIndex];
                preIndex -= grp;
            }
            array[preIndex + grp] = temp;
        }
    }
}
</code></pre><blockquote>
<p>希尔排序只能用于顺序结构，不能用于链式结构，增量序列可以有各种取法，但应该使增量序列的值没有除1之外的公因子，并且最后一个增量的值必须为1，记录总的比较次数和移动次数比直接插入排序要少，记录个数越多，效果越明显，因此，希尔排序更适合初始记录无须、数据量较大时的情况。</p>
</blockquote>
<h3 id="6、堆排序（Heap-Sort）"><a href="#6、堆排序（Heap-Sort）" class="headerlink" title="6、堆排序（Heap Sort）"></a>6、堆排序（Heap Sort）</h3><blockquote>
<p>堆排序是一种树型选择排序，在排序过程中，将待排序序列看成一棵完全二叉树。利用完全二叉树中双亲结点与孩子结点之间的内在关系，在当前序列中选择最大（或最小）的记录。通过大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征，来选择当前序列中的最大（或最小）的记录。   </p>
<ul>
<li>堆的定义（1 &lt;= i &lt;= n/2）<br>（1）ki &gt;= k2i且ki &gt;= k2i+1  （2）ki &lt;= ki且ki &lt;= ki+1<br>按堆的定义将带排序序列调整为大根堆，交换r[1]与r[n],调整剩余数列为大顶堆（即只需将当前堆顶元素向下调整即可），直到堆中只剩一个元素为止。</li>
</ul>
</blockquote>
<pre><code>//向下调整
void SiftDown(int *array, int n, int i)
{
    //如果当前结点至少存在一个孩子结点，比较它与孩子结点的大小
    while ((2 * i + 1) &lt;= n) {
        int t = i;
        if (array[t] &lt; array[2 * i + 1])
            t = 2 * i + 1;
        if ((2 * i + 2) &lt;= n &amp;&amp; array[t] &lt; array[2 * i + 2])
            t = 2 * i + 2;
        //当前结点比它的孩子结点小，进行交换
        if (t != i) {
            int temp = array[t];
            array[t] = array[i];
            array[i] = temp;
            i = t;        //当前结点的索引变为t
        }
        //当前结点比它两个孩子结点的值大，结束调整
        else
            break;
    }
}
void HeapSort(int *array, int n)
{
    //（初始化堆）从最后一个非叶结点的结点开始依次进行向上调整
    for (int i = n / 2; i &gt;= 0; --i) {
        SiftDown(array, n, i);
    }
    //将堆顶元素放到最后，并在剩余的 n-- 数内对新的堆顶元素向下调整
    while (n &gt;= 0) {
        int temp = array[n];
        array[n] = array[0];
        array[0] = temp;
        SiftDown(array, --n, 0);
    }
}
</code></pre><blockquote>
<p>对于堆排序，初建堆时比较次数较多，因此记录较少时不宜采用，当记录较多时较为高效。</p>
</blockquote>
<h3 id="7、归并排序（Merge-Sort）"><a href="#7、归并排序（Merge-Sort）" class="headerlink" title="7、归并排序（Merge Sort）"></a>7、归并排序（Merge Sort）</h3><blockquote>
<p>归并排序就是将两个或者两个以上的有序列表合成一个有序列表的过程。将2个有序表合成一个有序表的过程称为2-路归并。对一个有n个记录的列表进行归并排序时，可以将列表看成是n个有序的子序列，每个序列的长度为1。然后两两合并得到n/2个长度为2或1的有序子序列，再两两合并，直到得到一个长度为n的有序序列为止。<br>在归并时，分别从两个要归并的序列中得到最小的值，放到一个新的列表中，重复这个过程直到其中一个列表为空，然后将非空列表中的剩余部分直接复制到新列表中。</p>
</blockquote>
<p><img src="http://p.qpic.cn/pic_wework/1948211503/64626c74be2f621b6f7ee6552b8440ea17f32eb3974d660c/0" alt=""></p>
<pre><code>void merge(int *array, int L_left, int L_right, int R_left, int R_right)
{
    //申请一个新数组用来储存排好序的数组
    int *temp = new int[R_right - L_left + 1];
    int i = L_left, j = R_left, k = 0;
    //将两数组中的数据有序归并到temp中
    while (i &lt;= L_right &amp;&amp; j &lt;= R_right) {
        temp[k++] = (array[i] &lt; array[j]) ? array[i++] : array[j++];
    }
    //将左数组或者右数组中剩余的有序数列归并到temp中
    while (i &lt;= L_right) {
        temp[k++] = array[i++];
    }
    while (j &lt;= R_right) {
        temp[k++] = array[j++];
    }
    //将排好序的数列替换到原数列中
    k = 0;
    for (i = L_left; i &lt;= R_right; ++i) {
        array[i] = temp[k++];
    }
    //释放临时开辟的空间
    delete[] temp;
}
void MergeSort(int *array, int left, int right)
{
    if (left + 1 &lt;= right) {
        MergeSort(array, left, (right + left) / 2);
        MergeSort(array, (right + left) / 2 + 1, right);
        merge(array, left, (right + left) / 2, (right + left) / 2 + 1, right);
    }
}
</code></pre><blockquote>
<p>用顺序表实现归并排序时，需要和待排序记录个数相等的辅助储存空间，因此空间复杂度为O(n)，归并排序可用于练市结构，且不需要附加的储存空间。</p>
</blockquote>
<blockquote>
<p><strong>以上排序算法测试源代码：</strong> <a href="https://github.com/syfx/Sort/blob/master/Sort/Sort.cpp" target="_blank" rel="noopener">https://github.com/syfx/Sort/blob/master/Sort/Sort.cpp</a></p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/04/链表相关操作/">链表相关操作</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-04</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/算法/">算法</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/链表/">链表</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/数据结构/">数据结构</a></span><div class="content"><h2 id="链表相关操作"><a href="#链表相关操作" class="headerlink" title="链表相关操作"></a>链表相关操作</h2><blockquote>
<ol>
<li>求单链表中结点的个数   </li>
<li>将单链表反转   </li>
<li>查找单链表中的倒数第K个结点（k &gt; 0）   </li>
<li>查找单链表的中间结点   </li>
<li>从尾到头打印单链表   </li>
<li>已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序   </li>
<li>判断两个单链表是否相交   </li>
<li>求两个单链表相交的第一个结点  </li>
<li>判断一个单链表中是否有环   </li>
<li>已知一个单链表中存在环，求进入环中的第一个结点   </li>
<li>给出一单链表头指针pHead和一结点指针pToBeDeleted，O(1)时间复杂度删除结点pToBeDeleted   </li>
</ol>
</blockquote>
<ul>
<li><p><strong>链表结构</strong></p>
<pre><code>typedef  struct List {
    int val;
    List* next;
}*myList;

//创建链表
myList CreatList(unsigned int length)
{
    if (length == 0)
        return NULL;
    myList head, tail, temp;
    head = new List();
    head-&gt;next = NULL;
    tail = head;
    //在32位系统中size_t是4字节的，而在64位系统中，size_t是8字节的，这样利用该类型可以增强程序的可移植性。
    for (size_t i = 0; i &lt; length; ++i){
        temp = new List();
        cin &gt;&gt; temp-&gt;val;
        temp-&gt;next = NULL;
        tail-&gt;next = temp;
        tail = temp;
    }
    temp = head;
    head = head-&gt;next;
    delete temp;
    return head;
}
</code></pre></li>
</ul>
<h4 id="1、求单链表中结点的个数"><a href="#1、求单链表中结点的个数" class="headerlink" title="1、求单链表中结点的个数"></a>1、求单链表中结点的个数</h4><blockquote>
<p>因为要求链表中结点的个数，因此只能遍历整个链表以确定结点个数。(；´д｀)ゞ</p>
</blockquote>
<pre><code>int Length(myList head)
{
    int length = 0;
    while (head) {
        length++;
        head = head++;
    }
    return length;
}
</code></pre><h4 id="2、将单链表反转"><a href="#2、将单链表反转" class="headerlink" title="2、将单链表反转"></a>2、将单链表反转</h4><blockquote>
<p>当链表中节点个数大于1时，保存链表的头结点为oldHead指针（因为反转后这就不是头指针了），<br>如果oldHead的后继结点不为空的话，使用指针temp储存这个结点，然后赋值oldHead的后继结点为其后继结点(即temp)的后继结点，然后将temp的后继结点设置为head结点，赋值head为temp；</p>
</blockquote>
<p><img src="http://p.qpic.cn/pic_wework/1948211503/696f94662529e7b821a61fbd81de0706543ad7ea7dc42dfe/0" alt=""></p>
<pre><code>void ReverseList(myList &amp;head)
{
    if (head == NULL || head-&gt;next == NULL)
        return;
    myList temp, oldHead = head;
    while (oldHead-&gt;next) {
        temp = oldHead-&gt;next;
        oldHead-&gt;next = temp-&gt;next;
        temp-&gt;next = head;
        head = temp;
    }
}
</code></pre><h4 id="3、查找单链表中的倒数第K个结点（k-gt-0）"><a href="#3、查找单链表中的倒数第K个结点（k-gt-0）" class="headerlink" title="3、查找单链表中的倒数第K个结点（k &gt; 0）"></a>3、查找单链表中的倒数第K个结点（k &gt; 0）</h4><blockquote>
<p>使用两个指针left，right，先让right指向正数第k个结点，然后让left结点从头结点与right指针一同向后移动。当right指向最后一个结点时，left指向的就是倒数第k个结点。</p>
</blockquote>
<p><img src="http://p.qpic.cn/pic_wework/1948211503/3b3dc6341672ff7ca163d1f6a2e421b22158a6b18359d32a/0" alt=""></p>
<pre><code>myList FindCountBackwardsK(myList head, unsigned int k) 
{
    if (head == NULL)
        return NULL;
    myList  left = head, right = head;
    for (size_t i = 1; i &lt; k; ++i){
        right = right-&gt;next;
        if (!right)
            return NULL;
    }
    while (right &amp;&amp; right-&gt;next){
        right = right-&gt;next;
        left = left-&gt;next;
    }
    return left;
}
</code></pre><h4 id="4、查找单链表的中间结点"><a href="#4、查找单链表的中间结点" class="headerlink" title="4、查找单链表的中间结点"></a>4、查找单链表的中间结点</h4><blockquote>
<p>使用快慢指针，快指针每次向后移动两个结点的距离，慢指针每次向后移动一个指针距离，当快指针为空时，慢指针指向的结点便是中间结点。</p>
</blockquote>
<pre><code>myList FindMiddleNode(myList head)
{
    myList left = head, right = head;
    if (head == NULL)
        return NULL;
    while (right-&gt;next){
        right = right-&gt;next-&gt;next;
        if (right == NULL) 
            break;
        left = left-&gt;next;
    }
    return left;
}
</code></pre><h4 id="5、从尾到头打印单链表"><a href="#5、从尾到头打印单链表" class="headerlink" title="5、从尾到头打印单链表"></a>5、从尾到头打印单链表</h4><blockquote>
<p>由从尾到头可以很容易想到能够使用递归或者栈来实现。使用递归时，在遇到链表尾结点时返回，然后打印结点的值。</p>
</blockquote>
<pre><code>//从尾到头打印单链表（递归）
void PrintListFromTailToHead(myList head)
{
    if (head == NULL)
        return;
    PrintListFromTailToHead(head-&gt;next);
    cout &lt;&lt; head-&gt;val &lt;&lt; endl;
}

//从尾到头打印单链表（通过栈）
void PrintListFromTailToHeadByStack(myList head)
{
    stack&lt;myList&gt; sta;
    while (head){
        sta.push(head);
        head = head-&gt;next;
    }
    while (!sta.empty()){
        cout &lt;&lt; sta.top()-&gt;val &lt;&lt; &quot; &quot;;
        sta.pop();
    }
    cout &lt;&lt; endl;
}
</code></pre><h4 id="6、已知两个单链表pHead1-和pHead2-各自有序，把它们合并成一个链表依然有序"><a href="#6、已知两个单链表pHead1-和pHead2-各自有序，把它们合并成一个链表依然有序" class="headerlink" title="6、已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序"></a>6、已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序</h4><blockquote>
<p>可是使用归并排序的思想；选择值较小的头结点作为新的头结点，然后遍历两个链表，将值较小的结点合并到新链表中，遍历此链表的指针向后移位，另一个指针不做处理；当一个链表为空后，将不为空的链表合并到新链表中。</p>
</blockquote>
<pre><code>myList MergeOrderedLists(myList head1, myList head2)
{
    if (head1 == NULL)
        return head2;
    if (head2 == NULL)
        return head1;
    myList newHead =NULL;
    if (head1-&gt;val &gt;= head2-&gt;val) {
        newHead = head2;
        head2 = head2-&gt;next;
    }
    else {
        newHead = head1;
        head1 = head1-&gt;next;
    }
    newHead-&gt;next = NULL;
    myList temp = newHead;
    while ( head1 &amp;&amp; head2){
        if (head1-&gt;val &lt; head2-&gt;val) {
            temp-&gt;next = head1;
            head1 = head1-&gt;next;
        }
        else {
            temp-&gt;next = head2;
            head2 = head2-&gt;next;
        }
        temp = temp-&gt;next;
        temp-&gt;next = NULL;
    }
    if (head1 == NULL) {
        temp-&gt;next = head2;
    }
    else {
        temp-&gt;next = head1;
    }
    return newHead;
}
</code></pre><h4 id="7、判断两个单链表是否相交"><a href="#7、判断两个单链表是否相交" class="headerlink" title="7、判断两个单链表是否相交"></a>7、判断两个单链表是否相交</h4><blockquote>
<p>从这点出发：若两个两链表相交，则这两个链表的尾结点必然相同。因此，我们可以分别遍历链表以得到他们的尾结点，然后判断两个尾结点的地址是否相同即可。</p>
</blockquote>
<pre><code>bool IsIntersect(myList head1, myList head2)
{
    if (head1 == NULL || head2 == NULL)
        return false;
    while (head1-&gt;next) {
        head1 = head1-&gt;next;
    }
    while (head2-&gt;next) {
        head2 = head2-&gt;next;
    }
    //若相交则两个链表的最后一个节点必然完全相等
    if (head1 == head2)
        return true;
    return false;
}
</code></pre><h4 id="8、求两个单链表相交的第一个结点"><a href="#8、求两个单链表相交的第一个结点" class="headerlink" title="8、求两个单链表相交的第一个结点"></a>8、求两个单链表相交的第一个结点</h4><p><img src="http://p.qpic.cn/pic_wework/1948211503/67619a683e1e68a5c224b626ba6f324ec7836fde8335d76c/0" alt=""></p>
<blockquote>
<p>两链表相交，求相交的第一个结点：先遍历两个链表，分别得到两个链表的长度。（储存一下尾结点，顺便判断一下两个链表是否相交）。求相交的第一个结点时，先让一个指针从长链表的头结点向前移动<strong>abs(len1-len2)</strong>个距离，然后让另一个指针从短链表头结点出发与这个指针一同向后移动，当两个指针首次指向同一个结点时，这个结点便是两个单链表相交的第一个结点。</p>
</blockquote>
<pre><code>myList FirstIntersectNode(myList head1, myList head2)
{
    if (head1 == NULL || head2 == NULL)
        return NULL;
    int len1 = 1, len2 = 1;
    myList temp1 = head1, temp2 = head2;
    while (temp1-&gt;next) {
        len1++;
        temp1 = temp1-&gt;next;
    }
    while (temp2-&gt;next) {
        len2++;
        temp2 = temp2-&gt;next;
    }
    //判断两链表是否相交
    if (temp1 != temp2)
        return NULL;
    //保证head1是两者中较长的链表
    if (len1 &lt; len2) {
        temp1 = head1;
        head1 = head2;
        head2 = temp1;
    }
    for (int i = 0; i &lt; abs(len1 - len2); ++i) {
        head1 = head1-&gt;next;
    }
    while (head2) {
        if (head1 == head2)
            return head1;
        head1 = head1-&gt;next;
        head2 = head2-&gt;next;
    }
    return NULL;
}
</code></pre><h4 id="9、判断一个单链表中是否有环"><a href="#9、判断一个单链表中是否有环" class="headerlink" title="9、判断一个单链表中是否有环"></a>9、判断一个单链表中是否有环</h4><blockquote>
<p>可以使用快慢指针来判断单链表中是否存在环：使用两个指针fast、slow，slow每次向后移动一个结点的距离，fast每次向后移动两个结点的距离。若链表存在环的话，两个指针必然会相遇。</p>
</blockquote>
<pre><code>bool IsCircularList(myList head)
{
    if (head == NULL &amp;&amp; head-&gt;next == NULL)
        return false;
    myList temp1 = head, temp2 = head;
    //temp1和temp2都不为空
    while (temp1 &amp;&amp; temp2 &amp;&amp; temp2-&gt;next)
    {
        temp1 = temp1-&gt;next;
        temp2 = temp2-&gt;next-&gt;next;
        if (temp1 == temp2)
            return true;
    }
    return false;
}
</code></pre><h4 id="10、已知一个单链表中存在环，求进入环中的第一个结点"><a href="#10、已知一个单链表中存在环，求进入环中的第一个结点" class="headerlink" title="10、已知一个单链表中存在环，求进入环中的第一个结点"></a>10、已知一个单链表中存在环，求进入环中的第一个结点</h4><p><img src="http://p.qpic.cn/pic_wework/1948211503/6b6d96648f6e5c4b4eeef80f655b0c0c2e54c6a083e12304/0" alt=""></p>
<blockquote>
<p>设链表头距离环入口的长度为L，快慢指针相遇的位置为cross，该位置距离环入口的长度为S。考虑快慢指针移动的距离，慢指针走了L+S，快指针走了L+S+nR(n表示两只镇相遇前快指针走的圈数)。由于快指针的速度是慢指针的两倍，相同时间下快指针走过的路程就是慢指针的两倍，所以有2(L+S)=L+S+nR，化简得L+S=nR<br>当n=1时，即快指针在相遇之前多走了一圈，即L+S=R，也就是L=R−S，因此可以使用两个指针，一个指针从链表头部移动，一个从快慢指针第一次相遇处的后个指针开始移动，每次移动一个节点的距离，则两指针相等时所指向的结点就是进入环的第一个结点。   </p>
</blockquote>
<pre><code>myList CircularListEntrance(myList head)
{
    if (head == NULL)
        return NULL;
    myList fast = head, slow = head;
    while (slow &amp;&amp; fast &amp;&amp; fast-&gt;next)
    {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
        //第一次相交
        if (slow == fast) {
            fast = head;
            while (slow != fast) {
                //这里让指向第一次相遇处的指针先走
                slow = slow-&gt;next;
                fast = fast-&gt;next;
            }
            return slow;
        }
    }
    return NULL;
}
</code></pre><h4 id="11、给出一单链表头指针pHead和一节点指针pToBeDeleted，O-1-时间复杂度删除结点pToBeDeleted"><a href="#11、给出一单链表头指针pHead和一节点指针pToBeDeleted，O-1-时间复杂度删除结点pToBeDeleted" class="headerlink" title="11、给出一单链表头指针pHead和一节点指针pToBeDeleted，O(1)时间复杂度删除结点pToBeDeleted"></a>11、给出一单链表头指针pHead和一节点指针pToBeDeleted，O(1)时间复杂度删除结点pToBeDeleted</h4><blockquote>
<p>因为每个结点的储存结构都是相同的，因此，当pToBeDeleted不是尾结点时，可以将pToBeDeleted下个节点储存的数据复制到pToBeDeleted结点中，然后进行删除pToBeDeleted-next的操作即可。当pToBeDeleted为尾结点时，就需要遍历整个链表找到pToBeDeleted结点的前驱结点了。不过时间复杂度总体上讲为O(1);</p>
</blockquote>
<pre><code>void DeleteNode(myList head, myList pToBeDeleted)
{
    if (head == NULL)
        return;
    if (pToBeDeleted-&gt;next != NULL) {
        myList temp = pToBeDeleted-&gt;next;
        pToBeDeleted-&gt;val = temp-&gt;val;
        pToBeDeleted-&gt;next = temp-&gt;next;
        delete temp;
        temp = NULL;
    }
    else {
        if (head == pToBeDeleted) {
            delete pToBeDeleted;
            head = NULL;
            pToBeDeleted = NULL;
        }
        while (head-&gt;next != pToBeDeleted) {
            head = head-&gt;next;
        }
        head-&gt;next = NULL;
        delete pToBeDeleted;
        pToBeDeleted = NULL;
    }
}
</code></pre><blockquote>
<p><strong>测试源码：</strong><a href="https://github.com/syfx/List/blob/master/lIST/Main.cpp" target="_blank" rel="noopener">https://github.com/syfx/List/blob/master/lIST/Main.cpp</a></p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/27/递归创建二叉树时为什么要传指针的引用？/">递归创建二叉树时为什么要传指针的引用？</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-27</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/C/">C++</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/二叉树/">二叉树</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/指针/">指针</a></span><div class="content"><blockquote>
<p>复习了一下二叉树的知识，想用C++实现一颗二叉树，没想到竟然在创建二叉树时忽略了点东西。<br>本来的惯性思维是：<strong>用指针做参数传递时，指针指向的值会被同步改变。</strong>。<br>于是调用创建树的方法时，只是传递了空的指针，然后在函数中为指针开辟空间，递归创建二叉树。 然后遍历二叉树时发现二叉树为空。这是为什么呢？<br>上面惯性思维所想的的确没有错，它是对的；那为什么创建的树为空呢？那是因为，我们在创建树时，在创建方法中<strong>改变的不仅是指针指向的值，还有指针本身的值</strong>。<br>错误的创建代码为：</p>
</blockquote>
<pre><code>void CreatTree(BiTree*p)
{
    char ch;
    cin &gt;&gt; ch;
    if (ch == &apos;#&apos;)
        p = NULL;
    else {
        p = new BiTree();
        p-&gt;value = ch;
        CreatTree(p-&gt;lift);
        CreatTree(p-&gt;right);
    }
}
</code></pre><blockquote>
<p>在上述代码中，当使用new关键字开辟空间后（new关键在在<strong>自由储存区</strong>申请一快内存，它返回一个指向这块内存的指针），我们又改变了这个指针指向的值；因此，在这里指针本身和指针指向的值都发生了改变。因此，当我们创建二叉树时，应该使用指针的引用或者二级指针。示例代码如下：   </p>
<ul>
<li>堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。我们可以重载new关键字改用其他内存作为自由储存区。   </li>
</ul>
</blockquote>
<pre><code>//使用二级指针做参数
void CreatTree(BiTree**p) 
{
    char ch;
    cin &gt;&gt; ch;
    if (ch == &apos;#&apos;)
        *p = NULL;
    else {
        *p = new BiTree();
        (*p)-&gt;value = ch;
        CreatTree(&amp;(*p)-&gt;lift);
        CreatTree(&amp;(*p)-&gt;right);
    }
}

//使用指针的引用做参数
void CreatTree(BiTree* &amp;p)
{
    char ch;
    cin &gt;&gt; ch;
    if (ch == &apos;#&apos;)
        p = NULL;
    else {
        p = new BiTree();
        p-&gt;value = ch;
        CreatTree(p-&gt;lift);
        CreatTree(p-&gt;right);
    }
}
</code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/20/设计模式之单例模式/">设计模式之单例模式</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-20</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/设计模式/">设计模式</a></span><div class="content"><h2 id="单例模式（Singleton-Pattern）"><a href="#单例模式（Singleton-Pattern）" class="headerlink" title="单例模式（Singleton Pattern）"></a>单例模式（Singleton Pattern）</h2><blockquote>
<p>单例模式又称<strong>单件模式/单态模式</strong>，是常用的设计模式之一。单例模式要求其实例对象只能在系统中存在一个。许多时候整个系统只需要拥有一个的全局对象，使用单例模式有利于我们协调系统整体的行为。   </p>
</blockquote>
<p><strong>单例模式三要素</strong>   </p>
<ul>
<li>必须确保一个类只有一个实例    </li>
<li>它必须自行创建这个实例    </li>
<li>必须自行向整个系统提供这个实例     </li>
</ul>
<blockquote>
<p>代码分析（c#）   </p>
</blockquote>
<pre><code>namespace Singleton
{

    /*
    空间换时间   
    声明属性时直接将它初始化   
    缺点：在没有使用时内存已经分配，（如果此单例类未被使用）就造成了空间浪费。   
    */
    class SimpleSingle
    {
        private static _mySingle = new SimpleSingle();
        public static mySingle{
            get{return _mySingle;}
        }    
    }
    /*
    饿汉式   
    时间换空间   
    缺点，因为要判断属性是否为null，因此是线程不安全的。  
    可能一个线程刚进入判断后，CPU被另外一个线程抢占而导致生成多个实例。   
    */
    class Single
    {
        private static _mySingle;
        public static mySingle{
            get{
                if(_mySingle == null)
                    _mySingle = new Single();
                return _mySingle;
            }
        }
    }

    /*
    懒汉式
    使用互斥锁保证线程安全
    */
    class MySingleton
    {
        static public Mutex mutex = new Mutex();   //创建互斥锁对象
        static private MySingleton _instance;
        static public MySingleton instance {
            get
            {
                mutex.WaitOne();            //申请互斥锁
                if (_instance == null)
                    _instance = new MySingleton();
                mutex.ReleaseMutex();       //释放锁资源
                return instance;
            }
        }

        //私有化构造函数
        private MySingleton() { }
    }
}
</code></pre><p><strong>单例模式分析</strong>   </p>
<blockquote>
<p>单例模式保证一个类仅有一个实例，并提供了一个访问它的全局访问点；单例模式拥有一个私有构造函数，确保用户不能再外界实例化它；该模式中还存在一个静态私有变量和一个静态公有工厂方法，在这个工厂方法中确保实例化自己一次，将对象保存到静态成员变量中。</p>
</blockquote>
<p><strong>单例模式的优缺点</strong>   </p>
<ul>
<li><p>优点：     </p>
<ul>
<li><strong>提供了对唯一实例的受访控制</strong>。单例类封装了它的唯一实例，所以它可以严格控制客户如何访问它。   </li>
<li><strong>节约系统资源</strong>。在系统中只存在一个对象。    </li>
<li><strong>允许可变数量的实例</strong>，可以基于单例模式进行扩展，在其工厂方法（获取实例的成员方法）中做控制以用来获取指定数目的实例。      </li>
</ul>
</li>
<li><p>缺点：      </p>
<ul>
<li><strong>单例模式在扩展时有很大的困难</strong>，因为单例模式没有抽象层（抽象父类）。</li>
<li><strong>单例类职责过重</strong>，在一定程度上违背了“单一职责原则”。它既充当了工厂角色，提供了工厂方法（获取自己的实例）；又充当了产品角色，有自己的业务逻辑；讲产品的创建与自身功能融合到了一起。      </li>
<li><strong>滥用单例时将带来一些负面问题</strong>，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收（c#、Java等语言具有垃圾自动回收机制），这将导致对象状态的丢失。   </li>
</ul>
</li>
</ul>
<p><strong>适用场景</strong>   </p>
<ul>
<li>单例模式只允许创建一个对象，因此节省内存，加快对象访问速度，因此在对象需要被公用的场合适合使用。如：    <ol>
<li>需要频繁实例化然后销毁的对象。    </li>
<li>创建对象时耗时过多或者耗资源过多，但又经常用到的对象。    </li>
<li>有状态的工具类对象。     </li>
<li>频繁访问数据库或文件的对象。       </li>
</ol>
</li>
<li>单例模式的经典使用场景：   <ol>
<li>资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。      </li>
<li>控制资源的情况下，方便资源之间的互相通信。如线程池等。   </li>
</ol>
</li>
</ul>
<p><strong>注意事项</strong>   </p>
<ol>
<li>使用时不能用反射模式创建单例，否则会实例化一个新的对象。    </li>
<li>使用饿汉单例模式时注意线程安全问题。     </li>
<li>单例模式中构造方法都是私有的，因而是不能被继承，有些单例模式可以被继承（如登记式模式）。       </li>
</ol>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By fx</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>