<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++知识点总结</title>
      <link href="/2019/09/03/C-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/03/C-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写在前面：当要找工作时，发现对于面试中问的问题总有种朦朦胧胧的熟悉感，但让自己说时又不能说出个所以然来，归根结底，还是太<strong>菜</strong>了；记性不好，还是把比较重要的知识点记下来，常看看吧。</p></blockquote><h3 id="C-语言简介"><a href="#C-语言简介" class="headerlink" title="C++语言简介"></a>C++语言简介</h3><blockquote><p><strong>c++</strong>是在<strong>c</strong>语言的基础上开发出的一种<strong>面向对象</strong>的编程语言，c++支持多种编程范式，包括面向对象编程、泛型编程、过程化编程。c++应用广泛，常应用于系统、引擎等开发领域。</p></blockquote><p><strong>面向对象</strong>   </p><blockquote><p>从实体上抽象出我们需要的属性及行为。<br>对于其三大基本特征<strong>封装、继承、多态</strong>，我想是大概是在一定程度上增加了程序的安全性、复用性及灵活性吧。</p></blockquote><p><strong>C++与C的区别</strong></p><blockquote><p>主要区别在于 c++ 在 c 语言的基础上增加了类的概念，这一点可以从 c++ 早前的名字 c with classes 中看出。再者，c++ 相比 c 语言引入了更多的特性，例如命名空间、模板与泛型编程特性。</p></blockquote><h3 id="define、const"><a href="#define、const" class="headerlink" title="#define、const"></a>#define、const</h3><ul><li><a href="https://syfx.github.io/2019/03/13/c-%E5%AE%8F/#more">#define</a>：预编译指令，可用来定义一个常量。   </li><li>const：是c和c++中的关键字，用来声明一个常量（不可改变的变量），const可在一定程度上提高程序的安全性及可靠性；const可用来修饰<strong>基本数据类型</strong>、<strong>指针</strong>和<strong>引用</strong>；当const修饰指针时，要搞明白被修饰的是<strong>指针本身</strong>，还是<strong>指针指向的变量</strong>，例如：   </li></ul><pre><code class="c++"><span class="keyword">int</span> t1 = <span class="number">1</span>, t2 = <span class="number">2</span>;<span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;t1;            <span class="comment">//指针常量</span><span class="keyword">int</span> <span class="keyword">const</span> *p2 = &amp;t1;            <span class="comment">//指针常量（p1与p2效果相同）</span><span class="comment">//*p2 = 3;    (错误)                //不允许修改 指针指向的变量 的值</span>p2 = &amp;t2;                        <span class="comment">//允许修改 指针 的值</span><span class="keyword">int</span> *<span class="keyword">const</span> p3 = &amp;t1;            <span class="comment">//常量指针</span>*p3 = <span class="number">3</span>;                        <span class="comment">//允许修改 指针指向的变量 的值</span><span class="comment">//p3 = &amp;t2;    (错误)                //不允许修改 指针 的值</span></code></pre><p>使用const修饰的<strong>函数</strong>，只能调用const修饰的函数，普通函数能调用const修饰的函数。<br>使用const修饰的<strong>成员函数</strong>，表示在该函数中不会对<strong>对象</strong>进行改变。</p><h3 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用"></a>static的作用</h3><p>在c++中，static会修改所修饰标识符的链接属性，由external（外部的）变为internal（内部的）；<br>即该标识符只能在其所处的文件中起作用。    </p><blockquote><p>补充：   </p><ol><li>另一个链接属性 <strong>none</strong>：总是被当做单独的个体，也就是说该标识符的多个声明被当作独立不同的实体。   </li><li>extern：<strong>声明</strong>一个全局变量，作用范围是整个工程。</li></ol></blockquote><h4 id="关于变量的声明与定义"><a href="#关于变量的声明与定义" class="headerlink" title="关于变量的声明与定义"></a>关于变量的<strong>声明</strong>与<strong>定义</strong></h4><pre><code>声明（引用性声明）：声明一个变量时并没有为该变量分配内存空间，它只是告诉编译器，    该变量会在某处进行定义。   定义（定义性声明）：声明一个变量的同时也为其分配储存空间。声明一个变量extern int A;或 extern A;定义一个变量int A;</code></pre><p>1.对于全局静态变量而言，可将该变量的作用域理解为从其所在文件开头，到其所在文件的结尾。<br>全局静态变量被储存在<strong>全局静态区</strong>   </p><p>2.局部静态变量，作用域不变，只是在离开作用域后，局部静态变量并未被销毁，当再次进入该作用域时，它的值也和上次一样。<br>全局静态变量也被储存在<strong>全局静态区</strong> </p><h4 id="关于内存五区"><a href="#关于内存五区" class="headerlink" title="关于内存五区"></a>关于内存五区</h4><blockquote><p>栈区、堆区、静态区、常量区、代码区</p></blockquote><p>花费碎片时间，将搞懂的知识点写下来，未完待续。。。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2019/08/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2019/08/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><blockquote><p>学习动态规划思想后的学习总结，以便日后复习使用。   </p></blockquote><h3 id="动态规划思想三要素：最优子结构、边界、状态转移公式。"><a href="#动态规划思想三要素：最优子结构、边界、状态转移公式。" class="headerlink" title="动态规划思想三要素：最优子结构、边界、状态转移公式。"></a>动态规划思想三要素：<strong>最优子结构、边界、状态转移公式。</strong></h3><ul><li>最优子结构<br>要解决当前问题，需解决的简化后的子问题。</li><li>边界<br>问题结束的条件。</li><li>状态转移公式<br>联系当前子结构和上一级结构之间的表达式。</li></ul><blockquote><p>找寻上述三个要素的过程称为“建模”，其难点在于如何建立状态转移公式。   </p></blockquote><p>还是以几个问题为例对这一思想进行阐述吧。</p><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>指这样一个数列，第一项和第二项为1，其余项的值为它前两项值得和：1,1,2,3,5,8……n<br>问题：求第n项的值。</p><p>对于这个问题，最先想到的办法应该是通过递归解决，因为它的代码书写比较简单。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibo</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> n)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> fibo(nums, n - <span class="number">1</span>) + fibo(nums, n - <span class="number">2</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用递归解决时，最大的问题就是进行了太多次无意义的重复函数调用，比如，在求n-1项和n-2项的值时，都调用了函数来求n-3项的值。具体有多少个重复项，可以自己画个二叉树来分析一下。<br>怎么避免呢？可以从以空间换时间的角度来思考一下，比如将所有已求得的值保存到哈希表中，当需要某项的值时，先从哈希表中查找，没有查找到时再递归运算。    </p><blockquote><p>在上面这一优化策略中就体现出了动态规划的思想：<strong>动态规划在于避免进行重复的运算，根据从低至上的策略，让先解决的子问题的结果作为后续问题的条件以避免重复求解相同的问题。</strong>  </p></blockquote><p>因此，我们可以这样来解决上述问题   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibo</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> n)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>, s = <span class="number">1</span>;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)&#123;   </span><br><span class="line">    s = f + s;   </span><br><span class="line">    f = s - f;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> s;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上面的代码中，首先我们将s赋值为f+s；然后在通过s-f将f赋值为之前s的值；最终的s就是第n项的值</p></blockquote><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL入门</title>
      <link href="/2019/08/21/OpenGL%E5%85%A5%E9%97%A8/"/>
      <url>/2019/08/21/OpenGL%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一、状态机"><a href="#一、状态机" class="headerlink" title="一、状态机"></a>一、状态机</h1><p>在真正学习OpenGL之前，要先了解一个概念：<strong>状态机</strong>   </p><blockquote><p>什么是状态机呢？可以将它理解成一种设计模式——通过一段特殊的组织代码的方式来表示对象当前所处的状态。<br>概念总是不好理解，举个栗子：比如有一个小的绘制图形的状态机sOpenGL，里面有个属性保存当前要绘制的图形（即当前的状态），当我们设置要绘制的图形为 圆形 之后，每次通过这个sOpenGL绘制图形，都会绘制一个圆。然后当我们不想让它绘制圆时，就调用接口改变要绘制的图形（切换状态）。<br>状态机当前的状态又被称为 上下文(Context)</p></blockquote><p>OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项(当前图形的渲染设置)，操作缓冲(当前保存的图形数据)。最后，我们使用当前OpenGL上下文进行图形渲染。</p><p>待更新。。。</p>]]></content>
      
      
      <categories>
          
          <category> 图形渲染 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity3D性能优化</title>
      <link href="/2019/06/14/Unity3D%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2019/06/14/Unity3D%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="多细节层次（LOD）"><a href="#多细节层次（LOD）" class="headerlink" title="多细节层次（LOD）"></a>多细节层次（LOD）</h2><blockquote><p>使用LOD优化技术进行渲染，可以随着某个对象与摄像机的距离增加而减少渲染对象的三角形数量。只要全部的对象不是同时靠近摄像机，LOD 便能降低硬件的负载并提高渲染性能。<br>在 Unity 中，使用 LOD Group 组件为对象设置 LOD 渲染。</p></blockquote><ul><li>选中某个层级后，通过拖拽或者点击Add按钮来选择相机位于这个层级时应显示的图形<br><img src="http://p.qpic.cn/pic_wework/1948211503/9f99dc8f85cf39bc21dede85ac32cd562dec7a948d72b9ba/0" alt=""></li><li>在一个层级上点击右键来增加一个新层级或者删除选定的层级<br><img src="http://p.qpic.cn/pic_wework/1948211503/9294d182bfc64a682e78418fec87deda5a8680f4ab03d870/0" alt=""></li></ul><h2 id="Mipmap"><a href="#Mipmap" class="headerlink" title="Mipmap"></a>Mipmap</h2><p>Mipmap 是图像逐渐减小版本的的列表，用于优化实时3D引擎的性能，当纹理远离相机时使用较小版本的纹理。<br>在导入纹理时，勾选 Generate Mip Maps选项为当前纹理创建Mipmap。使用Mipmap时会多占用 33% 的内存   </p><blockquote><p>如果贴图的基本尺寸是256x256像素的话,它 mipmap 就会有8个层级。每个层级是上一层级的四分之一的大小，依次层级大小就是：128x128;64x64;32x32;16x16;8x8;4x4;2x2;1x1(一个像素)。    </p></blockquote><p>因此，使用 Mipmap 时会增加内存占用。不过使用 Mipmap 可以很好的优化性能    </p><blockquote><p>因为 mipmap 贴图需要被读取的像素远少于普通贴图，所以渲染的速度得到了提升。而且操作的时间减少了，因为 mipmap 的图片已经是做过抗锯齿处理的，从而减少了实时渲染的负担。放大和缩小纹理也因为 mipmap 而变得更有效率。  </p></blockquote><p>建议游戏中的距离相机位置会发生变化的纹理始终使用 Mipmap；（除 GUI 纹理、天空盒、游标外） </p><h2 id="各向异性过滤（Anisotropic-filtering）"><a href="#各向异性过滤（Anisotropic-filtering）" class="headerlink" title="各向异性过滤（Anisotropic filtering）"></a>各向异性过滤（Anisotropic filtering）</h2><p>各向异性过滤可以提高从掠射角观察时的纹理质量。此渲染在显卡上非常消耗资源。提高各向异性等级对于地面和地板纹理而言是一种很好的做法。<br>可在质量设置（Quality Settings）中强制对所有纹理进行各向异性过滤或完全禁用该功能。<br>导入纹理时通过 Aniso Level 选项来设置各向异性等级。</p><h2 id="纹理导入设置对性能及内存的影响"><a href="#纹理导入设置对性能及内存的影响" class="headerlink" title="纹理导入设置对性能及内存的影响"></a>纹理导入设置对性能及内存的影响</h2><h3 id="纹理尺寸大小"><a href="#纹理尺寸大小" class="headerlink" title="纹理尺寸大小"></a>纹理尺寸大小</h3><p>建议纹理尺寸大小应该每边为2的整数次幂（即2、4…64..2048像素）。<br>因为使用 NPOT（非2的整数幂）纹理大小时，通常要占用稍微多一点的内存；并且 GPU 的采样速度可更慢。因此，最好使用2的整幂大小的纹理。<br>如果平台或 GPU 不支持 NPOT 纹理大小，Unity 会对纹理进行缩放和填充以达到一个2的整幂大小。这一过程会使用更多内存并使加载速度变慢。<br><img src="http://p.qpic.cn/pic_wework/1948211503/9a9cde8a9be2ea844fcec526bab05a5108c42226dae5d315/0" alt=""></p><center><strong>2的整幂纹理大小,左侧不使用 mipmap，右侧使用 mipmap</strong></center><br><img src="http://p.qpic.cn/pic_wework/1948211503/292f6d390da603039d7a25af2782450099fc3297390f73a8/0" alt=""><br><center><strong>NPOT 纹理大小,左侧不使用 mipmap，右侧使用 mipmap</strong></center><h3 id="Read-Write-Enable"><a href="#Read-Write-Enable" class="headerlink" title="Read/Write Enable"></a>Read/Write Enable</h3><p>选中这个选项，允许从脚本函数（例如 Texture2D.SetPixels…）中访问纹理数据，但这种情况下会生成纹理数据的副本，使纹理资源所需的内存增加一倍，因此，非绝对必要下不要使用这个属性。</p><h3 id="Generate-Mip-Maps"><a href="#Generate-Mip-Maps" class="headerlink" title="Generate Mip Maps"></a>Generate Mip Maps</h3><p>选中此框，可为当前纹理生成 Mipmap。</p><ul><li>Border Miip Maps： 选中此框可避免颜色向外渗透到较低 MIP 级别的边缘。</li><li>Mip Map Filtering<ul><li>Box：切换时淡出 Mipmap 的最简单的方法，随着尺寸减小，MIP 级别将变得更加平滑。</li><li>Kaiser：随着 Mipmap 的尺寸大小下降，对其应用锐化。如果纹理在远处太模糊，可尝试此选项。</li></ul></li><li>Fadeout Mip Maps：滚动条左边的的滚动项表示第一个开始淡出的 MIP 级别。其右边的滚动项表示纹理完全变灰的 MIP 级别。</li></ul><h3 id="Aniso-Level"><a href="#Aniso-Level" class="headerlink" title="Aniso Level"></a>Aniso Level</h3><p>以大角度查看时提高纹理质量。</p><h2 id="避免频繁的GC"><a href="#避免频繁的GC" class="headerlink" title="避免频繁的GC"></a>避免频繁的GC</h2><p>GC何时触发？   </p><ol><li>堆内存不足仍进行堆内存分配时</li><li>自动触发，不同的平台运行频率不一样</li><li>强制执行GC（GC.Collect()尽量避免主动调用它）<br>因此，在代码中，要尽量避免大量临时变量的生成，或者避免有大量临时变量产生的操作<br>其他策略有：   </li><li>对需要频繁生成和销毁的对象使用<a href="https://gpp.tkchu.me/object-pool.html" target="_blank" rel="noopener">对象池</a>进行缓存   </li><li>需要对字符串频繁进行拼接等操作时，使用使用StringBUilder   </li><li>循环时尽量使用for，除非必须使用foreach   </li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于脚本和设置方面的优化策略，这两篇博客写的很不错<br><a href="https://wuzhiwei.net/unity_script_optimization/" target="_blank" rel="noopener">Unity性能优化 – 脚本篇（https://wuzhiwei.net/unity_script_optimization/）</a><br><a href="https://wuzhiwei.net/unity-settings-optimization/" target="_blank" rel="noopener">Unity性能优化 – 设置篇（https://wuzhiwei.net/unity-settings-optimization/）</a></p><p>未完待续。。。</p><p>参考文献   </p><ul><li><a href="https://docs.unity3d.com/2018.4/Documentation/Manual/ImportingTextures.html" target="_blank" rel="noopener">https://docs.unity3d.com/2018.4/Documentation/Manual/ImportingTextures.html</a></li><li><a href="https://docs.unity3d.com/2018.4/Documentation/Manual/TextureTypes.html" target="_blank" rel="noopener">https://docs.unity3d.com/2018.4/Documentation/Manual/TextureTypes.html</a></li><li><a href="https://zh.wikipedia.org/wiki/Mipmap" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Mipmap</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity3D AssetBundle</title>
      <link href="/2019/05/22/Unity3DAssetBundle/"/>
      <url>/2019/05/22/Unity3DAssetBundle/</url>
      
        <content type="html"><![CDATA[<h3 id="AssetBundle简介"><a href="#AssetBundle简介" class="headerlink" title="AssetBundle简介"></a>AssetBundle简介</h3><blockquote><p>AssetBundle是Unity支持的一种文件储存格式，也是Unity官方推荐的资源存储与更新方式，它可以对资源(Asset)进行压缩，分组打包，动态加载，以及实现热更新，但是AssetBundle无法对Unity脚本进行热更新。（因此通过Lua来进行热更行）<br>至于为什么，这篇文章说的挺详细了：<a href="https://www.jianshu.com/p/71fffc9a9cac" target="_blank" rel="noopener">https://www.jianshu.com/p/71fffc9a9cac</a></p></blockquote><p>在Unity的5.3版本时，简化了AssetBundle的打包方式，只留下了一个API与寥寥几个设置参数，而之前最让人头痛的资源依赖管理，也被默认进行处理。 而在每个Asset文件的Inspector面板上都会多出一个Asset Labels的设定栏：<br> <img src="https://images-cdn.shimo.im/EObgbENsE8MT1cs7/QQ截图20180919212256.png" alt=""></p><ul><li>AssetBundle Name：需要将此资源打包的AssetBundle名称    </li><li>AssetBundle Variant：需要将此资源打包的AssetBundle的扩展名<br><strong>Variant：</strong><br>Variant是5.3以后新添加的一个概念，这个值其实是一个尾缀，添加在对应AssetBundle的名称之后，如：ddzgame.hd，hd就是Variant(从此以后AssetBundle的尾缀已经跟其文件类型本身没有任何联系了)。<br>它主要用在不同版本资源的使用和动态替换AssetBundle。它被用来支持定制化的参数。与预定义宏类似，它可以对一个单独对象重映射项目中不同的资源。这样就可以灵活控制语言、地区、或者用户偏好。AssetBundle Variant相同的AssetBundle之间将有共同的内部id。通过设置Variant变量，可以实现定制化的资源控制。可以使用Variant区分了相同资源的不同版本，所以它可以为同一个资源提供不同的解决方案。   </li></ul><h3 id="AssetBundle相关操作"><a href="#AssetBundle相关操作" class="headerlink" title="AssetBundle相关操作"></a>AssetBundle相关操作</h3><h4 id="自动打包脚本"><a href="#自动打包脚本" class="headerlink" title="自动打包脚本"></a>自动打包脚本</h4><p>从以上可知，如果需要一个一个的对资源设置AssetBundle Name与Variant实在太过繁琐与麻烦，也可能出现纰漏，好在可以通过脚本去批量设置这两个参数。（脚本放到Unity的Editor文件夹下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//path是资源在Assets下的路径（eg： Assets/.../.....）   </span><br><span class="line">AssetImporter assetImporter = AssetImporter.GetAtPath(&quot;path&quot;);   </span><br><span class="line">//设置AssetBundle Name与Variant</span><br><span class="line">assetImporter.assetBundleName = &quot;AssetbundleName&quot;;   </span><br><span class="line">assetImporter.assetBundleVariant = &quot;AssetbundleVariant&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[MenuItem(&quot;AssetsBundle/Build AssetBundle&quot;)]   </span><br><span class="line">static public void BuildAssetBundle()   </span><br><span class="line">&#123;   </span><br><span class="line">    AssetImporter asserImporter = AssetImporter.GetAtPath(&quot;Assets/Sources/Player1.prefab&quot;);   </span><br><span class="line">    asserImporter.assetBundleName = &quot;player&quot;;   </span><br><span class="line">    asserImporter.assetBundleVariant = &quot;prefab&quot;;   </span><br><span class="line"></span><br><span class="line">//将ab资源打包的当前工程的AssetBundles文件夹下（与Assets同级）</span><br><span class="line"> if(!Directory.Exists(&quot;AssetBundles&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        Directory.CreateDirectory(&quot;AssetBundles&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    BuildPipeline.BuildAssetBundles(&quot;AssetBundles&quot;, BuildAssetBundleOptions.None,   </span><br><span class="line">BuildTarget.StandaloneWindows64);    </span><br><span class="line">    AssetDatabase.Refresh();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对Scene的打包</strong><br>Scene打包跟资源打包无异，唯一需要注意的是：Scene只能与Scene打入同一个AssetBundle内，而无法与其他资源打入同一个AssetBundle。<br>AssetBundle内的Scene需要在AssetBundle加载后，通过SceneManager来加载。</p><h4 id="压缩方式"><a href="#压缩方式" class="headerlink" title="压缩方式"></a>压缩方式</h4><ol><li>LZMA（Ziv-Markov chain algorithm）格式<br>Unity打包成AssetBundle时的默认格式，会将序列化数据压缩成LZMA流，使用时需要整体解包。优点是打包后体积小，缺点是解包时间长，且占用内存。   </li><li>LZ4格式<br>5.3新版本添加的压缩格式，压缩率不及LZMA，但是不需要整体解压。LZ4是基于chunk的算法，加载对象时只有响应的chunk会被解压。   <blockquote><p>压缩格式在打包时通过AssetBundleOption参数选择。   </p></blockquote></li></ol><h4 id="AssetBundle资源加载"><a href="#AssetBundle资源加载" class="headerlink" title="AssetBundle资源加载"></a>AssetBundle资源加载</h4><p>使用 WWW 或者 AssetBundle 相关 API 加载，其中 AssetBundle 的 API 只能进行本地加载。<br><code>AssetBundle.LoadfromMemory（byte[] bytes）</code>用来对加密的Assetbundle进行读取，可以结合WWW使用。   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class BuileAsset : MonoBehaviour &#123;    </span><br><span class="line">//资源地址（Player.prefab是我的资源包的名称）   </span><br><span class="line">private string path = &quot;File://F:/myUnityProject/AssetBundle/AssetBundles/Player.prefab&quot;;     </span><br><span class="line">   </span><br><span class="line">IEnumerator Start()   </span><br><span class="line">&#123;   </span><br><span class="line">WWW www = new WWW(path);   </span><br><span class="line">yield return www;   </span><br><span class="line">if (www == null)   </span><br><span class="line">&#123;   </span><br><span class="line">Debug.Log(&quot;路径内容为空&quot;);   </span><br><span class="line">&#125;   </span><br><span class="line">else   </span><br><span class="line">&#123;   </span><br><span class="line">AssetBundle asset = www.assetBundle;   </span><br><span class="line">Object[] obj = asset.LoadAllAssets&lt;GameObject&gt;();   </span><br><span class="line">//实例化资源包中的游戏物体   </span><br><span class="line">foreach (var value in obj)   </span><br><span class="line">&#123;   </span><br><span class="line">Instantiate(value);   </span><br><span class="line">&#125;   </span><br><span class="line">www.Dispose();   </span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AssetBundle资源卸载"><a href="#AssetBundle资源卸载" class="headerlink" title="AssetBundle资源卸载"></a>AssetBundle资源卸载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssetBundle.Unload(bool unloadAllLoadedObjects);</span><br></pre></td></tr></table></figure><p>AssetBundle唯一的一个卸载函数，传入的参数用来选择是否将已经从此AssetBundle中加载的资源一起卸载。另外，已经从AssetBundle中加载的资源可以通过<code>Resources.UnloadAsset(Object)</code>卸载。不过通过<code>Resources.UnloadUnusedAssets()</code>卸载从AssetBundle加载的资源时，要先将AssetBundle卸载后才能生效。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity3D资源处理</title>
      <link href="/2019/05/20/Unity3D%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/"/>
      <url>/2019/05/20/Unity3D%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="GUID与fileID-本地ID"><a href="#GUID与fileID-本地ID" class="headerlink" title="GUID与fileID(本地ID)"></a>GUID与fileID(本地ID)</h3><p>Unity会为每个导入到Assets目录中的资源创建一个meta文件，文件中记录了GUID，GUID用来记录资源之间的引用关系。还有fileID（本地ID），用于标识资源内部的资源。资源间的依赖关系通过GUID来确定；资源内部的依赖关系使用fileID来确定。</p><h3 id="InstanceID-实例ID"><a href="#InstanceID-实例ID" class="headerlink" title="InstanceID(实例ID)"></a>InstanceID(实例ID)</h3><p>Unity为了在运行时，提升资源管理的效率，会在内部维护一个缓存表，负责将文件的GUID与fileID转换成为整数数值，这个数值在本次会话中是唯一的，称作实例ID(InstanceID)。<br>程序启动时，实例ID缓存与所有工程内建的对象(例如在场景中被引用)，以及Resource文件夹下的所有对象，都会被一起初始化。如果在运行时导入了新的资源，或从AssetBundle中载入了新的对象，缓存会被更新，并为这些对象添加相应条目。实例ID仅在失效时才会被从缓存中移除，当提供了指定文件GUID和fileID的AssetBundle被卸载时会产生移除操作。<br>卸载AssetBundle会使实例ID失效，实例ID与其文件GUID和fileID之间的映射会被删除以便节省内存。重新载入AssetBundle后，载入的每个对象都会获得新的实例ID。   </p><h3 id="资源的生命周期"><a href="#资源的生命周期" class="headerlink" title="资源的生命周期"></a>资源的生命周期</h3><p>Object从内存中加载或卸载的时间点是定义好的。Object有两种加载方式：自动加载与外部加载。当对象的实例ID与对象本身解引用，对象当前未被加载到内存中，而且可以定位到对象的源数据，此时对象会被自动加载。对象也可以外部加载，通过在脚本中创建对象或者调用资源加载API来载入对象（例如：AssetBundle.LoadAsset）<br>对象加载后，Unity会尝试修复任何可能存在的引用关系，通过将每个引用文件的GUID与FileID转化成实例ID的方式。<br>一旦对象的实例ID被解引用且满足以下两个标准时，对象会被强制加载：   </p><ul><li>实例ID引用了一个没有被加载的对象。   </li><li>实例ID在缓存中存在对应的有效GUID和本地ID。   </li></ul><p>如果文件GUID和本地ID没有实例ID，或一个已卸载对象的实例ID引用了非法的文件GUID和本地ID，则引用本身会被保留，但实例对象不会被加载。在Unity编辑器中表现为空引用，在运行的应用中，或场景视图里，空对象会以多种方式表示，取决于丢失对象的类型：网格会变得不可见，纹理呈现为紫红色等等。</p><h3 id="MonoScripts"><a href="#MonoScripts" class="headerlink" title="MonoScripts"></a>MonoScripts</h3><p>一个MonoScripts含有三个字符串：程序集名称，类名称，命名空间。<br>构建工程时，Unity会收集Assets文件夹中独立的脚本文件并编译他们，组成一个Mono程序库。Unity会将Assets目录中的语言分开编译，Assets/Plugins目录中的脚本同理。Plugin子目录之外的C#脚本会放在Assembly-CSharp.dll中。而Plugin及其子目录中的脚本则放置在Assembly-CSharp-firstpass.all中。<br>这些程序库会被MonoScripts所引用，并在程序第一次启动时被加载。</p><h3 id="资源文件夹Assets"><a href="#资源文件夹Assets" class="headerlink" title="资源文件夹Assets"></a>资源文件夹Assets</h3><p>为Unity编辑器下的资源文件夹，Unity项目编辑时的所有资源都将置入此文件夹内。在编辑器下，可以使用以下方法获得资源对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssetDatabase.LoadAssetAtPath(&quot;Assets/x.txt&quot;);</span><br></pre></td></tr></table></figure><p>注意：此方法只能在编辑器下使用，当项目打包后，在游戏内无法运作。参数为包含Assets内的文件全路径，并且需要文件后缀。<br>Assets下的资源除特殊文件夹内，或者在会打入包内的场景中引用的资源，其余资源不会被打入包中。</p><h3 id="Resources资源载入"><a href="#Resources资源载入" class="headerlink" title="Resources资源载入"></a>Resources资源载入</h3><p>Assets下的特殊文件夹，此文件夹内的资源将会在项目打包时，全部打入包内，并能通过以下方法获得对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Resources.Load(&quot;fileName&quot;);   </span><br><span class="line">Resources.Load(&quot;fileName&quot;);</span><br></pre></td></tr></table></figure><p>注意：函数内的参数为相对于Resource目录下的文件路径与名称,不包含后缀。<br>Assets目录下可以拥有任意路径及数量的Resources文件夹，在运行时,Resources下的文件路径将被合并。<br>例：Assets/Resources/test.txt与Assets/TestFloder/Resources/test.png在使用Resource.Load (“test”)载入时，将被视为同一资源，只会返回第一个符合名称的对象。如果使用Resource.Load(“test”)将返回text.txt；<br>如果在Resources下有相同路径及名称的资源，使用以上方法只能获得第一个符合查找条件的对象，使用以下方法能或得到所有符合条件的对象：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] assets = Resources.LoadAll(&quot;fileName&quot;);    </span><br><span class="line">TextAsset[] assets = Resources.LoadAll(&quot;fileName&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>在工程进行打包后，Resource文件夹中的资源将进行加密与压缩，打包后的程序内将不存在Resource文件夹，故无法通过路径访问以及更新资源。<br>在程序启动时会为Resource下的所有对象进行初始化，构建实例ID。随着Resource内资源的数量增加，此过程耗时的增加是非线性的。故会出现程序启动时间过长的问题，请密切留意Resource内的资源数量   </p></blockquote><h3 id="卸载资源"><a href="#卸载资源" class="headerlink" title="卸载资源"></a>卸载资源</h3><p>所有实例化后的 GameObject 可以通过 Destroy 函数销毁。请留意 Object 与 GameObject 之间的区别与联系<br>Object 可以通过 Resources 中的相关 Api 进行卸载：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Resources.UnloadAsset(Object);//卸载对应Object   </span><br><span class="line">Resources.UnloadUnusedAssets();//卸载所有没有被引用以及实例化的Object</span><br></pre></td></tr></table></figure><p>注意以下情况：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = Resources.Load(&quot;MyPrefab&quot;);    </span><br><span class="line">GameObject instance = Instantiate(obj) as GameObjct;    </span><br><span class="line">...</span><br><span class="line">Destroy(instance);    </span><br><span class="line">Resources.UnloadUnusedAssets(); //卸载资源</span><br></pre></td></tr></table></figure><p>此时UnloadUnusedAssets将不会生效，因为obj依然引用了MyPrefab，需要将obj = null，才可生效。   </p><h3 id="StreamingAssets"><a href="#StreamingAssets" class="headerlink" title="StreamingAssets"></a>StreamingAssets</h3><blockquote><p>概述<br>StreamingAssets 文件夹为流媒体文件夹，此文件夹内的资源将不会经过压缩与加密，原封不动的打包进游戏包内。在游戏安装时，StreamAssets 文件件内的资源将根据平台，移动到对应的文件夹内。 StreamingAssets 文件夹在 Android 与 IOS 平台上为只读文件夹。</p></blockquote><p>你可以使用以下函数获得不同平台下的StreamingAssets文件夹路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application.streamingAssetsPath</span><br></pre></td></tr></table></figure><p>参考以下各平台下 StreamingAssets 文件夹的等价路径，Application.dataPath 为程序安装路径。Android 平台下的路径比较特殊，请留意此路径的前缀，在一些资源读取的方法中是不必要的（eg：AssetBundle.LoadFromFile）    </p><ul><li>Application.dataPath+”/StreamingAssets”//Windows OR MacOS    </li><li>Application.dataPath+”/Raw” //IOS    </li><li>“jar:file://“+Application.dataPath+”!/assets/“ //Android<br>StreamingAssets文件夹下的文件在游戏中只能通过 IOStream 或者 WWW 的方式读取<br>io方式：   </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileStream stream = File.Open(Application.streamingAssetsPath + &quot;/fileName&quot;, FileMode.Open);</span><br></pre></td></tr></table></figure><p>WWW方式（注意协议与不同平台下路径的区别）：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private IEnumerator Start()   </span><br><span class="line">&#123;   </span><br><span class="line">    WWW www = new WWW(Application.streamingAssetsPath + &quot;/Cube&quot;);   </span><br><span class="line">    yield return www; </span><br><span class="line">//将获取的web页面的内容作为字符串返回（只读）    </span><br><span class="line">    Debug.Log(www.text);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AssetBundle特有的资源加载方式：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//同步地从磁盘上的文件加载    </span><br><span class="line">AssetBundle.LoadFromFile(assetbundlePath+&quot;/name.unity3d&quot;);</span><br></pre></td></tr></table></figure><h3 id="PersistentDataPath"><a href="#PersistentDataPath" class="headerlink" title="PersistentDataPath"></a>PersistentDataPath</h3><p>路径：Application.persistentDataPath<br>Unity指定的一个可读写的外部文件夹，该路径因平台及系统配置不同而不同。可以用来保存数据及文件。该目录下的资源不会在打包时被打入包中，也不会自动被Unity导入及转换。该文件夹只能通过IOStream以及WWW的方式进行资源加载。   </p><h3 id="WWW载入资源"><a href="#WWW载入资源" class="headerlink" title="WWW载入资源"></a>WWW载入资源</h3><p>WWW是一个Unity封装的网络下载模块，支持Http以及file两种URL协议，并会尝试将资源转换成Unity能使用的AssetsComponents（如果资源是Unity不支持的格式，则只能取出byte[]）。具体对应的格式参考第一章表格。WWW加载是异步加载方法。<br>每次new WWW时，Unity都会启用一个线程去进行下载。通过此方式读取或者下载资源，会在内存中生成WebStream，WebStream为下载文件转换后的内容，占用内存较大。使用WWW.Dispose将终止仍在加载过程中的进程，并释放掉内存中的WebStream。 如果WWW不及时释放，将占用大量的内存。<br>如果载入的为Assetbundle且进行过压缩，则还会在内存中占用一份AssetBundle解压用的缓冲区Deompresion Buffer,AssetBundle压缩格式的不同会影响此区域的大小。<br>WWW.LoadFromCacheOrDownload静态方法  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int version = 1;    </span><br><span class="line">WWW.LoadFromCacheOrDownload(PathURL+&quot;/fileName&quot;,version);</span><br></pre></td></tr></table></figure><p>使用此方式加载，将先从硬盘上的存储区域查找是否有对应的资源，再验证本地Version与传入值之间的关系，如果传入的Version&gt;本地Version，则从传入的URL地址下载资源，并缓存到硬盘，替换掉现有资源，如果传入的Version&lt;=本地Version，则直接从本地读取资源；如果本地没有存储资源，则下载资源。此方法的存储路径无法设定以及访问。使用此方法载入资源，不会在内存中生成WebStream（其实已经将WebStream保存在本地），如果硬盘空间不够进行存储，将自动使用new WWW方法加载，并在内存中生成WebStream。在本地存储中，使用fileName作为标识符，所以更换URL地址而不更改文件名，将不会造成缓存资源的变更。保存的路径无法更改，也没有接口去获取此路径。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c#高级知识点</title>
      <link href="/2019/04/24/c-%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2019/04/24/c-%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="c-特性与反射"><a href="#c-特性与反射" class="headerlink" title="c#特性与反射"></a>c#特性与反射</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><blockquote><p>定义：在程序运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）行为信息的声明性<strong>标签</strong>。   </p></blockquote><p>看定义，一脸懵逼，那这玩意究竟有什么用呢？<br>举个例子：比如我们有一个开发平台，向外部提供了API；然后，当我们更新时，想使用一个新的方法代替其中一个方法；这时我们总不能直接把老方法删了吧，但是我们又不想让人家用老方法了，怎么办呢？这时候，特性就可以帮助我们在人家调用老方法时提醒人。怎么用呢？呐，示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Obsolete(&quot;Don&apos;t use OldMethod(), use NewMethod()&quot;, false)]</span><br><span class="line">public void OldMethod()</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(&quot;老方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void NewMethod()</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(&quot;新方法&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Obsolete是.Net提供的三个预定义特性之一，这个预定义特性标记了不应该被使用的程序实体。它可以让您通知编译器丢弃某个特定的目标元素。语法为：<code>[Obsolete(message,iserror)]</code>   </p><ul><li>message：字符串参数，描述项目实体过时的原因以及该使用什么替代。   </li><li>iserror，布尔参数。为 true 时，编译器把对该实体的使用当作一个错误。默认值是 false（当做警告）。   </li></ul><blockquote><p>.Net提供了两种类型的特性：预定义特性，自定义特性。<br>个人理解：预定义特性是在预处理阶段起作用的特性。</p></blockquote><h3 id="预定义特性"><a href="#预定义特性" class="headerlink" title="预定义特性"></a>预定义特性</h3><p>除了Obsolete，另外两个预定义特性是AttributeUsage与Conditional。<br><strong>AttributeUsage</strong><br>语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[AttributeUsage(</span><br><span class="line">   validon,</span><br><span class="line">   AllowMultiple=allowmultiple,</span><br><span class="line">   Inherited=inherited</span><br><span class="line">)]</span><br></pre></td></tr></table></figure><p>这位的作用是描述了如何使用一个自定义特性。可以理解成用它来约束我们编写的自定义特性。看参数就知道了：       </p><ul><li>validon：规定特性可“修饰”的语言元素(类、方法…)。它是枚举器 AttributeTargets 的值的组合，使用OR（|）运算法组合；默认值是 AttributeTargets.All。   </li><li>allowmultiple：为该特性的 AllowMultiple 属性提供一个布尔值。为 true 时该特性是多用的（ 即我们的定制特性能被重复放置在同一个程序实体（语言元素）前多次。）。默认值是 false（单用的）       </li><li>inherited：为该特性的 Inherited 属性提供一个布尔值。为 true 时该特性可被派生类继承。默认值是 false（不被继承）；这里的继承指当被这个特性“修饰”的类被继承时，其子类是否也继承了此特性。<br>示例代码： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method,</span><br><span class="line">    AllowMultiple = true, </span><br><span class="line">    Inherited = true)]</span><br><span class="line">class MyHelpAttribure : Attribute</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们自定义了一个特性MyHelpAttribure，并用预定义特性AttributeUsage约束它只能放置在类和方法前面，可重复放置，可被继承。（自定义特性其实就是一个继承了System.Attribute类的类）</p><p><strong>Conditional</strong><br>Conditional 在命名空间 System.Diagnostics 下，语法如下：<code>[Conditional(conditionalSymbol)]</code>   </p><ul><li>conditionalSymbol：字符串类型，为<strong>预处理标识符</strong>的名称。<br>这个特性只能放置在<strong>特性</strong>和<strong>方法</strong>之前。 这个预定义特性标记了一个条件方法，其执行依赖于指定的预处理标识符，它会引起方法调用的条件编译。 和预编译指令 #if、#endif 作用相同。不同的是#if、#endif作用于代码段，Conditional作用于方法。<br>示例代码：   </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace cSharpReview</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        [System.Diagnostics.Conditional(&quot;DEBUG&quot;)]</span><br><span class="line">        void Method1()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Method1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        void Method2()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Method2&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Program pro = new Program();</span><br><span class="line">            pro.Method1();</span><br><span class="line">            pro.Method2();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码在Debug环境里执行结果为：<br>Method1<br>Method2<br>在Release环境里执行结果为：<br>Method2<br>因为在Debug环境下定义的有 预处理标识符 DEBUG。<br><img src="http://p.qpic.cn/pic_wework/1948211503/bdbbafad795f12972637b82c0b8050106a6b8ce205b991e0/0" alt=""><br><img src="http://p.qpic.cn/pic_wework/1948211503/e6e0f4f6ca62c1e05cbeac31aa3fc284b270710c0aa5a021/0" alt=""></p><h3 id="自定义特性"><a href="#自定义特性" class="headerlink" title="自定义特性"></a>自定义特性</h3><p>前面说过，自定义特性就是一个继承了System.Attribute的类。一般我们将自定义特性用于存储声明性的信息，可在运行时通过反射技术检索这些信息。<br>下面，通过一个示例来了解一下自定义特性。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><blockquote><p>定义：反射提供描述程序集、模块和类型的<strong>对象</strong>（Type 类型）。 可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型，然后调用其方法或访问其字段和属性。 如果代码中使用了特性，可以利用反射来访问它们。   </p></blockquote><p>通俗点讲，反射能够在获得对象的内部结构。可以理解成“给一个对象做b超”（这个对象是 Type 类型的对象实例，不是人啊，别想多了）。<br>在此之前，要了解一些名词。   </p><ul><li>程序集、模块、与类型。<br>.Net应用程序由“程序集”，“模块”，“类型”组成，程序集包含模块，模块包含类型。   </li><li>命名空间与装配件的关系。<br>名空间类似与Java的包，但又不完全等同，因为Java的包必须按照目录结构来放置，命名空间则不需要。<br>装配件，是.Net应用程序执行的最小单位，编译出来的.dll、.exe都是一个装配件。一个程序集中可以有无数个名称不同的命名空间，不同程序集之间可以有名字相同的命名空间。<br>关于装配件与程序集，是同一个概念（都是翻译惹得祸吧，英文：Assembly），这个不用纠结ヽ(ー_ー)ノ。</li></ul><p><strong>以上名词来自网络资料，如有不对，再做更改</strong></p><blockquote><p><strong>System.Type 类</strong>是反射的中心。 当反射提出请求时，公共语言运行时为已加载的类型创建 Type。 可使用 Type 对象的方法、字段、属性和嵌套类来查找该类型的任何信息。<br>继承关系：Object-&gt;MemberInfo-&gt;Type   </p></blockquote><ol><li>获取对象的三种方式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Type t = typeof(String);</span><br><span class="line">string str = string.Empty;</span><br><span class="line">Type t = str.GetType();</span><br><span class="line">Type t = Type.GetType(&quot;System.String&quot;);</span><br></pre></td></tr></table></figure><p>使用 Assembly.GetType 或 Assembly.GetTypes 从尚未加载的程序集中获取 Type 对象，传入所需类型的名称。 使用 Type.GetType 从已加载的程序集中获取 Type 对象。 使用 Module.GetType 和 Module.GetTypes 获取模块 Type 对象。   </p><ol start="2"><li><p>如何使用反射访问特性  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">//自定义特性类</span><br><span class="line">[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true)]</span><br><span class="line">class DebugInfo : Attribute</span><br><span class="line">&#123;</span><br><span class="line">    private int bugNo;               //调错编号</span><br><span class="line">    private string lastReview;       //最后一次排错时间</span><br><span class="line">    private string message;          //描述</span><br><span class="line">    public DebugInfo(int iNo, String sLR, String sMsg)</span><br><span class="line">    &#123;</span><br><span class="line">        bugNo = iNo;</span><br><span class="line">        lastReview = sLR;</span><br><span class="line">        message = sMsg;</span><br><span class="line">    &#125;</span><br><span class="line">    public int BugNo</span><br><span class="line">    &#123;</span><br><span class="line">        get &#123; return bugNo; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public String LastReview</span><br><span class="line">    &#123;</span><br><span class="line">        get &#123; return lastReview; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public String Message</span><br><span class="line">    &#123;</span><br><span class="line">        get &#123; return message; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[DebugInfo(17, &quot;22/04/2019&quot;, &quot;fx&quot;)]</span><br><span class="line">[DebugInfo(16, &quot;18/04/2019&quot;, &quot;fx&quot;)]</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    [DebugInfo(17, &quot;22/04/2019&quot;, &quot;fx&quot;)]</span><br><span class="line">    void Method1()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    [DebugInfo(16, &quot;18/04/2019&quot;, &quot;fx&quot;)]</span><br><span class="line">    public void Method2()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Type type = typeof(Test);</span><br><span class="line">        ///1、遍历类Test的特性</span><br><span class="line">        foreach (Object obj in type.GetCustomAttributes(false))</span><br><span class="line">        &#123;</span><br><span class="line">            DebugInfo dbInfo = (DebugInfo)obj;</span><br><span class="line">            if(dbInfo != null)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;bug no: &#123;0&#125;&quot;, dbInfo.BugNo);</span><br><span class="line">                Console.WriteLine(&quot;last review: &#123;0&#125;&quot;, dbInfo.LastReview);</span><br><span class="line">                Console.WriteLine(&quot;message: &#123;0&#125;&quot;, dbInfo.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ///2、遍历Test类中方法的特性</span><br><span class="line">        foreach(MethodInfo mi in type.GetMethods())</span><br><span class="line">        &#123;</span><br><span class="line">            foreach (Object obj in mi.GetCustomAttributes(false))</span><br><span class="line">            &#123;</span><br><span class="line">                DebugInfo dbInfo = (DebugInfo)obj;</span><br><span class="line">                if (dbInfo != null)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;bug no: &#123;0&#125;&quot;, dbInfo.BugNo);</span><br><span class="line">                    Console.WriteLine(&quot;last review: &#123;0&#125;&quot;, dbInfo.LastReview);</span><br><span class="line">                    Console.WriteLine(&quot;message: &#123;0&#125;&quot;, dbInfo.Message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用反射查看类型信息   </p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Type t = Type.GetType(&quot;System.String&quot;);</span><br><span class="line">        ///获取所有成员(构造函数、 事件、 字段、 方法和属性)信息</span><br><span class="line">        foreach (MemberInfo mi in t.GetMembers())</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(mi.Name);</span><br><span class="line">        &#125;</span><br><span class="line">        ///获取所有成员方法信息</span><br><span class="line">        foreach (MethodInfo mi in t.GetMethods())</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(mi.Name);</span><br><span class="line">        &#125;</span><br><span class="line">        //......</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用反射获取及调用构造方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    string str = string.Empty;</span><br><span class="line">    private Test()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public Test(string str)</span><br><span class="line">    &#123;</span><br><span class="line">        this.str = str;</span><br><span class="line">    &#125;</span><br><span class="line">    public void Method()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Type t = typeof(Test);</span><br><span class="line">        //根据构造函数的参数类型获取构造函数，为空的话传入 Type.EmptyTypes;</span><br><span class="line">        Type[] para = new Type[1];</span><br><span class="line">        para[0] = typeof(string);</span><br><span class="line">        //获取有一个string参数的公有构造函数</span><br><span class="line">        ConstructorInfo ct = t.GetConstructor(para);</span><br><span class="line">        //构造Object数组，作为传入的参数组合（无参设置为null）</span><br><span class="line">        object[] ojbs = new object[1] &#123; &quot;fx&quot; &#125;;</span><br><span class="line">        //调用构造函数创建对象</span><br><span class="line">        if(ct != null)</span><br><span class="line">        &#123;</span><br><span class="line">            object test = ct.Invoke(ojbs);</span><br><span class="line">            ((Test)test).Method();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获取无参数的私有构造函数</span><br><span class="line">        ConstructorInfo _ct = t.GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic, </span><br><span class="line">            null, Type.EmptyTypes, null);</span><br><span class="line">        if(_ct != null)</span><br><span class="line">        &#123;</span><br><span class="line">            object test = _ct.Invoke(null);</span><br><span class="line">            ((Test)test).Method();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ///使用Activator生成对象</span><br><span class="line">        Object theObj2 = Activator.CreateInstance(t, &quot;fx&quot;);   //调用有参构造函数</span><br><span class="line">        ((Test)theObj2).Method();</span><br><span class="line">        //调用 私有 无参构造函数                          </span><br><span class="line">        Object theObj3 = Activator.CreateInstance(t, true);</span><br><span class="line">        ((Test)theObj3).Method();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BindingFlags是一个枚举类型，常用枚举值如下：   </p><ul><li>BindingFlags.Public ： 指定公开成员将被包含在搜索中</li><li>BindingFlags.Static ：指定静态成员将被包含在搜索中</li><li>BindingFlags.NonPublic：指定非公开成员将被包含在搜索中</li><li>BindingFlags.Instance ：指定实例成员将被包含在搜索中</li></ul><p>其它（方法、字段、属性等）的操作与此类似：   </p><ul><li>MemberInfo类是用来获取所有成员 （构造函数、 事件、 字段、 方法和属性） 的类的相关信息的类的抽象基类。</li><li>使用Assembly定义和加载程序集，加载在程序集清单中列出模块，以及从此程序集中查找类型并创建该类型的实例。    </li><li>使用Module了解包含模块的程序集以及模块中的类等，还可以获取在模块上定义的所有全局方法或其他特定的非全局方法。    </li><li>使用ConstructorInfo了解构造函数的名称、参数、访问修饰符（如pulic 或private）和实现详细信息（如abstract或virtual）等。    </li><li>使用MethodInfo了解方法的名称、返回类型、参数、访问修饰符（如pulic 或private）和实现详细信息（如abstract或virtual）等。   </li><li>使用FiedInfo了解字段的名称、访问修饰符（如public或private）和实现详细信息（如static）等，并获取或设置字段值。   </li><li>使用EventInfo了解事件的名称、事件处理程序数据类型、自定义属性、声明类型和反射类型等，添加或移除事件处理程序。    </li><li>使用PropertyInfo了解属性的名称、数据类型、声明类型、反射类型和只读或可写状态等，获取或设置属性值。    </li><li>使用ParameterInfo了解参数的名称、数据类型、是输入参数还是输出参数，以及参数在方法签名中的位置等。   </li></ul><p><strong>反射的优缺点:</strong></p><ul><li><p>优点：</p><ol><li>反射提高了程序的灵活性和扩展性。</li><li>降低耦合性，提高自适应能力。</li><li>它允许程序创建和控制任何类的对象，无需提前硬编码目标类。</li></ol></li><li><p>缺点：</p><ol><li>性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。</li><li>使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。</li></ol></li></ul><p>关于反射的使用，这里只做简单的介绍，深入学习的话请访问<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/reflection" target="_blank" rel="noopener">反射(c#)</a>编程指南.</p><h1 id="c-属性（Property）"><a href="#c-属性（Property）" class="headerlink" title="c#属性（Property）"></a>c#属性（Property）</h1><blockquote><p>定义：属性是一种成员，它提供灵活的机制来读取、写入或计算私有字段的值。 属性可用作公共数据成员，但它们实际上是称为访问器的特殊方法。 这使得可以轻松访问数据，还有助于提高方法的安全性和灵活性。</p></blockquote><p>访问器包括get和set，通过get来返回某个字段的值，在set中，使用关键字value为某个字段进行赋值。属性中至少有一个访问器，可以只有一个get或set访问器，或者既有get又有set访问器。<br>可以用访问限制修饰符修饰访问器，不过限制级别要大于属性的限制修饰符。   </p><ul><li>限制级别：private &gt; internal和protected &gt; public</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    //字段</span><br><span class="line">    private int field;              </span><br><span class="line">    //属性</span><br><span class="line">    public int Field &#123;</span><br><span class="line">        get &#123; return field; &#125;</span><br><span class="line">        set &#123; field = value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Test test = new Test();</span><br><span class="line">        //通过属性为field赋值</span><br><span class="line">        test.Field = 66; </span><br><span class="line">        //通过属性获取字段field的值</span><br><span class="line">        Console.WriteLine(&quot;Test.field：&#123;0&#125;&quot;, test.Field);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在一些情况下，属性 get 和 set 访问器仅为<strong>支持字段</strong>赋值或仅从其中检索值，而没有其它附加逻辑。 这是，通过使用自动实现的属性，既能简化代码，还能让 C# 编译器透明地提供<strong>支持字段</strong>（即我们不用显示声明字段了）。   </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    //自动属性</span><br><span class="line">    public int Pro &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Test test = new Test();</span><br><span class="line">        test.Pro = 66; </span><br><span class="line">        Console.WriteLine(&quot;Test.Pro：&#123;0&#125;&quot;, test.Pro);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深入学习请访问：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/properties" target="_blank" rel="noopener">属性(c#)</a></p><h1 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h1><blockquote><p>定义：索引器允许类或结构的实例像数组一样进行索引。 无需显式指定类型或实例成员，即可设置或检索索引值。 类似于属性，不同之处在于索引器的的访问器需要使用参数。</p></blockquote><p>下面是一个简单索引器的使用案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class collection</span><br><span class="line">&#123;</span><br><span class="line">    static int Count = 100;</span><br><span class="line">    private string[] arr = new string[Count];</span><br><span class="line"></span><br><span class="line">    public string this[int i]</span><br><span class="line">    &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            if(i &gt;= 0 &amp;&amp; i &lt; 100)</span><br><span class="line">                return arr[i];</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            if (i &gt;= 0 &amp;&amp; i &lt; 100)</span><br><span class="line">                arr[i] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        var stringCollection = new collection();</span><br><span class="line">        stringCollection[0] = &quot;fx&quot;;</span><br><span class="line">        Console.WriteLine(stringCollection[0]);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们可以在泛型类中来使用索引器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class SampleCollection&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">   private T[] arr = new T[100];</span><br><span class="line"></span><br><span class="line">   public T this[int i]</span><br><span class="line">   &#123;</span><br><span class="line">      get &#123; return arr[i]; &#125;</span><br><span class="line">      set &#123; arr[i] = value; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">   static void Main()</span><br><span class="line">   &#123;</span><br><span class="line">      var stringCollection = new SampleCollection&lt;string&gt;();</span><br><span class="line">      stringCollection[0] = &quot;Hello, World&quot;;</span><br><span class="line">      Console.WriteLine(stringCollection[0]);</span><br><span class="line">  Console.ReadKey();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>索引器也可以被重载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class collection</span><br><span class="line">&#123;</span><br><span class="line">    private string[] arr = new string[100];</span><br><span class="line"></span><br><span class="line">    public string this[int i]</span><br><span class="line">    &#123;</span><br><span class="line">        get &#123; return arr[i]; &#125;</span><br><span class="line">        set &#123; arr[i] = value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //重载索引器</span><br><span class="line">    public int this[string val]</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            int index = 0;</span><br><span class="line">            while (index &lt; 100)</span><br><span class="line">            &#123;</span><br><span class="line">                if (arr[index] == val)</span><br><span class="line">                &#123;</span><br><span class="line">                    return index;</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        var stringCollection = new collection();</span><br><span class="line">        stringCollection[0] = &quot;fx&quot;;</span><br><span class="line">        Console.WriteLine(stringCollection[0]);</span><br><span class="line">        Console.WriteLine(stringCollection[&quot;fx&quot;]);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于更多请访问<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/indexers/index" target="_blank" rel="noopener">索引器(c#)</a></p><h1 id="c-委托与事件"><a href="#c-委托与事件" class="headerlink" title="c#委托与事件"></a>c#委托与事件</h1><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><blockquote><p>定义：委托是一种引用类型，表示对具有特定参数列表和返回类型的方法的引用。 在实例化委托时，你可以将其实例与任何具有兼容参数和返回类型的方法相关联。 并能通过委托实例调用方法。</p></blockquote><p>委托具有以下属性： </p><ul><li>委托类似于 C++ 函数指针，但委托完全面向对象，不像 C++ 指针会记住函数，委托会同时封装对象   + 实例和方法。   </li><li>委托允许将方法作为参数进行传递。   </li><li>委托可用于定义回调方法。   </li><li>委托可以链接在一起；例如，可以对一个事件调用多个方法。    </li></ul><p>声明一个委托：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public delegate int DgName(int para1, string para2);</span><br></pre></td></tr></table></figure><p>实例化委托并简单使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    public delegate int DgName(int para1); </span><br><span class="line">    public int Method(int para1)</span><br><span class="line">    &#123;</span><br><span class="line">        return para1 / 2;</span><br><span class="line">    &#125;</span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        Program pro = new Program();</span><br><span class="line">        //实例化一个委托myDg</span><br><span class="line">        DgName myDg = pro.Method;</span><br><span class="line">        //通过委托调用pro.Method</span><br><span class="line">        Console.WriteLine(myDg(66));            //33</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面说过，委托允许将方法作为参数进行传递，因此，我们还可以这样使用委托。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class PrintString</span><br><span class="line">&#123;</span><br><span class="line">    // 委托声明</span><br><span class="line">    public delegate void DgName(string s);</span><br><span class="line"></span><br><span class="line">    public static void WriteToScreen(string str)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;The String is: &#123;0&#125;&quot;, str);</span><br><span class="line">    &#125;</span><br><span class="line">    // 该方法把委托作为参数，并使用它调用方法</span><br><span class="line">    public static void sendString(DgName ps)</span><br><span class="line">    &#123;</span><br><span class="line">        ps(&quot;Hello World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">//可以这样实例化委托变量</span><br><span class="line">        DgName ps1 = new DgName(WriteToScreen);</span><br><span class="line">        sendString(ps1);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>委托对象可使用加法赋值运算符（“+”或“+=”）进行合并。一个<strong>合并委托</strong>调用它所合并的两个委托。只有相同类型的委托可被合并。<br>使用委托的这个有用的特点，您可以创建一个委托被调用时要调用的方法的调用列表。这被称为委托的多播（multicasting），也叫组播。 若要删除调用列表中的方法，使用减法运算符或减法赋值运算符（“-”或“-=”）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    public delegate void Dlg();</span><br><span class="line"></span><br><span class="line">    public static void DogCry()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;汪汪汪~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void CatCry()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;喵喵~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void SheepCry()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;咩 ~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void AnimalCry(Dlg dlg)</span><br><span class="line">    &#123;</span><br><span class="line">        dlg();</span><br><span class="line">    &#125;</span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        Dlg dlg =DogCry;</span><br><span class="line">        dlg += CatCry;</span><br><span class="line">        Dlg anoDlg = new Dlg(SheepCry);</span><br><span class="line">        dlg = dlg + anoDlg;</span><br><span class="line">        AnimalCry(dlg);</span><br><span class="line">        /**</span><br><span class="line">         * 输出：</span><br><span class="line">         * 汪汪汪~</span><br><span class="line">         * 喵喵~</span><br><span class="line">         * 咩 ~</span><br><span class="line">         */</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多请访问<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/delegates/" target="_blank" rel="noopener">委托(c#)</a></p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><blockquote><p>定义：类或对象可以通过事件向其他类或对象通知发生的相关事情。 发送（或 引发）事件的类称为“发行者（发布器）” ，接收（或 处理）事件的类称为“订户（订阅器）” 。   </p></blockquote><ul><li>发布器（publisher） 是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器类的对象调用这个事件，并通知其他的对象。   </li><li>订阅器（subscriber） 是一个接受事件并提供事件处理程序的对象。在发布器（publisher）类中的委托调用订阅器类中的方法（事件处理程序）。    </li></ul><p>由上面的定义可以看出，事件，实际上就是.Net对<a href="https://syfx.github.io/2019/03/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">观察这模式</a>的应用。</p><p>在类中声明事件之前，必须要先声明用于该事件的委托。例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public delegate void Cry();</span><br><span class="line">//基于委托声明事件</span><br><span class="line">public event Cry MouseRun;</span><br></pre></td></tr></table></figure><p>编写一个实例：当老鼠跑时，狗叫，猫叫并追赶老鼠；因为在这个设计模型中，当老鼠跑时要通知猫追赶它，通知狗叫，因此老鼠类就是“发布器”，狗类和猫类就是“订阅器”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace StudyNotes</span><br><span class="line">&#123;</span><br><span class="line">    //；老鼠类</span><br><span class="line">    class Mouse</span><br><span class="line">    &#123;</span><br><span class="line">        public delegate void Cry();</span><br><span class="line">        //基于委托声明事件</span><br><span class="line">        public event Cry MouseRun;</span><br><span class="line"></span><br><span class="line">        //老鼠跑</span><br><span class="line">        public void Run()</span><br><span class="line">        &#123;</span><br><span class="line">            //向“订阅器”发送消息</span><br><span class="line">            MouseRun();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //狗类</span><br><span class="line">    class Dog</span><br><span class="line">    &#123;</span><br><span class="line">        public void Cry()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;狗：猫赶紧抓老鼠去！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //猫类</span><br><span class="line">    class Cat</span><br><span class="line">    &#123;</span><br><span class="line">        public void RunAndCry()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;猫：小老鼠，哪里跑！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main()</span><br><span class="line">        &#123;</span><br><span class="line">            Mouse mouse = new Mouse();</span><br><span class="line">            Dog dog = new Dog();</span><br><span class="line">            Cat cat = new Cat();</span><br><span class="line">            //猫和狗“订阅”老鼠的跑事件</span><br><span class="line">            mouse.MouseRun += dog.Cry;</span><br><span class="line">            mouse.MouseRun += cat.RunAndCry;</span><br><span class="line">            //老鼠跑事件发生</span><br><span class="line">            mouse.Run();</span><br><span class="line">            /**</span><br><span class="line">             * 输出：</span><br><span class="line">             * 狗：猫赶紧抓老鼠去！</span><br><span class="line">             * 猫：小老鼠，哪里跑！</span><br><span class="line">             * */</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟多关于<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/events/index" target="_blank" rel="noopener">事件(c#)</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET与c#</title>
      <link href="/2019/04/19/NET%E4%B8%8Ec/"/>
      <url>/2019/04/19/NET%E4%B8%8Ec/</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是-NET"><a href="#一、什么是-NET" class="headerlink" title="一、什么是.NET"></a>一、什么是.NET</h3><p>.NET是一个微软搭造的开发者平台，它主要包括：   </p><ol><li>支持(面向)该平台的编程语言(如C#、Visual Basic、C++/CLI、F#、IronPython、IronRuby…)   </li><li>用于该平台下开发人员的技术框架体系(<strong>即 .NET实现</strong>)   </li><li>用于支持开发人员开发的软件工具(即SDK，如VS2017、VS Code等)   </li></ol><blockquote><ul><li>.NET实现<br>Microsoft 积极开发和维护的主要 .NET实现 有4个：.NET Framework、.NET Core、Mono 和 UWP。<br>每个 .NET实现 都具有以下组件：<ol><li>一个或多个运行时。    <ul><li>.NET运行时<br>  运行时是用于托管程序的执行环境。 操作系统属于运行时环境，但不属于 .NET 运行时。 下面是 .NET 运行时的一些示例：<ul><li>.NET Framework 公共语言运行时 (CLR)</li><li>.NET Core 核心公共语言运行时 (CoreCLR)</li><li>适用于通用 Windows 平台的 .NET Native</li><li>用于 Xamarin.iOS、Xamarin.Android、Xamarin.Mac 和 Mono 桌面框架的 Mono 运行时</li></ul></li></ul></li><li>实现 .NET Standard 并且可实现其他 API 的类库。 示例：.NET Framework 基类库、.NET Core 基类库。  <ul><li>.NET Standard<br>  .NET Standard 是一组所有 .NET 平台都应实现的 API。 更正式地说，它是构成协定统一集（这些协定是编写代码的依据）的特定 .NET API 组。 这些协定在每个 .NET实现 中实现。 这可实现不同 .NET实现 间的可移植性，有效地使代码可在任何位置运行。  </li></ul></li><li>可选择包含一个或多个应用程序框架。 示例：ASP.NET、Windows 窗体…(包含在 .NET Framework 中)</li><li>可包含开发工具。 某些开发工具在多个实现之间共享。   </li></ol></li></ul></blockquote><h4 id="NET架构结构"><a href="#NET架构结构" class="headerlink" title=".NET架构结构"></a>.NET架构结构</h4><p><img src="http://p.qpic.cn/pic_wework/1948211503/e9efe5f95612423a370ff2bd921d91a831e60fed1ac22fa4/0" alt=""></p><h4 id="1、CTS-通用类型系统-Common-Type-System"><a href="#1、CTS-通用类型系统-Common-Type-System" class="headerlink" title="1、CTS-通用类型系统(Common Type System)"></a>1、CTS-通用类型系统(Common Type System)</h4><blockquote><p>.NET实现对语言不可知。 <strong>这意味着程序员可以使用可编译为 IL 的任意语言进行编写代码。而且这些通过不同语言进行编写的代码进行交互(即跨语言操作)</strong>。   </p><blockquote><p>跨语言操作：比如，c#和vb是.NET下两个不同的语言，不过在c#中写的类可以在vb中当做自家写的类一样正常使用。   </p></blockquote><p>为透明地执行此操作，必须使用某种通用方式描所有受支持类型。 这正是 CTS 的职责。 其功能如下：      </p><ul><li>建立用于跨语言执行的框架。   </li><li>提供面向对象的模型，支持在 .NET 实现上实现各种语言。   </li><li>定义处理类型时所有语言都必须遵守的一组规则。   </li><li>提供包含应用程序开发中使用的基本基元数据类型（如 Boolean、Byte、Char 等）的库。  </li></ul></blockquote><h4 id="2、CLS-公共语言规范-Common-Language-Specification"><a href="#2、CLS-公共语言规范-Common-Language-Specification" class="headerlink" title="2、CLS-公共语言规范(Common Language Specification)"></a>2、CLS-公共语言规范(Common Language Specification)</h4><blockquote><p>为实现完全互操作性情景，代码中创建的所有对象都必须依赖于使用它的语言（即其调用方）的某些共性。 由于存在多种不同语言，因此 .NET 在公共语言规范 (CLS) 中指定了这些共性。然后定义了一组规则，开发者都遵守这个规则来编码，那么代码就能被任意.NET平台支持的语言所通用。<br>而与其说是规则，不如说它是一组语言互操作的标准规范，这就是CLS。</p><blockquote><p>注意：<strong>CLS 遵从性的规则仅适用于组件的公共接口，而非其私有实现。</strong></p></blockquote></blockquote><h4 id="3、CLR-公共语言运行-时-或库-Common-Language-Runtime"><a href="#3、CLR-公共语言运行-时-或库-Common-Language-Runtime" class="headerlink" title="3、CLR-公共语言运行 时(或库)(Common Language Runtime)"></a>3、CLR-公共语言运行 时(或库)(Common Language Runtime)</h4><blockquote><p>这里指的是 .NET Framework 的运行时。<br>可以将CLR看成一个在 执行时 <strong>管理代码</strong> 的代理（<strong>托管代码</strong>），它提供核心服务（如内存管理（GC）、线程管理和远程处理），而且还强制实施严格的类型安全以及可确保安全性和可靠性的其他形式的代码准确性。事实上，代码管理的概念是 运行时 的基本原则。</p><blockquote><p>托管：以垃圾回收器（GC）为例，在c#中，内存分配和释放的工作本应该是我们做的，现在这些工作却让GC帮你做了，这就是“托管”的概念。<br>因此，C#被称为托管语言。C#编写的代码也就称为托管代码,C#生成的模块称为托管模块等。<br>从这个角度来看，那些脱离了.NET提供的诸如垃圾回收器这样的环境管制，就是对应的 非托管了。</p></blockquote><p>CLR管理内存、线程执行、代码执行、代码安全验证、编译以及其他系统服务。这些功能是在CLR上运行的托管代码所固有的。这套环境及体系之完善，以至于就像一个小型的系统一样，所以通常形象的称CLR为”.NET虚拟机”。</p></blockquote><h4 id="NET程序的编译执行"><a href="#NET程序的编译执行" class="headerlink" title=".NET程序的编译执行"></a>.NET程序的编译执行</h4><blockquote><ul><li>对于用非托管语言(c/c++)编写的程序源代码，编译时翻译器将源码翻译为本地 机器语言，以文件形式保存在硬盘上；运行时，操作系统将文件读出到内存，然后CPU从内存中取出指令执行。    </li><li>对于托管代码，编译时将源码翻译为微软中间语言（IL）代码，运行的时候通过JIT（即时编译器）翻译为本地机器语言，同时.NET代码运行时有一个CLR环境来管理程序。   <blockquote><p>翻译器与解释器：   </p><ul><li>在编译时<strong>翻译器</strong>将源代码翻译成机器语言保存到文件中（例如C/C++）；执行效率高，不过难以移植。   </li><li>在运行时<strong>解释器</strong>对源代码逐行进行翻译和执行（例如Python）；执行效率较低，不过易于移植。   </li></ul></blockquote></li></ul></blockquote><p><img src="http://p.qpic.cn/pic_wework/1948211503/01070d1133a261b41edd9346720be2c008e98d1b93db163c/0" alt="">   </p><h3 id="二、C-简介"><a href="#二、C-简介" class="headerlink" title="二、C#简介"></a>二、C#简介</h3><h4 id="1、-C-及其特点"><a href="#1、-C-及其特点" class="headerlink" title="1、 C#及其特点"></a>1、 C#及其特点</h4><blockquote><p>C#是微软公司在2000年7月发布的一种全新且<strong>简单、安全、面向对象</strong>的程序设计语言，是专门为.NET的应用而开发的语言。它吸收了C++、Visual Basic、Delphi、Java等语言的优点，体现了当今最新的程序设计技术的功能和精华。C#继承了C语言的语法风格，同时又继承了C++的面向对象特性。不同的是，C#的对象模型已经面向Internet进行了重新设计，使用的是.NET框架的类库；<strong>C#不再提供对指针类型的支持，使得程序不能随便访问内存地址空间，从而更加健壮；C#不再支持 多重继承，避免了以往类层次结构中由于多重继承带来的可怕后果</strong>。.NET框架为C#提供了一个强大的、易用的、逻辑结构一致的程序设计环境。同时，公共语言运行时（Common Language Runtime）为C#程序语言提供了一个托管的运行时环境，使程序比以往更加稳定、安全。<br>总结一下，c#特点有：    </p><ul><li>语言简洁。   </li><li>保留了C++的强大功能。   </li><li>快速应用开发功能。   </li><li>语言的自由性。   </li><li>强大的Web服务器控件。   </li><li>支持跨平台。   </li><li>与XML相融合。   </li></ul></blockquote><h4 id="2、-c-存在哪些缺点呢？"><a href="#2、-c-存在哪些缺点呢？" class="headerlink" title="2、 c#存在哪些缺点呢？"></a>2、 c#存在哪些缺点呢？</h4><blockquote><ul><li>不适合开发高性能的程序：因为中间语言和编译过程，比C/C++等语言会慢一些，还有就是内存自动回收机制导致难以立即释放不需要的内存，不采用(不建议)内联函数和析构函数。   </li><li>Windows平台以外支持有限： 因为除Windows外，还没有其他操作系统上的稳定版本的.Net Framework环境，提供给.Net 程序来运行。</li></ul></blockquote><h4 id="3、-c-与其它语言的比较"><a href="#3、-c-与其它语言的比较" class="headerlink" title="3、 c#与其它语言的比较"></a>3、 c#与其它语言的比较</h4><blockquote><ul><li>C#与C++的比较      <ul><li>编译目标：C++代码直接编译为本地可执行代码，而C#默认编译为中间语言（IL）代码，执行时再通过Just-In-Time将需要的模块临时编译成本地代码。   </li><li>内存管理：C++需要显式地删除动态分配给堆的内存，而C#不需要这么做，C#采用垃圾回收机制自动在合适的时机回收不再使用的内存。   </li><li>指针：C++中大量地使用指针，而C#使用对类实例的引用，如果确实想在C#中使用指针，必须声明该内容是非安全的。不过，一般情况下C#中没有必要使用指针。   </li><li>字符串处理：在C#中，字符串是作为一种基本数据类型来对待的，因此比C++中对字符串的处理要简单得多。   </li><li>库：C++依赖于以继承和模板为基础的标准库，C#则依赖于.NET基库。</li><li>C++允许类的多继承，而C#只允许类的单继承，而通过接口实现多继承。</li></ul></li><li>C#与Java的比较<ul><li>C#面向对象的程度比Java高。   </li><li>C#中的基本类型都是面向对象的。   </li><li>C#具有比Java更强大的功能。   </li><li>C#语言的执行速度比Java快。</li></ul></li></ul></blockquote><h4 id="4、值类型与引用类型，装箱与拆箱"><a href="#4、值类型与引用类型，装箱与拆箱" class="headerlink" title="4、值类型与引用类型，装箱与拆箱"></a>4、值类型与引用类型，装箱与拆箱</h4><blockquote><ul><li>在c#中，<strong>值类型</strong>的变量直接储存数据，数据存在栈中，执行复制操作时，复制了一个新的数据给另一个变量，两个数据相互独立；而<strong>引用类型</strong>持有的是数据的引用，在栈上开辟一小块内存储存一个地址，地址指向堆中实际储存数据的内存（相当于c++中的指针，只是c#做了一些工作使这个指针与它指向的对象更紧密的联系在一起了）。   </li><li>数据从值类型转换为引用类型的过程被称为<strong>“装箱”</strong>，从引用类型转换为值类型的过程被称为<strong>“拆箱”</strong>。装箱与拆箱操作比较费时，应该尽量避免装箱拆箱操作。</li></ul></blockquote><p><strong>值类型与引用类型的分类</strong><br><img src="http://p.qpic.cn/pic_wework/1948211503/fafcf6eaab4a7774885510cc4dd684254710f43750315fcb/0" alt=""></p><p>.NET中六个重要的概念：栈、堆、值类型、引用类型、装箱和拆箱：<br><a href="https://www.cnblogs.com/edisonchou/p/3947170.html" target="_blank" rel="noopener">https://www.cnblogs.com/edisonchou/p/3947170.html</a>   </p><p>什么是.NET：<br><a href="https://www.cnblogs.com/1996V/p/9037603.html#net3" target="_blank" rel="noopener">https://www.cnblogs.com/1996V/p/9037603.html#net3</a></p><p><strong>注：</strong>图片来自网上</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NET </tag>
            
            <tag> c# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路径算法Floyd与Dijkstra</title>
      <link href="/2019/04/17/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95Floyd%E4%B8%8EDijkstra/"/>
      <url>/2019/04/17/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95Floyd%E4%B8%8EDijkstra/</url>
      
        <content type="html"><![CDATA[<h3 id="一、弗洛伊德算法（Floyd）"><a href="#一、弗洛伊德算法（Floyd）" class="headerlink" title="一、弗洛伊德算法（Floyd）"></a>一、弗洛伊德算法（Floyd）</h3><blockquote><p>Floyd算法的思想比较简单，它的核心代码只有5行；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; G.vCount; ++k)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vCount; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vCount; ++j)</span><br><span class="line"><span class="keyword">if</span> (G.arcs[i][j] &gt; G.arcs[i][k] + G.arcs[k][j])</span><br><span class="line">G.arcs[i][j] = G.arcs[i][k] + G.arcs[k][j];</span><br></pre></td></tr></table></figure><p> 对于一个有向图G：<br> <img src="http://p.qpic.cn/pic_wework/1948211503/c8cec3d80ab6b3b9e5d697e65a4cfbf9f23b6b3a2a6272f0/0" alt=""></p><blockquote><p>我们可以认为当前二维数组中的值表示的是两个顶点之间的直接路径长度（即中间不经过其它顶点进行中转时的路径）。这个直接路径并不一定是最短路径。<br>例如：G[1][3] = 6表示从1到3的直接路径长度为6，当我们引入2号顶点作为中转点时，（即先从顶点1走到顶点2，再从顶点2走到顶点3），从顶点1到3的路径长度可以更短，为G[1][2] + G[2][3] = 5;</p></blockquote><p><strong>上述思想的代码实现非常简单：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; G.vCount; ++k) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vCount; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vCount; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (G.arcs[i][j] &gt; G.arcs[i][k] + G.arcs[k][j])</span><br><span class="line">G.arcs[i][j] = G.arcs[i][k] + G.arcs[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"任意两点间的最短距离为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//打印最终结果</span></span><br><span class="line">ShowGraph(G);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这段代码中，最外层的循环用来控制当前允许经过哪个点进行中转。内层的两个循环表示<strong>当经过此中转点时一个顶点到其他所有顶点的距离是否能更短</strong>，若能更短，则更新最短距离。用一句话概括就是：<strong>从i号顶点到j号顶点只经过前k号顶点的最短路径</strong>(比如当要经过k-1顶点进行中转时，图中的储存的路径已经是经过前k-1号顶点时的最短路径了)，这其实是一种“动态规划”的思想（可以根据 <strong>斐波那契数列</strong> 想象一下这个思想）。</p></blockquote><p>由代码不难看出，Floyd算法的时间复杂度为O(n^3),因为要储存两两顶点间的最短路径，所以空间复杂度为O(n^2)（我在这里没有使用辅助空间，直接在原图中进行操作了）。</p><h3 id="二、迪杰斯特拉算法（Dijkstra）"><a href="#二、迪杰斯特拉算法（Dijkstra）" class="headerlink" title="二、迪杰斯特拉算法（Dijkstra）"></a>二、迪杰斯特拉算法（Dijkstra）</h3><blockquote><p>Dijkstra算法是一种“单源最短路径算法”（求一个顶点(源点)到其余各个顶点的最短路径），它是一种采用<strong>贪婪策略</strong>（在对问题求解时，总是做出在当前看来是最好的选择）实现的算法。 </p></blockquote><p> 对于有向图G：<br><img src="http://p.qpic.cn/pic_wework/1948211503/c8cec3d80ab6b3b9e5d697e65a4cfbf9f23b6b3a2a6272f0/0" alt=""></p><blockquote><p>在算法中，我们声明一个dis数组用来储存源点到其余顶点的的最短路径的“预估值”。以0号顶点为源点，有：    </p></blockquote><p><img src="http://p.qpic.cn/pic_wework/1948211503/d4d2dfc447ed7b3a3f9b73c399bc945848a023b66c121091/0" alt=""></p><blockquote><p>在dis表中选择到源点“预估值”最小的顶点（不包括源点本身），为dis[1] = 2;选择1号顶点后，dis[1]的值就可以从“预估值”变成“确定值”了；为什么呢？因为目前到源点最近的顶点为1号顶点，且图中边的权重都是正数（此算法不适用于带负权图），因此，不可能找到一个中转点使得从源点到1号顶点的路径更短。<br>这样的话，我们就还需要使用一个数组book来标记源点到当前点的最短路径是否为确定值（一般使用两个列表来分别储存“预估值”与“确定值”）。     </p></blockquote><p><img src="http://p.qpic.cn/pic_wework/1948211503/b4b2bfa455b687c5b64bc652096a40a12dab663aab792e89/0" alt=""></p><blockquote><p>确定源点到1号顶点的最短路径之后，我们对1号顶点的所有出边进行松弛：对于1号顶点，有一条出边1-&gt;2，我们讨论当通过1号顶点进行中转时，源点到2号顶点的路径是否能更短，即比较dis[2]与dis[1] + G[1][2]的大小，如果更短，则更新dis[2]的值。这一过程称为边的松弛。<br>对1号顶点的所有出边松弛完毕后，继续在“预估值”中选取最小的值执行边松弛操作，直到所有“预估值”变为“确定值”。</p></blockquote><p><strong>代码实现如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Graph G, <span class="keyword">int</span> origin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//dis：储存源点到其它点的最短距离，book：用来做标记，标记到当前点到源点的最短距离是否已被确定</span></span><br><span class="line"><span class="keyword">int</span> *dis = <span class="keyword">new</span> <span class="keyword">int</span>[G.vCount], *book = <span class="keyword">new</span> <span class="keyword">int</span>[G.vCount];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>, s = <span class="number">0</span>, min = MaxInt;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vCount; ++i) &#123;</span><br><span class="line"><span class="comment">//GetSub(G,origin)：获取源点在顶点表中的下标</span></span><br><span class="line">s = GetSub(G, origin);</span><br><span class="line">dis[i] = G.arcs[s][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化标记</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vCount; ++i) &#123;</span><br><span class="line">book[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置源点到源点的最短距离为已确定</span></span><br><span class="line">book[s] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//确定源点到dis表里的所有顶点的最短距离，算法核心</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; G.vCount; ++i) &#123;</span><br><span class="line">min = MaxInt;</span><br><span class="line"><span class="comment">//在未确定到源点最短距离的顶点中找到离源点最近的顶点</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; G.vCount; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (book[j] == <span class="number">0</span> &amp;&amp; dis[j] &lt; min) &#123;</span><br><span class="line">min = dis[j];</span><br><span class="line">s = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置s点到源点的最短距离为已知</span></span><br><span class="line">book[s] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//对当前顶点的出边进行松弛</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.vCount; ++k) &#123;</span><br><span class="line"><span class="comment">//判断下标为s的顶点到下标为k的顶点间是否存在边，若存在，对其进行松弛操作</span></span><br><span class="line"><span class="keyword">if</span> (G.arcs[s][k] &lt; MaxInt) &#123;</span><br><span class="line"><span class="keyword">if</span> (dis[k] &gt; dis[s] + G.arcs[s][k]) &#123;</span><br><span class="line">dis[k] = dis[s] + G.arcs[s][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印最短路径</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vCount; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"点"</span> &lt;&lt; origin &lt;&lt; <span class="string">"到"</span> &lt;&lt; G.vexs[i] &lt;&lt; <span class="string">"的最短距离为："</span> &lt;&lt; dis[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Dijkstra算法的时间复杂度为O(n^2)，在对算法的优化方面，可以使用最小堆在来实现查找最小“预估值”操作，若数据较多，且图为稀疏图时，通过邻接表来储存边，也能在一定程度上优化此算法的性能。</p></blockquote><p><strong>完整代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Num = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxInt = <span class="number">32767</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> vexs[Num];<span class="comment">//顶点表</span></span><br><span class="line"><span class="keyword">int</span> arcs[Num][Num];<span class="comment">//边表</span></span><br><span class="line"><span class="keyword">int</span> vCount;<span class="comment">//顶点数量</span></span><br><span class="line"><span class="keyword">int</span> aCount;<span class="comment">//边数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取值在顶点表中下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSub</span><span class="params">(Graph G, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vCount; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (G.vexs[i] == value)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建图（邻接矩阵）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatMap</span><span class="params">(Graph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t1, t2, w;</span><br><span class="line"><span class="comment">//输入顶点信息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vCount; ++i) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; G.vexs[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vCount; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vCount; ++j) &#123;</span><br><span class="line">G.arcs[i][j] = MaxInt;</span><br><span class="line"><span class="keyword">if</span> (i == j)</span><br><span class="line">G.arcs[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.aCount; ++i) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; w;</span><br><span class="line"><span class="keyword">int</span> s1 = GetSub(G, t1);</span><br><span class="line"><span class="keyword">int</span> s2 = GetSub(G, t2);</span><br><span class="line"><span class="keyword">if</span> (s1 != G.vCount &amp;&amp; s2 != G.vCount) &#123;</span><br><span class="line">G.arcs[s1][s2] = w;</span><br><span class="line"><span class="comment">//G.arcs[s2][s1] = w;//无向图</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowGraph</span><span class="params">(Graph G)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vCount; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vCount; ++j) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; G.arcs[i][j] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弗洛伊德算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; G.vCount; ++k) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vCount; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vCount; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (G.arcs[i][j] &gt; G.arcs[i][k] + G.arcs[k][j])</span><br><span class="line">G.arcs[i][j] = G.arcs[i][k] + G.arcs[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"任意两点间的最短距离为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//打印最终结果</span></span><br><span class="line">ShowGraph(G);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">迪杰斯特拉算法</span></span><br><span class="line"><span class="comment">G：图</span></span><br><span class="line"><span class="comment">origin：源点（起点）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Graph G, <span class="keyword">int</span> origin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//dis：储存源点到其它点的最短距离，book：用来做标记，标记到当前点到源点的最短距离是否已被确定</span></span><br><span class="line"><span class="keyword">int</span> *dis = <span class="keyword">new</span> <span class="keyword">int</span>[G.vCount], *book = <span class="keyword">new</span> <span class="keyword">int</span>[G.vCount];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>, s = <span class="number">0</span>, min = MaxInt;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vCount; ++i) &#123;</span><br><span class="line"><span class="comment">//GetSub(G,origin)：获取源点在顶点表中的下标</span></span><br><span class="line">s = GetSub(G, origin);</span><br><span class="line">dis[i] = G.arcs[s][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化标记</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vCount; ++i) &#123;</span><br><span class="line">book[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置源点到源点的最短距离为已确定</span></span><br><span class="line">book[s] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确定源点到dis表里的所有顶点的最短距离，算法核心</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; G.vCount; ++i) &#123;</span><br><span class="line">min = MaxInt;</span><br><span class="line"><span class="comment">//在未确定到源点最短距离的顶点中找到离源点最近的顶点</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; G.vCount; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (book[j] == <span class="number">0</span> &amp;&amp; dis[j] &lt; min) &#123;</span><br><span class="line">min = dis[j];</span><br><span class="line">s = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置s点到源点的最短距离为已知</span></span><br><span class="line">book[s] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//对当前顶点的出边进行松弛</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.vCount; ++k) &#123;</span><br><span class="line"><span class="comment">//判断下标为s的顶点到下标为k的顶点间是否存在边，若存在，对其进行松弛操作</span></span><br><span class="line"><span class="keyword">if</span> (G.arcs[s][k] &lt; MaxInt) &#123;</span><br><span class="line"><span class="keyword">if</span> (dis[k] &gt; dis[s] + G.arcs[s][k]) &#123;</span><br><span class="line">dis[k] = dis[s] + G.arcs[s][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印最短路径</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vCount; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"点"</span> &lt;&lt; origin &lt;&lt; <span class="string">"到"</span> &lt;&lt; G.vexs[i] &lt;&lt; <span class="string">"的最短距离为："</span> &lt;&lt; dis[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Graph G;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; G.vCount &gt;&gt; G.aCount;</span><br><span class="line">CreatMap(G);</span><br><span class="line">ShowGraph(G);</span><br><span class="line">Floyd(G);</span><br><span class="line">Dijkstra(G, <span class="number">0</span>);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10 13</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7  8 9</span></span><br><span class="line"><span class="comment">0 1 3</span></span><br><span class="line"><span class="comment">0 6 6</span></span><br><span class="line"><span class="comment">0 4 5</span></span><br><span class="line"><span class="comment">1 2 2 </span></span><br><span class="line"><span class="comment">1 9 9</span></span><br><span class="line"><span class="comment">2 3 1</span></span><br><span class="line"><span class="comment">3 6 3</span></span><br><span class="line"><span class="comment">4 5 3</span></span><br><span class="line"><span class="comment">5 6 2</span></span><br><span class="line"><span class="comment">6 7 2</span></span><br><span class="line"><span class="comment">6 9 3</span></span><br><span class="line"><span class="comment">7 8 6</span></span><br><span class="line"><span class="comment">8 9 8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 最短路径 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用排序算法</title>
      <link href="/2019/04/04/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/04/04/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h2><blockquote><p>常用算法分类</p></blockquote><p><img src="http://p.qpic.cn/pic_wework/1948211503/aaac57a57a48b9b14644657fdd9edc9ea7fe380cd2fc0316/0" alt=""></p><blockquote><p>常用算法性能分析</p></blockquote><p><img src="http://p.qpic.cn/pic_wework/1948211503/fdfb00f2ed8b878e504b553a62d32a0a37b1b041127d1e3b/0" alt=""><br><strong>后三个算法中的 k 表示桶的数量</strong></p><blockquote><p><strong>稳定/不稳定</strong>：若i&lt;j,a[i]=a[j],排完序后a[i]与a[j]的相对位置不发生变化(即仍然i&lt;j)，则称算法是稳定的，反之不稳定。这种特性在一些情况下还是有用的，例如对按学生姓名排好序的列表再按成绩排序时，可以保证成绩相同的学生是按照姓名排序的。<br><strong>在位</strong>：如果一个算法不需要额外的储存空间（除了个别储存单元外），我们把它称为是在位的。</p></blockquote><h3 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h3><blockquote><p><strong>冒泡排序的基本思想是：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。</strong><br>如果对n个数按从小到大排序的话，就要执行<strong>n-1</strong>趟“冒泡”操作，每执行一趟都将剩余列表中的最大值交换到最后。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="comment">//执行length-1趟"冒泡"操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line"><span class="comment">//在剩余数列中对满足条件的两个数执行交换操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>]) &#123;</span><br><span class="line">temp = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>冒泡排序是一种基于<strong>蛮力法</strong>的算法，因此在处理较多的数据时，使用冒泡排序显然不是一个好的选择。通过这样可以对冒泡排序的性能进行少许提升：<strong>若在一次循环中没有进行元素交换的操作，就表示列表已经有序，可以直接结束算法了。（这样最好情况下时间复杂度就是O(n)了）</strong></p></blockquote><h3 id="2、快速排序（Quick-Sort）"><a href="#2、快速排序（Quick-Sort）" class="headerlink" title="2、快速排序（Quick Sort）"></a>2、快速排序（Quick Sort）</h3><blockquote><p>快速排序是最常用的排序算法，它是基于二分思想（分治法）的一种排序，要求升序排列时；   </p><ol><li>在要排序的数列中找一个<strong>基准值（pivot）</strong>   </li><li>然后将数列中小于基准值的数放到基准值左边，大于基准值的数放到基准值的右边   </li><li>递归的对基准值左边和右边的数列执行上述步骤</li></ol></blockquote><ul><li><strong>对数列6 1 2 7 9 3 4 5 10 8执行1、2步骤图示：</strong><br>注意 j 先出发</li></ul><p><img src="http://p.qpic.cn/pic_wework/1948211503/95936b9a7523aa20e8865abe483f9edb9b569e0d2b88d22d/0" alt=""><br><img src="http://p.qpic.cn/pic_wework/1948211503/b7b149b8c08ca64c8596fc2000bb43870d29849da5b0c48c/0" alt=""><br><img src="http://p.qpic.cn/pic_wework/1948211503/b4b24abbe6212cbd83084f7fc5b618ed65b603308cd5bc16/0" alt=""><br><img src="http://p.qpic.cn/pic_wework/1948211503/93956d9c3576f77fc1431ef3e288c211f8643a5ed84ce2fc/0" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, t, temp;</span><br><span class="line"><span class="keyword">if</span> (left &gt; right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">temp = <span class="built_in">array</span>[left];<span class="comment">//设置基准值</span></span><br><span class="line">i = left;</span><br><span class="line">j = right;</span><br><span class="line"><span class="keyword">while</span> (i != j) &#123;</span><br><span class="line"><span class="comment">//先让 j--,因为基准值在最左边，先 j-- 可以保证 i，j 相遇处的值绝对小于基准值</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">array</span>[j] &gt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">j--;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">array</span>[i] &lt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">t = <span class="built_in">array</span>[i];</span><br><span class="line"><span class="built_in">array</span>[i] = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[left] = <span class="built_in">array</span>[i];</span><br><span class="line"><span class="built_in">array</span>[i] = temp;</span><br><span class="line">quicksort(<span class="built_in">array</span>, left, i - <span class="number">1</span>);<span class="comment">//排序基准值左边的数列</span></span><br><span class="line">quicksort(<span class="built_in">array</span>, i + <span class="number">1</span>, right);<span class="comment">//排序基准值右边的数列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>算法处理过程：</strong><br><img src="http://p.qpic.cn/pic_wework/1948211503/383ec6374f53a5adbb69f3894db5ede63256cf30883a84eb/0" alt=""></li></ul><blockquote><p>快速排序之所以比较快，是因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样只能在相邻的数之间进行交换，交换的距离就大得多了。因此总的比较和交换次数就少了，速度自然就提高了。<br>当然在最坏的情况下（例如以两端为基准点对<strong>有序</strong>列表再次排序时），即分裂点位于数列的两端时，仍是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的；最好情况下，即分裂点在中间时，时间复杂度为O(nlogn)。<br>对于快速算法的优化，包括以下几个方面：</p><ul><li>更好的基准选择方法（如 三平均分区法，以最左边、最右边和中间的元素的中值作为基准值）；   </li><li>当子数组足够小时改用更简单的排序算法；   </li><li>避免递归（非递归快速排序）；</li></ul></blockquote><h3 id="3、选择排序（Selection-Sort）"><a href="#3、选择排序（Selection-Sort）" class="headerlink" title="3、选择排序（Selection Sort）"></a>3、选择排序（Selection Sort）</h3><blockquote><p>选择排序也是蛮力法在排序方面的一种应用。选择排序开始时，我们扫描整个列表找到值最小的元素与第一个元素交换，然后从第二个元素开始扫描整个列表，找到最小值与第二个元素进行交换，直到从第n-1个元素开始扫描整个列表找到最小值与第n-1位元素进行交换。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp, minIndex;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> minIndex = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[minIndex] &gt; <span class="built_in">array</span>[j])</span><br><span class="line">minIndex = j;</span><br><span class="line">&#125;</span><br><span class="line">temp = <span class="built_in">array</span>[i];</span><br><span class="line"><span class="built_in">array</span>[i] = <span class="built_in">array</span>[minIndex];</span><br><span class="line"><span class="built_in">array</span>[minIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>无论输入的数列是怎样的，选择排序的时间复杂度都是O(n^2),然而，键的交换次数仅为O(n)。   </p></blockquote><h3 id="4、插入排序（Insertion-Sort）"><a href="#4、插入排序（Insertion-Sort）" class="headerlink" title="4、插入排序（Insertion Sort）"></a>4、插入排序（Insertion Sort）</h3><blockquote><p>插入排序是一种通过<strong>减一技术(减治法)</strong>实现的排序算法。   </p><ul><li>减治技术利用了一个问题给定<strong>实例的解</strong>和同样问题<strong>较小实例的解</strong>之间的某种关系。一旦建立     了这种关系，我们就可以<strong>从顶至下(递归)</strong>或<strong>从底至上(非递归)</strong>地来运用该关系。 </li></ul><p>插入排序就建立了这种关系：假设一个列表的前n-1项已经有序，我们可以通过把第n项元素插入到这个较小规模的有序列表中，得到最终的有序列表。<br>假设当前要插入的元素为temp，我们从右到左扫描这个有序的子数组，遇到第一个小于等于temp的元素，然后把temp插入到该元素后面。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp, preIndex;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">temp = <span class="built_in">array</span>[i];<span class="comment">//储存当前要向有序链表中插入的元素的值</span></span><br><span class="line">preIndex = i;</span><br><span class="line"><span class="keyword">while</span> (preIndex &gt; <span class="number">0</span> &amp;&amp; temp &lt; <span class="built_in">array</span>[preIndex - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="built_in">array</span>[preIndex] = <span class="built_in">array</span>[preIndex - <span class="number">1</span>];</span><br><span class="line">preIndex--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[preIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入排序（递归）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort2</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">InsertionSort2(<span class="built_in">array</span>, len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> preIndex, temp;</span><br><span class="line">temp = <span class="built_in">array</span>[len - <span class="number">1</span>];</span><br><span class="line">preIndex = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (preIndex &gt; <span class="number">0</span> &amp;&amp; temp &lt; <span class="built_in">array</span>[preIndex - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="built_in">array</span>[preIndex] = <span class="built_in">array</span>[preIndex - <span class="number">1</span>];</span><br><span class="line">--preIndex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[preIndex] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最坏情况下，temp &lt; array[preIndex - 1]的执行次数达到最大（比如是个递减的列表(相对而言，上述代码是升序排序)），这是算法复杂度为O(n^2)。然而，对于有序数组这种最优输入，该算法有着非常好的性能。对于升序排序来说，当输入的列表为升序列表时，temp &lt; array[preIndex - 1]只需执行n次，即时间复杂度为O(n)。因此，当输入数列<strong>基本有序</strong>时，插入排序能够有更好的性能</p><h3 id="5、希尔排序（Shell-Sort）"><a href="#5、希尔排序（Shell-Sort）" class="headerlink" title="5、希尔排序（Shell Sort）"></a>5、希尔排序（Shell Sort）</h3><blockquote><p>希尔排序又称“缩小增量排序”，希尔排序从“减少记录个数”和“序列基本有序”两个方面对直接插入排序进行了改进。在希尔排序中，对列表进行分组，对每组记录进行直接插入排序，经过几次分组之后，整个列表中的记录都“基本有序”了，这时在对整体进行一次直接插入排序。<br>希尔排序通过相隔某个“增量”对记录进行分组。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp, preIndex;</span><br><span class="line"><span class="comment">//增量（grp）为1时，对整个数组进行直接插入排序，</span></span><br><span class="line"><span class="comment">//此时的数列基本上是排好序的了。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> grp = len / <span class="number">2</span>; grp &gt; <span class="number">0</span>; grp /= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">//对每组进行插入排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = grp; i &lt; len; ++i) &#123;</span><br><span class="line">preIndex = i - grp;</span><br><span class="line">temp = <span class="built_in">array</span>[i];</span><br><span class="line"><span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">array</span>[preIndex] &gt; temp) &#123;</span><br><span class="line"><span class="built_in">array</span>[preIndex + grp] = <span class="built_in">array</span>[preIndex];</span><br><span class="line">preIndex -= grp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[preIndex + grp] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>希尔排序只能用于顺序结构，不能用于链式结构，增量序列可以有各种取法，但应该使增量序列的值没有除1之外的公因子，并且最后一个增量的值必须为1，记录总的比较次数和移动次数比直接插入排序要少，记录个数越多，效果越明显，因此，希尔排序更适合初始记录无须、数据量较大时的情况。</p></blockquote><h3 id="6、堆排序（Heap-Sort）"><a href="#6、堆排序（Heap-Sort）" class="headerlink" title="6、堆排序（Heap Sort）"></a>6、堆排序（Heap Sort）</h3><blockquote><p>堆排序是一种树型选择排序，在排序过程中，将待排序序列看成一棵完全二叉树。利用完全二叉树中双亲结点与孩子结点之间的内在关系，在当前序列中选择最大（或最小）的记录。通过大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征，来选择当前序列中的最大（或最小）的记录。   </p><ul><li>堆的定义（1 &lt;= i &lt;= n/2）<br>（1）ki &gt;= k2i且ki &gt;= k2i+1  （2）ki &lt;= ki且ki &lt;= ki+1<br>按堆的定义将带排序序列调整为大根堆，交换r[1]与r[n],调整剩余数列为大顶堆（即只需将当前堆顶元素向下调整即可），直到堆中只剩一个元素为止。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向下调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SiftDown</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果当前结点至少存在一个孩子结点，比较它与孩子结点的大小</span></span><br><span class="line"><span class="keyword">while</span> ((<span class="number">2</span> * i + <span class="number">1</span>) &lt;= n) &#123;</span><br><span class="line"><span class="keyword">int</span> t = i;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[t] &lt; <span class="built_in">array</span>[<span class="number">2</span> * i + <span class="number">1</span>])</span><br><span class="line">t = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((<span class="number">2</span> * i + <span class="number">2</span>) &lt;= n &amp;&amp; <span class="built_in">array</span>[t] &lt; <span class="built_in">array</span>[<span class="number">2</span> * i + <span class="number">2</span>])</span><br><span class="line">t = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"><span class="comment">//当前结点比它的孩子结点小，进行交换</span></span><br><span class="line"><span class="keyword">if</span> (t != i) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="built_in">array</span>[t];</span><br><span class="line"><span class="built_in">array</span>[t] = <span class="built_in">array</span>[i];</span><br><span class="line"><span class="built_in">array</span>[i] = temp;</span><br><span class="line">i = t;<span class="comment">//当前结点的索引变为t</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当前结点比它两个孩子结点的值大，结束调整</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//（初始化堆）从最后一个非叶结点的结点开始依次进行向上调整</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">SiftDown(<span class="built_in">array</span>, n, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将堆顶元素放到最后，并在剩余的 n-- 数内对新的堆顶元素向下调整</span></span><br><span class="line"><span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="built_in">array</span>[n];</span><br><span class="line"><span class="built_in">array</span>[n] = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>] = temp;</span><br><span class="line">SiftDown(<span class="built_in">array</span>, --n, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于堆排序，初建堆时比较次数较多，因此记录较少时不宜采用，当记录较多时较为高效。</p></blockquote><h3 id="7、归并排序（Merge-Sort）"><a href="#7、归并排序（Merge-Sort）" class="headerlink" title="7、归并排序（Merge Sort）"></a>7、归并排序（Merge Sort）</h3><blockquote><p>归并排序就是将两个或者两个以上的有序列表合成一个有序列表的过程。将2个有序表合成一个有序表的过程称为2-路归并。对一个有n个记录的列表进行归并排序时，可以将列表看成是n个有序的子序列，每个序列的长度为1。然后两两合并得到n/2个长度为2或1的有序子序列，再两两合并，直到得到一个长度为n的有序序列为止。<br>在归并时，分别从两个要归并的序列中得到最小的值，放到一个新的列表中，重复这个过程直到其中一个列表为空，然后将非空列表中的剩余部分直接复制到新列表中。</p></blockquote><p><img src="http://p.qpic.cn/pic_wework/1948211503/64626c74be2f621b6f7ee6552b8440ea17f32eb3974d660c/0" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> L_left, <span class="keyword">int</span> L_right, <span class="keyword">int</span> R_left, <span class="keyword">int</span> R_right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//申请一个新数组用来储存排好序的数组</span></span><br><span class="line"><span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[R_right - L_left + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> i = L_left, j = R_left, k = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//将两数组中的数据有序归并到temp中</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= L_right &amp;&amp; j &lt;= R_right) &#123;</span><br><span class="line">temp[k++] = (<span class="built_in">array</span>[i] &lt; <span class="built_in">array</span>[j]) ? <span class="built_in">array</span>[i++] : <span class="built_in">array</span>[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将左数组或者右数组中剩余的有序数列归并到temp中</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= L_right) &#123;</span><br><span class="line">temp[k++] = <span class="built_in">array</span>[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= R_right) &#123;</span><br><span class="line">temp[k++] = <span class="built_in">array</span>[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将排好序的数列替换到原数列中</span></span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = L_left; i &lt;= R_right; ++i) &#123;</span><br><span class="line"><span class="built_in">array</span>[i] = temp[k++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放临时开辟的空间</span></span><br><span class="line"><span class="keyword">delete</span>[] temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left + <span class="number">1</span> &lt;= right) &#123;</span><br><span class="line">MergeSort(<span class="built_in">array</span>, left, (right + left) / <span class="number">2</span>);</span><br><span class="line">MergeSort(<span class="built_in">array</span>, (right + left) / <span class="number">2</span> + <span class="number">1</span>, right);</span><br><span class="line">merge(<span class="built_in">array</span>, left, (right + left) / <span class="number">2</span>, (right + left) / <span class="number">2</span> + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用顺序表实现归并排序时，需要和待排序记录个数相等的辅助储存空间，因此空间复杂度为O(n)，归并排序可用于练市结构，且不需要附加的储存空间。</p></blockquote><blockquote><p><strong>以上排序算法测试源代码：</strong> <a href="https://github.com/syfx/Sort/blob/master/Sort/Sort.cpp" target="_blank" rel="noopener">https://github.com/syfx/Sort/blob/master/Sort/Sort.cpp</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表相关操作</title>
      <link href="/2019/04/04/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/04/04/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="链表相关操作"><a href="#链表相关操作" class="headerlink" title="链表相关操作"></a>链表相关操作</h2><blockquote><ol><li>求单链表中结点的个数   </li><li>将单链表反转   </li><li>查找单链表中的倒数第K个结点（k &gt; 0）   </li><li>查找单链表的中间结点   </li><li>从尾到头打印单链表   </li><li>已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序   </li><li>判断两个单链表是否相交   </li><li>求两个单链表相交的第一个结点  </li><li>判断一个单链表中是否有环   </li><li>已知一个单链表中存在环，求进入环中的第一个结点   </li><li>给出一单链表头指针pHead和一结点指针pToBeDeleted，O(1)时间复杂度删除结点pToBeDeleted   </li></ol></blockquote><ul><li><strong>链表结构</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">List* next;</span><br><span class="line">&#125;*myList;</span><br><span class="line"><span class="comment">//创建链表</span></span><br><span class="line"><span class="function">myList <span class="title">CreatList</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">myList head, tail, temp;</span><br><span class="line">head = <span class="keyword">new</span> List();</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">tail = head;</span><br><span class="line"><span class="comment">//在32位系统中size_t是4字节的，而在64位系统中，size_t是8字节的，这样利用该类型可以增强程序的可移植性。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; length; ++i)&#123;</span><br><span class="line">temp = <span class="keyword">new</span> List();</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; temp-&gt;val;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">tail-&gt;next = temp;</span><br><span class="line">tail = temp;</span><br><span class="line">&#125;</span><br><span class="line">temp = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1、求单链表中结点的个数"><a href="#1、求单链表中结点的个数" class="headerlink" title="1、求单链表中结点的个数"></a>1、求单链表中结点的个数</h4><blockquote><p>因为要求链表中结点的个数，因此只能遍历整个链表以确定结点个数。(；´д｀)ゞ</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(myList head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line">length++;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、将单链表反转"><a href="#2、将单链表反转" class="headerlink" title="2、将单链表反转"></a>2、将单链表反转</h4><blockquote><p>当链表中节点个数大于1时，保存链表的头结点为oldHead指针（因为反转后这就不是头指针了），<br>如果oldHead的后继结点不为空的话，使用指针temp储存这个结点，然后赋值oldHead的后继结点为其后继结点(即temp)的后继结点，然后将temp的后继结点设置为head结点，赋值head为temp；</p></blockquote><p><img src="http://p.qpic.cn/pic_wework/1948211503/696f94662529e7b821a61fbd81de0706543ad7ea7dc42dfe/0" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseList</span><span class="params">(myList &amp;head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">myList temp, oldHead = head;</span><br><span class="line"><span class="keyword">while</span> (oldHead-&gt;next) &#123;</span><br><span class="line">temp = oldHead-&gt;next;</span><br><span class="line">oldHead-&gt;next = temp-&gt;next;</span><br><span class="line">temp-&gt;next = head;</span><br><span class="line">head = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、查找单链表中的倒数第K个结点（k-gt-0）"><a href="#3、查找单链表中的倒数第K个结点（k-gt-0）" class="headerlink" title="3、查找单链表中的倒数第K个结点（k &gt; 0）"></a>3、查找单链表中的倒数第K个结点（k &gt; 0）</h4><blockquote><p>使用两个指针left，right，先让right指向正数第k个结点，然后让left结点从头结点与right指针一同向后移动。当right指向最后一个结点时，left指向的就是倒数第k个结点。</p></blockquote><p><img src="http://p.qpic.cn/pic_wework/1948211503/3b3dc6341672ff7ca163d1f6a2e421b22158a6b18359d32a/0" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">myList <span class="title">FindCountBackwardsK</span><span class="params">(myList head, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">myList  left = head, right = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; k; ++i)&#123;</span><br><span class="line">right = right-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (!right)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (right &amp;&amp; right-&gt;next)&#123;</span><br><span class="line">right = right-&gt;next;</span><br><span class="line">left = left-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、查找单链表的中间结点"><a href="#4、查找单链表的中间结点" class="headerlink" title="4、查找单链表的中间结点"></a>4、查找单链表的中间结点</h4><blockquote><p>使用快慢指针，快指针每次向后移动两个结点的距离，慢指针每次向后移动一个指针距离，当快指针为空时，慢指针指向的结点便是中间结点。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">myList <span class="title">FindMiddleNode</span><span class="params">(myList head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">myList left = head, right = head;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (right-&gt;next)&#123;</span><br><span class="line">right = right-&gt;next-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (right == <span class="literal">NULL</span>) </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">left = left-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、从尾到头打印单链表"><a href="#5、从尾到头打印单链表" class="headerlink" title="5、从尾到头打印单链表"></a>5、从尾到头打印单链表</h4><blockquote><p>由从尾到头可以很容易想到能够使用递归或者栈来实现。使用递归时，在遇到链表尾结点时返回，然后打印结点的值。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从尾到头打印单链表（递归）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintListFromTailToHead</span><span class="params">(myList head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">PrintListFromTailToHead(head-&gt;next);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; head-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从尾到头打印单链表（通过栈）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintListFromTailToHeadByStack</span><span class="params">(myList head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;myList&gt; sta;</span><br><span class="line"><span class="keyword">while</span> (head)&#123;</span><br><span class="line">sta.push(head);</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!sta.empty())&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sta.top()-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">sta.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、已知两个单链表pHead1-和pHead2-各自有序，把它们合并成一个链表依然有序"><a href="#6、已知两个单链表pHead1-和pHead2-各自有序，把它们合并成一个链表依然有序" class="headerlink" title="6、已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序"></a>6、已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序</h4><blockquote><p>可是使用归并排序的思想；选择值较小的头结点作为新的头结点，然后遍历两个链表，将值较小的结点合并到新链表中，遍历此链表的指针向后移位，另一个指针不做处理；当一个链表为空后，将不为空的链表合并到新链表中。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">myList <span class="title">MergeOrderedLists</span><span class="params">(myList head1, myList head2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head1 == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head2;</span><br><span class="line"><span class="keyword">if</span> (head2 == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head1;</span><br><span class="line">myList newHead =<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (head1-&gt;val &gt;= head2-&gt;val) &#123;</span><br><span class="line">newHead = head2;</span><br><span class="line">head2 = head2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">newHead = head1;</span><br><span class="line">head1 = head1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">newHead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">myList temp = newHead;</span><br><span class="line"><span class="keyword">while</span> ( head1 &amp;&amp; head2)&#123;</span><br><span class="line"><span class="keyword">if</span> (head1-&gt;val &lt; head2-&gt;val) &#123;</span><br><span class="line">temp-&gt;next = head1;</span><br><span class="line">head1 = head1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">temp-&gt;next = head2;</span><br><span class="line">head2 = head2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">temp-&gt;next = head2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">temp-&gt;next = head1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7、判断两个单链表是否相交"><a href="#7、判断两个单链表是否相交" class="headerlink" title="7、判断两个单链表是否相交"></a>7、判断两个单链表是否相交</h4><blockquote><p>从这点出发：若两个两链表相交，则这两个链表的尾结点必然相同。因此，我们可以分别遍历链表以得到他们的尾结点，然后判断两个尾结点的地址是否相同即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsIntersect</span><span class="params">(myList head1, myList head2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head1 == <span class="literal">NULL</span> || head2 == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (head1-&gt;next) &#123;</span><br><span class="line">head1 = head1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (head2-&gt;next) &#123;</span><br><span class="line">head2 = head2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若相交则两个链表的最后一个节点必然完全相等</span></span><br><span class="line"><span class="keyword">if</span> (head1 == head2)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、求两个单链表相交的第一个结点"><a href="#8、求两个单链表相交的第一个结点" class="headerlink" title="8、求两个单链表相交的第一个结点"></a>8、求两个单链表相交的第一个结点</h4><p><img src="http://p.qpic.cn/pic_wework/1948211503/67619a683e1e68a5c224b626ba6f324ec7836fde8335d76c/0" alt=""></p><blockquote><p>两链表相交，求相交的第一个结点：先遍历两个链表，分别得到两个链表的长度。（储存一下尾结点，顺便判断一下两个链表是否相交）。求相交的第一个结点时，先让一个指针从长链表的头结点向前移动<strong>abs(len1-len2)</strong>个距离，然后让另一个指针从短链表头结点出发与这个指针一同向后移动，当两个指针首次指向同一个结点时，这个结点便是两个单链表相交的第一个结点。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">myList <span class="title">FirstIntersectNode</span><span class="params">(myList head1, myList head2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head1 == <span class="literal">NULL</span> || head2 == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> len1 = <span class="number">1</span>, len2 = <span class="number">1</span>;</span><br><span class="line">myList temp1 = head1, temp2 = head2;</span><br><span class="line"><span class="keyword">while</span> (temp1-&gt;next) &#123;</span><br><span class="line">len1++;</span><br><span class="line">temp1 = temp1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (temp2-&gt;next) &#123;</span><br><span class="line">len2++;</span><br><span class="line">temp2 = temp2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断两链表是否相交</span></span><br><span class="line"><span class="keyword">if</span> (temp1 != temp2)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//保证head1是两者中较长的链表</span></span><br><span class="line"><span class="keyword">if</span> (len1 &lt; len2) &#123;</span><br><span class="line">temp1 = head1;</span><br><span class="line">head1 = head2;</span><br><span class="line">head2 = temp1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">abs</span>(len1 - len2); ++i) &#123;</span><br><span class="line">head1 = head1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (head2) &#123;</span><br><span class="line"><span class="keyword">if</span> (head1 == head2)</span><br><span class="line"><span class="keyword">return</span> head1;</span><br><span class="line">head1 = head1-&gt;next;</span><br><span class="line">head2 = head2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、判断一个单链表中是否有环"><a href="#9、判断一个单链表中是否有环" class="headerlink" title="9、判断一个单链表中是否有环"></a>9、判断一个单链表中是否有环</h4><blockquote><p>可以使用快慢指针来判断单链表中是否存在环：使用两个指针fast、slow，slow每次向后移动一个结点的距离，fast每次向后移动两个结点的距离。若链表存在环的话，两个指针必然会相遇。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsCircularList</span><span class="params">(myList head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> &amp;&amp; head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">myList temp1 = head, temp2 = head;</span><br><span class="line"><span class="comment">//temp1和temp2都不为空</span></span><br><span class="line"><span class="keyword">while</span> (temp1 &amp;&amp; temp2 &amp;&amp; temp2-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">temp1 = temp1-&gt;next;</span><br><span class="line">temp2 = temp2-&gt;next-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (temp1 == temp2)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10、已知一个单链表中存在环，求进入环中的第一个结点"><a href="#10、已知一个单链表中存在环，求进入环中的第一个结点" class="headerlink" title="10、已知一个单链表中存在环，求进入环中的第一个结点"></a>10、已知一个单链表中存在环，求进入环中的第一个结点</h4><p><img src="http://p.qpic.cn/pic_wework/1948211503/6b6d96648f6e5c4b4eeef80f655b0c0c2e54c6a083e12304/0" alt=""></p><blockquote><p>设链表头距离环入口的长度为L，快慢指针相遇的位置为cross，该位置距离环入口的长度为S。考虑快慢指针移动的距离，慢指针走了L+S，快指针走了L+S+nR(n表示两只镇相遇前快指针走的圈数)。由于快指针的速度是慢指针的两倍，相同时间下快指针走过的路程就是慢指针的两倍，所以有2(L+S)=L+S+nR，化简得L+S=nR<br>当n=1时，即快指针在相遇之前多走了一圈，即L+S=R，也就是L=R−S，因此可以使用两个指针，一个指针从链表头部移动，一个从快慢指针第一次相遇处的后个指针开始移动，每次移动一个节点的距离，则两指针相等时所指向的结点就是进入环的第一个结点。   </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">myList <span class="title">CircularListEntrance</span><span class="params">(myList head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">myList fast = head, slow = head;</span><br><span class="line"><span class="keyword">while</span> (slow &amp;&amp; fast &amp;&amp; fast-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line">fast = fast-&gt;next-&gt;next;</span><br><span class="line"><span class="comment">//第一次相交</span></span><br><span class="line"><span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">fast = head;</span><br><span class="line"><span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line"><span class="comment">//这里让指向第一次相遇处的指针先走</span></span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11、给出一单链表头指针pHead和一节点指针pToBeDeleted，O-1-时间复杂度删除结点pToBeDeleted"><a href="#11、给出一单链表头指针pHead和一节点指针pToBeDeleted，O-1-时间复杂度删除结点pToBeDeleted" class="headerlink" title="11、给出一单链表头指针pHead和一节点指针pToBeDeleted，O(1)时间复杂度删除结点pToBeDeleted"></a>11、给出一单链表头指针pHead和一节点指针pToBeDeleted，O(1)时间复杂度删除结点pToBeDeleted</h4><blockquote><p>因为每个结点的储存结构都是相同的，因此，当pToBeDeleted不是尾结点时，可以将pToBeDeleted下个节点储存的数据复制到pToBeDeleted结点中，然后进行删除pToBeDeleted-next的操作即可。当pToBeDeleted为尾结点时，就需要遍历整个链表找到pToBeDeleted结点的前驱结点了。不过时间复杂度总体上讲为O(1);</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(myList head, myList pToBeDeleted)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (pToBeDeleted-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">myList temp = pToBeDeleted-&gt;next;</span><br><span class="line">pToBeDeleted-&gt;val = temp-&gt;val;</span><br><span class="line">pToBeDeleted-&gt;next = temp-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line">temp = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (head == pToBeDeleted) &#123;</span><br><span class="line"><span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line">pToBeDeleted = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (head-&gt;next != pToBeDeleted) &#123;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">pToBeDeleted = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>测试源码：</strong><a href="https://github.com/syfx/List/blob/master/lIST/Main.cpp" target="_blank" rel="noopener">https://github.com/syfx/List/blob/master/lIST/Main.cpp</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归创建二叉树时为什么要传指针的引用？</title>
      <link href="/2019/03/27/%E9%80%92%E5%BD%92%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BC%A0%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%9F/"/>
      <url>/2019/03/27/%E9%80%92%E5%BD%92%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BC%A0%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>复习了一下二叉树的知识，想用C++实现一颗二叉树，没想到竟然在创建二叉树时忽略了点东西。<br>本来的惯性思维是：<strong>用指针做参数传递时，指针指向的值会被同步改变。</strong>。<br>于是调用创建树的方法时，只是传递了空的指针，然后在函数中为指针开辟空间，递归创建二叉树。 然后遍历二叉树时发现二叉树为空。这是为什么呢？<br>上面惯性思维所想的的确没有错，它是对的；那为什么创建的树为空呢？那是因为，我们在创建树时，在创建方法中<strong>改变的不仅是指针指向的值，还有指针本身的值</strong>。<br>错误的创建代码为：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatTree</span><span class="params">(BiTree*p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'#'</span>)</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">p = <span class="keyword">new</span> BiTree();</span><br><span class="line">p-&gt;value = ch;</span><br><span class="line">CreatTree(p-&gt;lift);</span><br><span class="line">CreatTree(p-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上述代码中，当使用new关键字开辟空间后（new关键在在<strong>自由储存区</strong>申请一快内存，它返回一个指向这块内存的指针），我们又改变了这个指针指向的值；因此，在这里指针本身和指针指向的值都发生了改变。因此，当我们创建二叉树时，应该使用指针的引用或者二级指针。示例代码如下：   </p><ul><li>堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。我们可以重载new关键字改用其他内存作为自由储存区。   </li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用二级指针做参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatTree</span><span class="params">(BiTree**p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'#'</span>)</span><br><span class="line">*p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">*p = <span class="keyword">new</span> BiTree();</span><br><span class="line">(*p)-&gt;value = ch;</span><br><span class="line">CreatTree(&amp;(*p)-&gt;lift);</span><br><span class="line">CreatTree(&amp;(*p)-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用指针的引用做参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatTree</span><span class="params">(BiTree* &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'#'</span>)</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">p = <span class="keyword">new</span> BiTree();</span><br><span class="line">p-&gt;value = ch;</span><br><span class="line">CreatTree(p-&gt;lift);</span><br><span class="line">CreatTree(p-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之观察者模式</title>
      <link href="/2019/03/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/03/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>#观察这模式（Observer Pattern）</p><blockquote><p>观察模式是一种行为模式，定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p></blockquote><p>观察者模式包含以下四个角色：</p><ul><li>抽象目标类：所有具体目标的父类，约束目标类应实现的接口。    </li><li>具体目标类：实现具体的功能，并在某个事件发生时通知所有观察自己的观察者。   </li><li>观察者类：观察者的抽象基类，约束观察者类应实现的接口。</li><li>具体观察者类：继承自观察者类，实现具体功能。</li></ul><p>举例说明，在游戏中，当主角击败BOSS时（即BOSS死亡事件发生），通知 动画管理类播放胜利动画，音效管理类播放胜利音乐。<br>在这个例子中，存在具体目标类<strong>BOSS</strong>，具体观察者类<strong>动画管理类</strong>，<strong>音效管理类</strong>。代码设计如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line"></span><br><span class="line">namespace ObserverPattern</span><br><span class="line">&#123;</span><br><span class="line">    //抽象目标类</span><br><span class="line">    abstract class Subject</span><br><span class="line">    &#123;</span><br><span class="line">        //目标类的观察类列表</span><br><span class="line">        protected List&lt;Observer&gt; obsLists = new List&lt;Observer&gt;();</span><br><span class="line">        //抽象注册方法</span><br><span class="line">        public abstract void AddObs(Observer obs);</span><br><span class="line">        //抽象移除方法</span><br><span class="line">        public abstract void RemoveObs(Observer obs);</span><br><span class="line">        //抽象通知方法</span><br><span class="line">        public abstract void Notify();</span><br><span class="line">    &#125;</span><br><span class="line">    //抽象观察者类</span><br><span class="line">    abstract class Observer</span><br><span class="line">    &#123;</span><br><span class="line">        public abstract void Update();</span><br><span class="line">    &#125;</span><br><span class="line">    //boss类</span><br><span class="line">    class BOSS : Subject</span><br><span class="line">    &#123;</span><br><span class="line">        public override void AddObs(Observer obs)</span><br><span class="line">        &#123;</span><br><span class="line">            obsLists.Add(obs);</span><br><span class="line">        &#125;</span><br><span class="line">        public override void RemoveObs(Observer obs)</span><br><span class="line">        &#123;</span><br><span class="line">            obsLists.Remove(obs);</span><br><span class="line">        &#125;</span><br><span class="line">        public override void Notify()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;BOSS死亡！&quot;);</span><br><span class="line">            foreach(Observer obs in obsLists)</span><br><span class="line">            &#123;</span><br><span class="line">                obs.Update();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class AnimatorManager : Observer</span><br><span class="line">    &#123;</span><br><span class="line">        public override void Update()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;我是胜利动画！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class AudioManager : Observer</span><br><span class="line">    &#123;</span><br><span class="line">        public override void Update()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;我是胜利音乐！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Subject sub = new BOSS();</span><br><span class="line">            Observer obs1 = new AnimatorManager();</span><br><span class="line">            Observer obs2 = new AudioManager();</span><br><span class="line">            //注册事件</span><br><span class="line">            sub.AddObs(obs1);</span><br><span class="line">            sub.AddObs(obs2);</span><br><span class="line">            //BOSS死亡</span><br><span class="line">            sub.Notify();</span><br><span class="line">            /**</span><br><span class="line">             * 输出：</span><br><span class="line">             * BOSS死亡！</span><br><span class="line">             * 我是胜利动画！</span><br><span class="line">             * 我是胜利音乐！</span><br><span class="line">             * */</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模式分析：</strong>   </p><ul><li>优点： <ol><li>观察者模式在只是在观察者和观察者之间建立一个抽象的耦合，因此对业务的逻辑进行了解耦。</li><li>使用观察者模式建立一套触发机制，支持广播通讯，被观察者会向所有的登记过的观察者发出通知。</li></ol></li><li>缺点： <ol><li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。   </li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。   </li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ol></li></ul><p>使用场景：</p><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。   </li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。   </li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="/2019/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式（Singleton-Pattern）"><a href="#单例模式（Singleton-Pattern）" class="headerlink" title="单例模式（Singleton Pattern）"></a>单例模式（Singleton Pattern）</h2><blockquote><p>单例模式又称<strong>单件模式/单态模式</strong>，是常用的设计模式之一。单例模式要求其实例对象只能在系统中存在一个。许多时候整个系统只需要拥有一个的全局对象，使用单例模式有利于我们协调系统整体的行为。   </p></blockquote><p><strong>单例模式三要素</strong>   </p><ul><li>必须确保一个类只有一个实例    </li><li>它必须自行创建这个实例    </li><li>必须自行向整个系统提供这个实例     </li></ul><blockquote><p>代码分析（c#）   </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">namespace Singleton</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line">空间换时间   </span><br><span class="line">声明属性时直接将它初始化   </span><br><span class="line">缺点：在没有使用时内存已经分配，（如果此单例类未被使用）就造成了空间浪费。   </span><br><span class="line">*/</span><br><span class="line">class SimpleSingle</span><br><span class="line">&#123;</span><br><span class="line">private static _mySingle = new SimpleSingle();</span><br><span class="line">public static mySingle&#123;</span><br><span class="line">get&#123;return _mySingle;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">饿汉式   </span><br><span class="line">时间换空间   </span><br><span class="line">缺点，因为要判断属性是否为null，因此是线程不安全的。  </span><br><span class="line">可能一个线程刚进入判断后，CPU被另外一个线程抢占而导致生成多个实例。   </span><br><span class="line">*/</span><br><span class="line">class Single</span><br><span class="line">&#123;</span><br><span class="line">private static _mySingle;</span><br><span class="line">public static mySingle&#123;</span><br><span class="line">get&#123;</span><br><span class="line">if(_mySingle == null)</span><br><span class="line">_mySingle = new Single();</span><br><span class="line">return _mySingle;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">懒汉式</span><br><span class="line">使用互斥锁保证线程安全</span><br><span class="line">*/</span><br><span class="line">    class MySingleton</span><br><span class="line">    &#123;</span><br><span class="line">        static public Mutex mutex = new Mutex();   //创建互斥锁对象</span><br><span class="line">        static private MySingleton _instance;</span><br><span class="line">        static public MySingleton instance &#123;</span><br><span class="line">            get</span><br><span class="line">            &#123;</span><br><span class="line">                mutex.WaitOne();            //申请互斥锁</span><br><span class="line">                if (_instance == null)</span><br><span class="line">                    _instance = new MySingleton();</span><br><span class="line">                mutex.ReleaseMutex();       //释放锁资源</span><br><span class="line">                return instance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //私有化构造函数</span><br><span class="line">        private MySingleton() &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单例模式分析</strong>   </p><blockquote><p>单例模式保证一个类仅有一个实例，并提供了一个访问它的全局访问点；单例模式拥有一个私有构造函数，确保用户不能再外界实例化它；该模式中还存在一个静态私有变量和一个静态公有工厂方法，在这个工厂方法中确保实例化自己一次，将对象保存到静态成员变量中。</p></blockquote><p><strong>单例模式的优缺点</strong>   </p><ul><li><p>优点：     </p><ul><li><strong>提供了对唯一实例的受访控制</strong>。单例类封装了它的唯一实例，所以它可以严格控制客户如何访问它。   </li><li><strong>节约系统资源</strong>。在系统中只存在一个对象。    </li><li><strong>允许可变数量的实例</strong>，可以基于单例模式进行扩展，在其工厂方法（获取实例的成员方法）中做控制以用来获取指定数目的实例。      </li></ul></li><li><p>缺点：      </p><ul><li><strong>单例模式在扩展时有很大的困难</strong>，因为单例模式没有抽象层（抽象父类）。</li><li><strong>单例类职责过重</strong>，在一定程度上违背了“单一职责原则”。它既充当了工厂角色，提供了工厂方法（获取自己的实例）；又充当了产品角色，有自己的业务逻辑；讲产品的创建与自身功能融合到了一起。      </li><li><strong>滥用单例时将带来一些负面问题</strong>，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收（c#、Java等语言具有垃圾自动回收机制），这将导致对象状态的丢失。   </li></ul></li></ul><p><strong>适用场景</strong>   </p><ul><li>单例模式只允许创建一个对象，因此节省内存，加快对象访问速度，因此在对象需要被公用的场合适合使用。如：    <ol><li>需要频繁实例化然后销毁的对象。    </li><li>创建对象时耗时过多或者耗资源过多，但又经常用到的对象。    </li><li>有状态的工具类对象。     </li><li>频繁访问数据库或文件的对象。       </li></ol></li><li>单例模式的经典使用场景：   <ol><li>资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。      </li><li>控制资源的情况下，方便资源之间的互相通信。如线程池等。   </li></ol></li></ul><p><strong>注意事项</strong>   </p><ol><li>使用时不能用反射模式创建单例，否则会实例化一个新的对象。    </li><li>使用饿汉单例模式时注意线程安全问题。     </li><li>单例模式中构造方法都是私有的，因而是不能被继承，有些单例模式可以被继承（如登记式模式）。       </li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之工厂模式</title>
      <link href="/2019/03/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/03/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式之工厂模式-Factory-Pattern"><a href="#设计模式之工厂模式-Factory-Pattern" class="headerlink" title="设计模式之工厂模式(Factory Pattern)"></a>设计模式之工厂模式(Factory Pattern)</h2><blockquote><p>工厂模式是最常用的设计模式之一，它属于创建型设计模式；工厂模式 <strong>提供了一种创建对象的最好方式</strong> （如果你有更好的方式就当我没说）；它的主要作用是让对象的创建与对象的使用分离开来，即使用单独的类来<strong> 封装创建实例的逻辑。</strong><br>工厂模式又可以细分为：   </p><ul><li>简单工厂模式   </li><li>工厂方法模式   </li><li>抽象工厂模式   </li></ul></blockquote><h3 id="1、简单工厂模式-Simple-Factory-Pattern"><a href="#1、简单工厂模式-Simple-Factory-Pattern" class="headerlink" title="1、简单工厂模式(Simple Factory Pattern)"></a>1、简单工厂模式(Simple Factory Pattern)</h3><blockquote><p>又称为静态工厂方法(Static Factory Method)模式；在简单工厂模式中，通常包含一个静态方法，可以根据参数的不同返回不同类的实例。<br>简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。   </p></blockquote><ul><li>简单工厂模式包含以下几种角色：   <ul><li>工厂：负责创建所有具体产品类的实例，工厂类中的静态方法要能够被其它类直接在外界调用，以获得产品对象。   </li><li>抽象产品类：是所有具体产品的父类，负责定义其它具体产品的所共有的公共接口（子类共有的行为）   </li><li>具体产品类：继承自抽象产品类，是工厂角色的创建目标。   </li></ul></li></ul><blockquote><blockquote><p>如果上面说的不好理解的话，那就来个栗子消化一下吧。   </p></blockquote><p>在一个游戏中，有三种小怪： <strong>MobA</strong> 、<strong>MobB</strong> 、<strong>Mobc</strong> ;<br>在游戏中，他们都可以攻击主角。这时候，我们就可以使用简单工厂模式来控制它们的 出场（实例生成）。   </p></blockquote><hr><blockquote><p>首先，我们应该创建一个抽象怪物类 <strong>Mob</strong> ，让上面那三个小怪类继承自Mob。然后用Mob当做工厂中静态方法的返回对象。<br>不太懂得话，就看看代码吧（c#）：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">namespace FactoryPattern</span><br><span class="line">&#123;</span><br><span class="line">    //怪物工厂</span><br><span class="line">    class MobFactory</span><br><span class="line">    &#123;</span><br><span class="line">        //获取对象实例的静态方法</span><br><span class="line">        public static Mob GetMob(string mobName)</span><br><span class="line">        &#123;</span><br><span class="line">            switch (mobName) &#123;</span><br><span class="line">                case &quot;MobA&quot;: return new MobA();</span><br><span class="line">                case &quot;MobB&quot;: return new MobB();</span><br><span class="line">                case &quot;MobC&quot;: return new MobC();</span><br><span class="line">                default: return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ////使用接口实现抽象类会更好</span><br><span class="line">    //interface I_Mob</span><br><span class="line">    //&#123;</span><br><span class="line">    //    //定义攻击接口（规定每个继承自此抽象类的怪物都能进行攻击）</span><br><span class="line">    //    void Attack();</span><br><span class="line">    //&#125;</span><br><span class="line"></span><br><span class="line">    //抽象怪物类</span><br><span class="line">    abstract class Mob</span><br><span class="line">    &#123;</span><br><span class="line">        //定义攻击接口（规定每个继承自此抽象类的怪物都能进行攻击）</span><br><span class="line">        public abstract void Attack(); </span><br><span class="line">    &#125;</span><br><span class="line">    //小怪A</span><br><span class="line">    class MobA : Mob</span><br><span class="line">    &#123;</span><br><span class="line">        //重写Acctak方法</span><br><span class="line">        public override void Attack()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;MobA 进行攻击&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //小怪B</span><br><span class="line">    class MobB : Mob</span><br><span class="line">    &#123;</span><br><span class="line">        //重写Acctak方法</span><br><span class="line">        public override void Attack()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;MobB 进行攻击&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //小怪C</span><br><span class="line">    class MobC : Mob</span><br><span class="line">    &#123;</span><br><span class="line">        //重写Acctak方法</span><br><span class="line">        public override void Attack()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;MobC 进行攻击&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Test</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Mob mob = MobFactory.GetMob(&quot;MobA&quot;);</span><br><span class="line">            mob.Attack();                                           //MobA进行攻击</span><br><span class="line">            mob = MobFactory.GetMob(&quot;MobB&quot;);</span><br><span class="line">            mob.Attack();                                           //MobB进行攻击</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简单工厂模式分析</strong>    </p><blockquote><ul><li>将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。    </li><li>对于简单工厂模式，由于其方法是静态的，因此使用起来比较方便。   </li><li>简单工厂模式虽然满足单一职则原则，不过工厂类的职责相对过重，而且增加新的产品时需要修改工厂类的判断逻辑，不符合开闭原则。</li></ul></blockquote><p> <strong>模式优缺点及使用场景</strong>   </p><ul><li><p>优点   </p><blockquote><ul><li>简单工厂模式实现了对责任的分割，它提供了专门的工厂类用于创建对象，降低系统的耦合度。    </li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可。   </li></ul></blockquote></li><li><p>缺点</p><blockquote><ul><li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。   </li><li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。   </li><li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。   </li><li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。   </li></ul></blockquote></li><li><p>使用场景   </p><blockquote><p>当需要创建的对象较少且以后基本上不要增加新的对象时，用这个工厂方式还是不错的。</p></blockquote></li></ul><h3 id="2、工厂方法模式-Factory-Pattern"><a href="#2、工厂方法模式-Factory-Pattern" class="headerlink" title="2、工厂方法模式(Factory Pattern)"></a>2、工厂方法模式(Factory Pattern)</h3><blockquote><p>又被称多态性工厂模式。在这个模式中，不再使用一个类创建所有的产品实例，而是实现一个抽象的工厂父类角色，然后为每个产品都实现一个具体的工厂子类，抽象工厂父类角色，仅负责给出具体工厂子类必须实现的接口，而具体的创建对象的逻辑在子类中实现。   </p></blockquote><ul><li>工厂方法模式包含的角色：   <ul><li>抽象工厂类：所有具体工厂的父类，规定工厂子类应实现哪些接口。   </li><li>具体工厂类：继承自抽象工厂类，用于创建一个特定的产品。   </li><li>抽象产品类：所有具体产品的父类，负责定义其它具体产品的所共有的公共接口    </li><li>具体产品类：继承自抽象产品类，是具体工厂类角色的创建目标。    </li></ul></li></ul><blockquote><p>根据上述例子实现的具体代码为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">namespace FactoryPattern</span><br><span class="line">&#123;</span><br><span class="line">    //怪物接口</span><br><span class="line">    interface Mob</span><br><span class="line">    &#123;</span><br><span class="line">        void Attack();</span><br><span class="line">    &#125;</span><br><span class="line">    //小怪A</span><br><span class="line">    class MobA : Mob</span><br><span class="line">    &#123;</span><br><span class="line">        //重写Acctak方法</span><br><span class="line">        public void Attack()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;MobA 进行攻击&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //小怪B</span><br><span class="line">    class MobB : Mob</span><br><span class="line">    &#123;</span><br><span class="line">        //重写Acctak方法</span><br><span class="line">        public void Attack()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;MobB 进行攻击&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //小怪C</span><br><span class="line">    class MobC : Mob</span><br><span class="line">    &#123;</span><br><span class="line">        //重写Acctak方法</span><br><span class="line">        public void Attack()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;MobC 进行攻击&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //抽象工厂接口</span><br><span class="line">    interface Factory</span><br><span class="line">    &#123;</span><br><span class="line">        Mob GetMob();</span><br><span class="line">    &#125;</span><br><span class="line">    //创建怪物A的工厂</span><br><span class="line">    class MobA_Factory : Factory</span><br><span class="line">    &#123;</span><br><span class="line">        public Mob GetMob()</span><br><span class="line">        &#123;</span><br><span class="line">            return new MobA();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //创建怪物B的工厂</span><br><span class="line">    class MobB_Factory : Factory</span><br><span class="line">    &#123;</span><br><span class="line">        public Mob GetMob()</span><br><span class="line">        &#123;</span><br><span class="line">            return new MobB();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //创建怪物C的工厂</span><br><span class="line">    class MobC_Factory : Factory</span><br><span class="line">    &#123;</span><br><span class="line">        public Mob GetMob()</span><br><span class="line">        &#123;</span><br><span class="line">            return new MobC();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Test</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            //获得小怪A</span><br><span class="line">            Factory factory = new MobA_Factory();</span><br><span class="line">            Mob mob = factory.GetMob();</span><br><span class="line">            mob.Attack();</span><br><span class="line">            //获得小怪B</span><br><span class="line">            factory = new MobB_Factory();</span><br><span class="line">            mob = factory.GetMob();</span><br><span class="line">            mob.Attack();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工厂方法模式分析</strong>   </p><blockquote><p>在这个模式中，将每个具体产品的创建细节分配给每个具体的工厂来实现，这样做不仅使工厂方法具有简单工厂方法的优点，还解决了简单工厂模式职责过重的问题。不过由于每个产品类都要对应一个工厂类，因此使用此模式时，会在一定程度上增加系统的复杂性。</p></blockquote><p><strong>优点</strong>     </p><blockquote><p>工厂方法模式除了具有简单工厂模式的优点外，还具有以下优点：   </p></blockquote><ul><li>进一步的细化了工厂类的职责，真正的实现了在创建实例这块的高内聚、低耦合。   </li><li>当一个工厂出现问题时不会影响到其他工厂，提高了程序的健壮性。   </li><li>提高了程序的灵活性，当新添加一个产品时，只需添加一个产品类和相应产品的工厂类即可。   </li></ul><p><strong>缺点</strong></p><ul><li>要为每个产品类创建具体工厂，增加了代码量。（个人感觉有其优点相比，这点缺点可以忽略了）</li></ul><p><strong>应用场景</strong> </p><h4 id="产品等级结构与产品族"><a href="#产品等级结构与产品族" class="headerlink" title="产品等级结构与产品族"></a>产品等级结构与产品族</h4><blockquote><ul><li>产品等级结构：即产品的继承结构，如在上面所用到的例子中，抽象怪物类Mob与小怪MobA、小怪MobB、小怪MobC之间便构成了一个产品等级结构，抽象怪物类是父类，而不同种类的小怪是其子类。   </li><li>产品族：在抽象工厂模式中会提到，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。</li></ul></blockquote><p><img src="http://p.qpic.cn/pic_wework/1948211503/f6f018f9ede8d36a07519fb4fbff98f0bf32c401b7f50c90/0" alt=""></p><h3 id="3、抽象工厂模式"><a href="#3、抽象工厂模式" class="headerlink" title="3、抽象工厂模式"></a>3、抽象工厂模式</h3><blockquote><p>抽象工厂模式是当有多个抽象产品时所使用的一种工厂模式。它和工厂方法模式很像，可以把工厂方法模式当成是产品族为1时的抽象工厂模式。   </p></blockquote><ul><li>抽象工厂模式包含的角色：   <ul><li>抽象工厂类：所有具体工厂的父类，实现对具体工厂的规范。   </li><li>具体工厂类：继承自抽象工厂类，用于创建某个产品族中的的产具体产品。   </li><li>抽象产品类：所有具体产品的父类，负责定义其它具体产品的所共有的公共接口    </li><li>具体产品类：继承自抽象产品类，是具体工厂类角色的创建目标之一。   </li></ul></li></ul><blockquote><p>修改一下上面那个例子，除了怪物类外，现在还要新添加一个武器类，武器类中包括武器WpA、WpB、WpC；怪物MobA使用WpA，怪物MobB使用WpB，怪物MobC使用WpC；<br>使用抽象工厂模式实现怪物和武器生成的代码如下：   </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">//怪物接口</span><br><span class="line">interface Mob</span><br><span class="line">&#123;</span><br><span class="line">    void Attack();</span><br><span class="line">&#125;</span><br><span class="line">//小怪A</span><br><span class="line">class MobA : Mob</span><br><span class="line">&#123;</span><br><span class="line">    //重写Acctak方法</span><br><span class="line">    public void Attack()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;MobA 进行攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//小怪B</span><br><span class="line">class MobB : Mob</span><br><span class="line">&#123;</span><br><span class="line">    //重写Acctak方法</span><br><span class="line">    public void Attack()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;MobB 进行攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//小怪C</span><br><span class="line">class MobC : Mob</span><br><span class="line">&#123;</span><br><span class="line">    //重写Acctak方法</span><br><span class="line">    public void Attack()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;MobC 进行攻击&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//武器接口</span><br><span class="line">interface Wp</span><br><span class="line">&#123;</span><br><span class="line">    //攻击加成</span><br><span class="line">    void AtkAdd();</span><br><span class="line">&#125;</span><br><span class="line">//武器WpA</span><br><span class="line">class WpA : Wp</span><br><span class="line">&#123;</span><br><span class="line">    public void AtkAdd()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;MobA专属武器，MobA提高了攻击力&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//武器WpA</span><br><span class="line">class WpB : Wp</span><br><span class="line">&#123;</span><br><span class="line">    public void AtkAdd()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;MobB专属武器，MobB提高了攻击力&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//武器WpC</span><br><span class="line">class WpC : Wp</span><br><span class="line">&#123;</span><br><span class="line">    public void AtkAdd()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;MobC专属武器，MobC提高了攻击力&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂接口</span><br><span class="line">interface Factory</span><br><span class="line">&#123;</span><br><span class="line">    //获取怪物实例的方法</span><br><span class="line">    Mob GetMob();</span><br><span class="line">    //获取武器实例的方法</span><br><span class="line">    Wp GetWp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//A类怪物武器产品族工厂</span><br><span class="line">class A_Factory : Factory</span><br><span class="line">&#123;</span><br><span class="line">    //获取怪物实例的方法</span><br><span class="line">    public Mob GetMob() &#123;</span><br><span class="line">        return new MobA();</span><br><span class="line">    &#125;</span><br><span class="line">    //获取武器实例的方法</span><br><span class="line">    public Wp GetWp()</span><br><span class="line">    &#123;</span><br><span class="line">        return new WpA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//A类怪物武器产品族工厂</span><br><span class="line">class B_Factory : Factory</span><br><span class="line">&#123;</span><br><span class="line">    //获取怪物实例的方法</span><br><span class="line">    public Mob GetMob()</span><br><span class="line">    &#123;</span><br><span class="line">        return new MobB();</span><br><span class="line">    &#125;</span><br><span class="line">    //获取武器实例的方法</span><br><span class="line">    public Wp GetWp()</span><br><span class="line">    &#123;</span><br><span class="line">        return new WpB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//A类怪物武器产品族工厂</span><br><span class="line">class C_Factory : Factory</span><br><span class="line">&#123;</span><br><span class="line">    //获取怪物实例的方法</span><br><span class="line">    public Mob GetMob()</span><br><span class="line">    &#123;</span><br><span class="line">        return new MobC();</span><br><span class="line">    &#125;</span><br><span class="line">    //获取武器实例的方法</span><br><span class="line">    public Wp GetWp()</span><br><span class="line">    &#123;</span><br><span class="line">        return new WpC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        //A类产品族工厂</span><br><span class="line">        Factory factory = new A_Factory();</span><br><span class="line">        Mob moba = factory.GetMob();</span><br><span class="line">        Wp wpa = factory.GetWp();</span><br><span class="line">        wpa.AtkAdd();</span><br><span class="line">        moba.Attack();</span><br><span class="line"></span><br><span class="line">        //B类产品族工厂</span><br><span class="line">        factory = new C_Factory();</span><br><span class="line">        Mob mobb = factory.GetMob();</span><br><span class="line">        Wp wpb = factory.GetWp();</span><br><span class="line">        wpb.AtkAdd();</span><br><span class="line">        mobb.Attack();</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>抽象工厂模式分析</strong>   </p><blockquote><p>抽象工厂模式符合单一职责原则、开闭原则、里氏替换原则、依赖倒置原则。它为具有多个产品结构的程序提供了一种获得产品实例的方法。</p></blockquote><p><strong>抽象工厂的优缺点</strong> </p><ul><li>优点：   </li><li><p>工厂方法模式除了具有简单工厂模式的优点外，还具有以下优点：   </p><ul><li>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</li><li>增加新的产品族时很方便，只需添加生产相应产品族实例的工厂即可，无须修改已有系统。</li></ul></li><li><p>缺点：   </p><ul><li>当增加新的产品等级结构时，需要对抽象工厂和具体工厂类进行修改，不符合开闭原则。   </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL-map和multimap</title>
      <link href="/2019/03/17/STL-map%E5%92%8Cmultimap/"/>
      <url>/2019/03/17/STL-map%E5%92%8Cmultimap/</url>
      
        <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote><p>map与multimap是键值对容器，支持根据键查找值。multimap可以储存重复的键，而前者只能储存唯一的键。使用两者之前要包含时头文件<map><br>为实现快速查找，map与multimap的内部结构看起来像二叉树，这意味着在map或multimap中插入数据时将对其进行排序；因此，位于map中特定位置的元素不能替换为值不同的新元素。   </map></p></blockquote><p><strong>map及multimap的实例化</strong>   </p><ul><li><p>实例化map和multimap的语法如下：   </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">map</span>&lt;keyType, valueType, Predicate = <span class="built_in">std</span>::less&lt;keyType&gt;&gt; mapObject;</span><br><span class="line"><span class="built_in">multimap</span>&lt;keyType, valueType, Predicate = <span class="built_in">std</span>::less&lt;keyType&gt;&gt; multimapObject;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>其中Predicate可图换为自定义谓词———一个实现了operator()的类或结构。例：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现从大到小排序的谓词</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> KeyType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReverseSort</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> KeyType&amp; key1, <span class="keyword">const</span> KeyType&amp; key2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (key1 &gt; key2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入元素</strong></p><blockquote><p>在两种容器之中插入元素时，都可以使用成员函数insert:<br><code>map&lt;int, string&gt; mapInt_String</code><br><code>mapInt_String.insert(make_pair(0, &quot;Number One&quot;));</code><br><code>mapInt_String.insert(pair&lt;int, string&gt;(2, &quot;Number Two&quot;));</code>      </p><ul><li><strong>std::pair</strong><br>主要作用是将两个数据组合成一个数据，两个数据可以是同一类型或者不同类型。<br>pair实质上是一个结构体，其主要的两个成员变量是<strong>first</strong>和<strong>second</strong>，这两个变量可以直接使用。<br>初始化一个pair可以使用构造函数，也可以使用std::make_pair函数。<br>make_pair函数的定义如下：<br>  <code>template pair make_pair(T1 a, T2 b) { return pair(a, b); }</code><br>在需要pair类型做参数的位置，可以直接调用make_pair生成pair对象。<br>mark_pair可以接受隐式的类型转换，这样可以获得更高的灵活度。但是这样会出现如下问题：<br>例如有如下两个定义：   <pre><code>`std::pair&lt;int, float&gt;(1, 1.1);`    `std::make_pair(1, 1.1);`    </code></pre>使用构造函数生成的pair对象的second变量是float类型，而用make_pair生成的pair对象的second变量将是double类型。   </li></ul></blockquote><p><strong>查找元素</strong></p><blockquote><p>可使用成员方法find在这两个容器中查找元素。find返回一个迭代器：<br><code>auto iPairFind = mapInt_String.find(key);</code><br>使用迭代器iPairFind之前，要检查该迭代器：<br><code>if(iPairFind != mapInt_String.end())</code>   </p><ul><li>注意：<br>在multimap中，因为key值不唯一，因此在使用find查找元素时，返回的迭代器指向首次查找得到的元素。如果想得到所有值，应该使用multimap::count()确定有多少值与指定的key对应。   </li></ul></blockquote><p><strong>删除元素</strong>   </p><blockquote><p>使用成员函数erase对来删除元素。   </p><ul><li>通过指定的key来删除元素：<br><code>mapObject.erase(key);</code>   </li><li>删除迭代器指向的元素：<br><code>mapObject.erase(iElement);</code>      </li><li>使用迭代器指定边界，删除指定范围内的所有元素：<br><code>mapObject.erase(iLowBound, iUpperBound);</code>   </li></ul></blockquote><p><strong>std::unordered_map与std::unordered_multimap</strong>   </p><blockquote><p>从C++11起，STL支持散列映射——std::unordered_map,使用时需包含头文件&lt;unordered_map&gt;<br>unordered_map的的平均插入和删除时间是固定的，查找元素的时间也是固定的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL简介及其环境配置</title>
      <link href="/2019/03/17/OpenGL%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/03/17/OpenGL%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="涉及内容简介"><a href="#涉及内容简介" class="headerlink" title="涉及内容简介"></a>涉及内容简介</h3><blockquote><p><strong>OpenGL</strong><br>一般它被认为是一个API(Application Programming Interface, 应用程序编程接口)，包含了一系列可以操作图形、图像的函数。然而，OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范。具体的实现是由驱动开发商针对特定显卡实现的。<br><strong>GLFW(Graphics Library Framework)</strong><br>GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。可认为是符合OpenGL规范的具体的库。<br><strong>GLAD</strong><br>由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。所以任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。<br>GLAD用来帮助开发者解决这个问题。（不用自己手动编写代码查询函数了）</p></blockquote><blockquote><blockquote><p>渲染（render）：它表示计算机从模型创建最终图像的过程。   </p></blockquote></blockquote><h3 id="编译环境配置"><a href="#编译环境配置" class="headerlink" title="编译环境配置"></a>编译环境配置</h3><blockquote><p>GLFW只是实现了OpenGL规范的具体库中的一个，其他比较流行的还有GLUT，SDL，SFML；<br>我选择使用GLFW。   </p></blockquote><ul><li><p>下载GLFW源文件：<a href="http://www.glfw.org/download.html" target="_blank" rel="noopener">官网（需翻墙）</a><br>打开后点击<strong>Source Package</strong>按钮进行下载。</p></li><li><p>下载cMake：<a href="https://cmake.org/download/" target="_blank" rel="noopener">官网（需翻墙）</a><br>打开后选择32位的下载就行。 下载按钮长这样<code>cmake-3.14.0-win32-x86.zip</code></p></li></ul><blockquote><p>cMake: CMake是一个工程文件生成工具。用户可以使用预定义好的CMake脚本，根据自己的选择（像是Visual Studio, Code::Blocks, Eclipse）生成不同IDE的工程文件。</p></blockquote><p>1、下载好cMake并安装成功后，打开cMake；点击<strong>Browsere Source…</strong>按钮选择glfw压缩包解压后的整个文件夹    </p><p>2、点击 <strong>Browsere Build…</strong> 选择一个文件夹（最好新建一个空的）来存放编译后的文件。  </p><p>3、点击 <strong>Configure</strong> (设置)按钮。选择工程的生成器，由于我们使用的是Visual Studio 2015，我们选择 Visual Studio 14 选项（因为Visual Studio 2015的内部版本号是14）。 </p><p>4、点击 <strong>Finish</strong> (完成)按钮保存设置。保存之后，点击Generate(生成)按钮，生成的工程文件会在你第二步选择的文件夹中（假设这个文件夹名为build）。   </p><p>5、在build文件夹中点击 <strong>GLFW.sln</strong> 打开项目，然后对其进行编译。   </p><p>6、编译通过后在bulid/src/Debug文件夹中找到库 <strong>glfw3.lib</strong> （注意我们用的是第3版）</p><p>7、推荐建立一个新的目录包含所有的第三方库文件和头文件，每次新建一个工程时都需要指定这些文件夹。<strong>可以使用一个单独的文件夹，里面包含libs和include文件夹，在这里存放OpenGL工程用到的所有第三方库和头文件。</strong>将第6步的库 <strong>glfw3.lib</strong> 放到libs文件夹下。</p><ul><li>打开GLAD:<a href="http://glad.dav1d.de/" target="_blank" rel="noopener">官网（再翻次吧）</a>   </li></ul><p>GLAD是在线服务，将语言(Language)设置为C/C++，在API选项中，选择3.3以上的OpenGL(gl)版本（我们的教程中将使用3.3版本，但更新的版本也能正常工作）。之后将模式(Profile)设置为Core，并且保证生成加载器(Generate a loader)的选项是选中的。现在可以先（暂时）忽略拓展(Extensions)中的内容。都选择完之后，点击生成(Generate)按钮来生成库文件。<br>GLAD现在应该提供给你了一个zip压缩文件，包含两个头文件目录，和一个glad.c文件。将两个头文件目录（glad和KHR）复制到你的 <strong>include</strong> 文件夹中，可以将glad.c文件储存到你的include文件夹下（便于寻找）。</p><blockquote><p>经过上面的操作我们已经得到了OpenGL工程中所需要的库和头文件了（bulid文件夹下的所有东西，一定要保存好）；接下来开始配置开发环境吧。</p><blockquote><p>使用VS创建一个Visual C++ 常规空项目。<br>打开 <strong>解决方案资源管理器</strong> 在项目名称上点击右键——&gt;属性，然后在配置属性下选择VC++目录，编辑 <strong>包含目录</strong> 和 <strong>库目录</strong> 分别选择我们的 <strong>build</strong> 文件夹中的 <strong>include</strong> 目录和 <strong>libs</strong> 目录。     </p></blockquote></blockquote><blockquote><blockquote><p>在配置属性下选择链接器——&gt;输入，编辑附加依赖项，输入格式为：opengl32.lib 回车 glfw3.lib 然后点击确定按钮。</p></blockquote></blockquote><blockquote><p>在配置属性页面确定修改后，环境配置便结束了。在当前项目中新建一个.cpp文件，将下面的代码复制过去，若果能编译且运行成功的话，恭喜你，OK了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">glfwInit();</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">GLFWwindow* window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">"SUCCESS"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create the windows"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">glfwTerminate();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">glfwMakeContextCurrent(window);</span><br><span class="line">glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!glfwWindowShouldClose(window)) &#123;</span><br><span class="line"></span><br><span class="line">processInput(window);</span><br><span class="line">glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">glfwSwapBuffers(window);</span><br><span class="line">glfwPollEvents();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glfwTerminate();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* windows, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;</span><br><span class="line">glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL-set和multiset</title>
      <link href="/2019/03/16/STL-set%E5%92%8Cmultiset/"/>
      <url>/2019/03/16/STL-set%E5%92%8Cmultiset/</url>
      
        <content type="html"><![CDATA[<ul><li><p><strong>简介</strong></p><blockquote><p>使用set与multiset时需要包含头文件 &lt;set><br>set与multiset让使用者能够在容器中快速查找键（键是储存在一维容器中的值），set和multiset的区别在于set中键值要求唯一，后者可以重复。<br>set与multiset的内部结构像是二叉树，插入与素时要对元素进行排序，因此，相对于vector，list那些容器，set与multiset在插入新元素时效率较低（有额外排序开销），在元素查找方面效率较高。因此，它们适用于那些需要频繁查找的程序中。      </p><blockquote><p>set与multiset操作相似，下面的介绍以set为例。   </p></blockquote></blockquote></li><li><p><strong>实例化set</strong></p><blockquote><p>实例化一个特定类型的set,以int类型为例：</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; intSet;</span><br></pre></td></tr></table></figure><blockquote><p>set与multiset在元素插入时对其进行排序，默认使用std::less对插入数据进行排序。<br>要创建二元谓词，可在类中定义一个operator()：   </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SortStandard</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//从大到小排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> T&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (lhs &gt; rhs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//指定排序规则的初始化操作</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, SortStandard&lt;<span class="keyword">int</span>&gt;&gt; intSet;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&gt;也可以使用另外一个<span class="built_in">set</span>或者两个<span class="built_in">set</span>迭代器对其进行初始化：</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, SortStandard&lt;<span class="keyword">int</span>&gt;&gt; intSet;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; intSet1(intSet.cbegin(), intSet.cend());</span><br><span class="line"><span class="comment">//这里不能用intSet初始化intSet，因为他们两个排序方式不一样</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; intSet2(intSet1);</span><br><span class="line">&gt;**注意：** 上面代码中不能用intSet初始化intSet，因为他们的排序方式不同。</span><br></pre></td></tr></table></figure><ul><li><strong>插入元素</strong>   </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;使用成员函数insert()进行元素插入操作。   </span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; intSet;</span><br><span class="line"></span><br><span class="line">intSet.insert(<span class="number">-1</span>);</span><br><span class="line">intSet.insert(<span class="number">600</span>);</span><br><span class="line">intSet.insert(<span class="number">66</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; intSet1;</span><br><span class="line">intSet1.insert(intSet.cbegin(), intSet.cend());</span><br><span class="line"><span class="keyword">auto</span> pos = ++intSet1.begin();</span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="comment">//*pos = 16;</span></span><br></pre></td></tr></table></figure><blockquote><p>无论使用begin()还是cbegin()获得的迭代器，都不等对*pos进行赋值操作，因为set不允许改变其内元素的值。<br>set也不能使用 [] 操作符获取元素的值；可以使用迭代器来获取元素值。   </p></blockquote><ul><li><strong>删除元素</strong>   <blockquote><p>关联容器都提供了成员函数erase()。<br>1、根据键删除值：<br>setObject.erase(key);<br>2、传入一个迭代器，删除迭代器指向的值：<br>setObject.erase(iElement);<br>3、使用迭代器指定边界，删除边界内的所有元素：<br>setObject.erase(iLowerBound, iUpperBound);   </p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; intSet;</span><br><span class="line">intSet.insert(<span class="number">-1</span>);</span><br><span class="line">intSet.insert(<span class="number">600</span>);</span><br><span class="line">intSet.insert(<span class="number">66</span>);</span><br><span class="line"></span><br><span class="line">intSet.erase(<span class="number">66</span>);</span><br><span class="line">intSet.erase(++intSet.begin(), intSet.end());</span><br></pre></td></tr></table></figure><blockquote><p>当multiset存在多个相同的值时，用setObject.erase(key)删除值时，会将他们全部删除。   </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; intSet;</span><br><span class="line">intSet.insert(<span class="number">66</span>);</span><br><span class="line">intSet.insert(<span class="number">600</span>);</span><br><span class="line">intSet.insert(<span class="number">66</span>);</span><br><span class="line"></span><br><span class="line">intSet.erase(<span class="number">66</span>);</span><br></pre></td></tr></table></figure><p><strong>C++11</strong></p><blockquote><p>在C++11中，新增加了散列集合unordered_set和unordered_multiset；它们相对于set和multiset进一步的改善了性能。他们使用散列函数来计算排序索引。   </p><blockquote><p>使用时添加头文件&lt;unordered_set></p></blockquote></blockquote><p><strong>注意</strong>，将对象储存到set或multiset中时，别忘了在类中实现运算符&lt;和==，前者将成为排序谓词，后者用于find()函数。   </p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL-list和forward_list</title>
      <link href="/2019/03/16/STL-list%E5%92%8Cforward-list/"/>
      <url>/2019/03/16/STL-list%E5%92%8Cforward-list/</url>
      
        <content type="html"><![CDATA[<ul><li><p><strong>list的特点</strong>   </p><blockquote><p>在list开头、中间、末尾插入数据，所需时间都是固定的，将元素从list中产出所需的时间是固定的。插入或者删除元素后，指向list中其他元素的迭代器仍然有效。<br>不过搜索速度比vector慢，因为元素没有储存在连续的内存单元中。   </p></blockquote></li><li><p><strong>插入元素</strong>   </p><blockquote><p>使用成员函数push_back()和push_front在list末尾和开头插入元素，使用成员函数insert在list中插入元素。  </p></blockquote>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; intList(<span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line">intList.push_front(<span class="number">5</span>);</span><br><span class="line">intList.push_back(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在迭代器指向的位置添加一个元素</span></span><br><span class="line">intList.insert(intList.begin(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在迭代器指向的位置添加指定数量的某个元素</span></span><br><span class="line">intList.insert(intList.end(), <span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在迭代器指向的位置插入某个容器两个迭代器之间的元素</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; anoList(<span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">intList.insert(intList.end(), anoList.begin(), anoList.end());</span><br></pre></td></tr></table></figure></li><li><p><strong>删除元素</strong></p><blockquote><p>使用list::erase()来删除list中的元素，他有两个重载版本，一个版本接受一个迭代器并删除迭代器指向的元素，另一个接受两个迭代器参数并删除指定范围内的所有元素。</p></blockquote></li><li><p><strong>元素反转和排序</strong></p><blockquote><p>使用list的成员方法reverse()和sort()对list进行反转和排序，执行者两个操作后之前指向元素的迭代器仍然有效。   </p></blockquote>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; intList;</span><br><span class="line">intList.push_back(<span class="number">7</span>);</span><br><span class="line">intList.push_front(<span class="number">5</span>);</span><br><span class="line">intList.push_back(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> int6 = --intList.end();<span class="comment">//6</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator int7 = ++intList.begin();<span class="comment">//7</span></span><br><span class="line"><span class="comment">//反转</span></span><br><span class="line">intList.reverse();</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">intList.sort();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *int6 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//6</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *int7 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//7 </span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">&gt;其中排序方法sort()还有一个重载版本，接受一个二元谓词作为参数：</span><br><span class="line"></span><br><span class="line">```c++ </span><br><span class="line"><span class="comment">//从大到小排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MySortStandard</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; lsh, <span class="keyword">const</span> <span class="keyword">int</span>&amp; rsh)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (lsh &gt; rsh);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">intList.sort(MySortStandard);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>STL forward_list</strong></p><blockquote><p>从c++11起，可以使用单向链表forward_list;<br>使用时需要包含头文件 &lt;forward_list&gt;<br>使用forward时，只能使用push_front()函数在开头插入元素，其他操作与list很像。   </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL-vector</title>
      <link href="/2019/03/15/STL-vector/"/>
      <url>/2019/03/15/STL-vector/</url>
      
        <content type="html"><![CDATA[<h2 id="STL-vector"><a href="#STL-vector" class="headerlink" title="STL vector"></a>STL vector</h2><blockquote><p>使用vector时需要包含头文件<strong>&lt;vector></strong> </p></blockquote><ul><li><p><strong>vector的特点</strong><br>vector动态数组类：<br>1、无论数组中存在多少元素，在数组末尾添加新元素时所需时间都是固定的。<br>2、在数组中间添加或者删除元素时，与<strong>该元素后面的元素个数</strong>成正比。<br>3、储存的元素是动态的，vector类负责管理内存。   </p></li><li><p><strong>vector的初始化</strong>   </p><blockquote><p>下面的代码介绍了vector的几种初始化方法。   </p></blockquote>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVec;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化时设置至少包含的元素数（并没有限制大小），每个元素初始值默认为0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVec1(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//同上，并设置每个元素的初始化值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVec2(<span class="number">10</span>, <span class="number">66</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用另外一个vector来初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVec3(intVec2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用另一个vector的两个迭代器来初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVec4(intVec2.cbegin(), intVec2.cbegin() + <span class="number">5</span>);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>cbegin()和cend()是C++11新增的，它们返回一个const的迭代器，不能用于修改元素。</p></blockquote><ul><li><p><strong>vector插入元素</strong></p><blockquote><p>使用成员函数push_back()在容器末尾插入元素；使用insert()在指定位置插入元素。   </p></blockquote>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVec(<span class="number">5</span>);</span><br><span class="line">intVec.push_back(<span class="number">66</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; intVec.size() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在指定位置插入元素</span></span><br><span class="line">intVec.insert(intVec.begin(), <span class="number">67</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在指定位置插入指定个数的某个元素</span></span><br><span class="line">intVec.insert(intVec.begin(), <span class="number">2</span>, <span class="number">66</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在指定位置插入另一个vector的内容(使用迭代器指定范围)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; anoVec(<span class="number">3</span>, <span class="number">65</span>);</span><br><span class="line">intVec.insert(intVec.begin(), </span><br><span class="line">anoVec.begin(), anoVec.end());</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>使用insert插入元素时，效率较低，与其特点有关。   </p></blockquote><ul><li><p><strong>访问vector中的元素</strong></p><blockquote><p>使用下标用算符[]访问元素，超出容器边界时结果不确定。<br>使用成员方法at()访问元素，超出容器边界时将会报错。<br>使用迭代器访问元素。   </p></blockquote>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVec;</span><br><span class="line">intVec.push_back(<span class="number">64</span>);</span><br><span class="line">intVec.push_back(<span class="number">65</span>);</span><br><span class="line">intVec.push_back(<span class="number">66</span>);</span><br><span class="line"><span class="comment">//使用 [] 访问元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; intVec.size(); ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; intVec[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用 at() 访问元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; intVec.size(); ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; intVec.at(i) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用迭代器访问元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator pos = intVec.begin()</span><br><span class="line">; pos != intVec.end()</span><br><span class="line">; ++pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除vector中的元素</strong></p><blockquote><p>使用pop_back()从vector中删除元素所需要的时间是固定的。<br>不能使用偏移位置和元素数删除指定个数的元素。   </p></blockquote>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVec;</span><br><span class="line">intVec.push_back(<span class="number">64</span>);</span><br><span class="line">intVec.push_back(<span class="number">65</span>);</span><br><span class="line">intVec.push_back(<span class="number">66</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除vector末尾的元素</span></span><br><span class="line">intVec.pop_back();</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除迭代器指向的元素</span></span><br><span class="line">intVec.erase(intVec.begin());</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除两个迭代器之间的元素</span></span><br><span class="line">intVec.erase(intVec.begin(), intVec.begin() + <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>大小和容量的区别</strong></p><blockquote><p>可以通过成员函数size()和capacity()来获取vector的大小和容量。<br><strong>容量</strong>总是大于等于<strong>大小</strong>，当当前容量不足时，重新分配容量时，会分配比当前所需容量更大的容量（比如容量满时再插入数据时，可能会分配两个元素的容量，或者更多）。<br>可使用成员函数reserve(number),设置当前容器的容量（如果传入的number小于size的话，默认使用size的值。）   </p></blockquote></li></ul><h3 id="STL-deque"><a href="#STL-deque" class="headerlink" title="STL deque"></a>STL deque</h3><blockquote><p>发音：/dek/<br>使用时要包含头文件 <deque><br>deque与vector极其相似，只是可以使用成员函数push_front()和pop_frone()在开头插入和删除元素。      </deque></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL-string</title>
      <link href="/2019/03/13/STL-string/"/>
      <url>/2019/03/13/STL-string/</url>
      
        <content type="html"><![CDATA[<h2 id="STL简介"><a href="#STL简介" class="headerlink" title="STL简介"></a>STL简介</h2><p>标准模板库是一组<strong>模板类和函数</strong>，向程序员提供了：  </p><ol><li>用于储存信息的<strong>容器</strong>   </li><li>用于访问容器储存的信息的<strong>迭代器</strong>   </li><li>用于操作容器内容的<strong>算法</strong>   </li></ol><p>其中，容器又包含：</p><ul><li><p>顺序容器    </p><ul><li>std::vector——与动态数组类似，在最后插入数据。   </li><li>std::deque——与std::vector类似，允许在开头添加或删除数据。   </li><li>std::list——与双向链表类似。   </li><li>std::forward_list——类似于std::list，不过是单向链表。   </li></ul></li><li><p>关联容器  </p><ul><li><p>std::set——储存各不相同的值，在插入时进行排序。（对数复杂度）<br>std::unordered_set——c++11新增的，与set相同。（复杂度为常数）   </p></li><li><p>std::map——储存键值对，并根据唯一的键排序。（对数复杂度）<br>std::unordered_map——c++11新增的，与map相同。（复杂度为对数）  </p></li><li><p>std::multiset——与set类似，但值不需要是唯一的。<br>std::unordered_multiset——c++11新增的，与unordered_set类似。但值不需要是唯一的。   </p></li><li><p>std::multimap——与map类似，不要求键是唯一的。<br>std::unordered_multimap——c++11新增的，与unordered_map类似。不要求键是唯一的。    </p></li></ul></li><li><p>容器适配器   </p><ul><li>std::stack：以LIFO(后进先出)的方式储存元素。   <ul><li>std::queue：以FIFO(先进先出)的方式储存元素。   </li><li>std::priority_queue：以特定顺序储存元素。   </li></ul></li></ul></li></ul><p><strong>下文再介绍时，省略了std::</strong></p><p><strong>STL迭代器</strong>   </p><blockquote><p>指针是最简单的迭代器，让该指针指向数组中的第一个元素，然后递增指针以获得下一个元素。<br>STL中的迭代器是模板类，在某种程度上，可以将它理解成泛型指针。    </p></blockquote><p><strong>STL算法</strong></p><blockquote><p>为程序员提供的查找、排序、反转等功能的模板函数。<br>使用STL算法时，要包含<strong>标准头文件<algorihm></algorihm></strong>   </p></blockquote><p>常用STL算法如下：</p><ul><li>std::find: 在集合中查找值。   </li><li>std::find_if: 根据用户指定的谓词在集合中查找值。   </li><li>std::reverse: 反转集合中的元素的排序。   </li><li>std::remove_if: 根据用户定义的谓词将元素从集合中删除。   </li><li>std::transform: 使用用户定义的变换函数对容器中的元素进行变换。   </li></ul><p><strong>使用迭代器在容器和算法之间交互</strong>   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;   </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; IntArray;   </span><br><span class="line">IntArray.push_back(<span class="number">123</span>);</span><br><span class="line">IntArray.push_back(<span class="number">1997</span>);</span><br><span class="line">IntArray.push_back(<span class="number">917</span>);</span><br><span class="line">IntArray.push_back(<span class="number">2019</span>);</span><br><span class="line">IntArray.push_back(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用迭代器遍历容器元素</span></span><br><span class="line"><span class="comment">//for (vector&lt;int&gt;::iterator IA = IntArray.begin(); </span></span><br><span class="line"><span class="comment">//IA &lt; IntArray.end(); ++IA) &#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; *IA &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//使用迭代器遍历容器元素，此处所使用了auto让编译器自动判断类型</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iArrayWalker = IntArray.begin(); </span><br><span class="line">iArrayWalker &lt; IntArray.end(); ++iArrayWalker)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *iArrayWalker &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用find算法在容器中查找元素1997，查到末尾时（end()）还没找到，便返回end()的地址</span></span><br><span class="line"><span class="comment">//vector&lt;int&gt;::iterator value = find(IntArray.begin(), IntArray.end(), 1997);</span></span><br><span class="line"><span class="keyword">auto</span> value = find(IntArray.begin(), IntArray.end(), <span class="number">1997</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否找到元素1997</span></span><br><span class="line"><span class="keyword">if</span> (value != IntArray.end()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"value: "</span> &lt;&lt; *value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//获取1997在容器中的位置，及到begin()的距离</span></span><br><span class="line"><span class="keyword">int</span> index = distance(IntArray.begin(), value);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"index: "</span> &lt;&lt; index &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由上述代码可以看出，迭代器就是获得的是容器中元素的地址；因此，在某种程度上可以将它理解为泛型指针。</p></blockquote><h2 id="STL-string类"><a href="#STL-string类" class="headerlink" title="STL string类"></a>STL string类</h2><blockquote><p>std::stirng与std::wstring是STL库中一个帮助程序员用于字符串操作的容器类。使用时要包含<string>头文件。<br>以std::string为例来介绍这个类的用法。</string></p></blockquote><ul><li><strong>实例化string</strong>   </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* C_StyleString = <span class="string">"Hello String"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cString = <span class="string">"Hello String"</span>;</span><br><span class="line"><span class="comment">//使用构造函数初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(cString)</span></span>;</span><br><span class="line"><span class="comment">//使用等号初始化</span></span><br><span class="line"><span class="built_in">string</span> str1 = cString;</span><br><span class="line"><span class="comment">//使用string类型数据初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">strCopy</span><span class="params">(cString)</span></span>;</span><br><span class="line"><span class="comment">//使用某个字符串的前n位初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str2</span><span class="params">(<span class="string">"Hello String"</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="comment">//使用指定数量的字符初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str3</span><span class="params">(<span class="number">6</span>, <span class="string">'a'</span>)</span></span>;<span class="comment">//str3 = aaaaaa</span></span><br><span class="line"><span class="comment">//string str3(6, 'adf');//str3 = ffffff</span></span><br></pre></td></tr></table></figure><ul><li><strong>访问string的内容</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过[]访问元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过迭代器访问</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">string</span>::const_iterator pos = str.begin()</span><br><span class="line">; pos != str.end()</span><br><span class="line">; ++pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//*pos = 'h';//报错，pos指向的值是const类型的，不可更改</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过迭代器访问</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">string</span>::iterator pos = str.begin()</span><br><span class="line">; pos != str.end()</span><br><span class="line">; ++pos)</span><br><span class="line">&#123;</span><br><span class="line">*pos = <span class="string">'6'</span>;<span class="comment">//不报错</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中使用迭代器时，使用了一个新的迭代器const_iterator,使用它时，迭代器的值可变，但迭代器指向的值的值不可被改变。</p><ul><li><strong>字符串拼接</strong>   </li></ul><p>使用+=或者成员函数append()来拼接字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str4 = <span class="string">"Hello "</span>;</span><br><span class="line"><span class="built_in">string</span> str5 = <span class="string">"World "</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str6</span><span class="params">(<span class="string">"Beautiful!"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">str4 += str5;<span class="comment">//str4 = Hello World </span></span><br><span class="line">str4.append(str6);<span class="comment">//str4 = Hello World Beautiful!</span></span><br></pre></td></tr></table></figure><ul><li><strong>字符/子字符串查找</strong>   </li></ul><p>可以使用string中的成员函数find来查找字符或者子字符串。<br>查找成功返回字符的索引或子字符串首个字符的索引。<br>查找失败返回string::npos（实际值为-1）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str6 = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="comment">//从索引为0初的字符往后进行查找</span></span><br><span class="line"><span class="keyword">int</span> index = str6.find(<span class="string">"World"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; index &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//6</span></span><br><span class="line"><span class="comment">//查找str6中所有 l 的索引</span></span><br><span class="line"><span class="keyword">size_t</span> charPos = str6.find(<span class="string">'l'</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (charPos != <span class="built_in">string</span>::npos) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; charPos &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//2 3 9</span></span><br><span class="line">charPos = str6.find(<span class="string">'l'</span>, ++charPos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>size_t在32位架构上是4字节，在64位架构上是8字节，在不同架构上进行编译时需要注意这个问题。而int在不同架构下都是4字节；且int为带符号数，size_t为无符号数。</p></blockquote><ul><li><strong>字符串截短</strong><br>可以使用成员函数erase()来删除字符串中的字符。<br>使用方法如下： </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> myStr = <span class="string">"Life is always like this."</span>;</span><br></pre></td></tr></table></figure><ol><li>在给定偏移位置（索引值）和指定数目时删除字符。  </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除索引在 区间[14,19) 内的字符串</span></span><br><span class="line">myStr.erase(<span class="number">14</span>,<span class="number">5</span>);<span class="comment">//Life is always this.</span></span><br></pre></td></tr></table></figure><ol start="2"><li>删除迭代器iChar指向的字符。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> iChar = find(myStr.begin(), myStr.end(), <span class="string">'.'</span>);</span><br><span class="line">myStr.erase(iChar);<span class="comment">//Life is always like this</span></span><br></pre></td></tr></table></figure><ol start="3"><li>删除两个迭代器指定范围内的字符串。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myStr.erase(++myStr.begin(), myStr.end());<span class="comment">//L</span></span><br></pre></td></tr></table></figure><p>使用成员方法clear()时，经清楚全部内容并重置string对象。</p><ul><li><strong>字符串反转</strong></li></ul><p>使用泛型算法std::reverse()对字符串进行反转。(注意不是成员方法)<br>reverse接收两个参数，起始迭代器、终止迭代器，然后将对两个迭代器之间的内容进行反转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> myStr = <span class="string">"Life is always like this."</span>;</span><br><span class="line">reverse(++myStr.begin(), myStr.end());<span class="comment">//L.siht ekil syawla si efi</span></span><br></pre></td></tr></table></figure><ul><li><strong>字符串大小写转换</strong>   </li></ul><p>使用算法std::transform()进行大小写转换。(注意不是成员方法)<br>transform(first, last, r_first, trans)接收四个参数：开始迭代器、终止迭代器、开始迭代器、要执行的变换。<br>要执行转大写操作时 trans = toupper, 要执行转小写操作时 trans = tolower。   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> myStr = <span class="string">"life is always like this."</span>;</span><br><span class="line">transform(++myStr.begin(), myStr.end(), ++myStr.begin(), <span class="built_in">toupper</span>);</span><br><span class="line"><span class="comment">//——&gt;lIFE IS ALWAYS LIKE THIS.</span></span><br><span class="line">transform(++myStr.begin(), myStr.end(), ++myStr.begin(), <span class="built_in">tolower</span>);</span><br><span class="line"><span class="comment">//——&gt;life is always like this.</span></span><br></pre></td></tr></table></figure><p>如果要编写的应用程序需要更好的支持非拉丁字符，如中文与日文时，应使用std::wstring。   </p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++模板</title>
      <link href="/2019/03/13/c-%E6%A8%A1%E6%9D%BF/"/>
      <url>/2019/03/13/c-%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>模板可能是c++中最强大最强大却最少被使用（或被理解）的<strong>特性</strong>之一了；我们可以用模板来定义一种适用于<strong>不同类型</strong>的对象的<strong>行为</strong><br>这就像是用#define定义的一个返回两个数中最大值的宏函数那样<br><code>#define MAX_NUM(a, b) ((a) &gt; (b) ? (a) : (b))</code><br>这里的a，b可以是int类型、也可以是其他类型；与“”宏函数不同的是<strong>宏不是类型安全的，而模板是类型安全的</strong>   </p><ul><li>模板函数/类声明语法   </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;参数列表&gt;   </span><br><span class="line">模板函数/类的声明</span><br></pre></td></tr></table></figure><p>参数列表中包含关键字typename，它定义了参数objectTyep，objectType是一个占位符，当对象实例化模板时（创建类实例时）将使用指定的对象类型替换它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板函数   </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;   </span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">GetMax</span><span class="params">(<span class="keyword">const</span> T&amp; num1, <span class="keyword">const</span> T&amp; num2)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num1 &lt; num2)</span><br><span class="line"><span class="keyword">return</span> num2;</span><br><span class="line"><span class="keyword">return</span> num1;   </span><br><span class="line">&#125;   </span><br><span class="line">   </span><br><span class="line"><span class="comment">//模板类   </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Template</span>   </span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">T1 m_Obj1;   </span><br><span class="line">T2 m_Obj2;   </span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">Template(T1 obj1, T2 obj2):   </span><br><span class="line">  m_Obj1(obj1), m_Obj2(obj2)&#123; &#125;   </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;   </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m_Obj1 &lt;&lt; <span class="string">"  "</span> &lt;&lt; m_Obj2 &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;;   </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">Template&lt;<span class="keyword">int</span>, <span class="keyword">float</span>&gt; tem(<span class="number">66</span>, <span class="number">66.6</span>);   </span><br><span class="line">tem.print();   </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; GetMax&lt;<span class="keyword">float</span>&gt;(<span class="number">25.5</span>, <span class="number">123</span>) &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; GetMax(<span class="number">25.5</span>, <span class="number">123.0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中实例化Template类时，将T1指定为int类型，将T2指定为float类型（显式指定）。<br>第一次调用模板函数时，将T指定为float类型；第二次调用时却没有指定类型，但这样也是正确的，这时候，模板函数会自动判断数据的类型（隐式指定）。<br>不过，<strong>对于模板类，必须要显式指定其类型</strong>。   </p><p><strong>声明包含多个参数的模板</strong><br>声明包含多个参数的模板时, 参数之间用逗号隔开：<br><code>template &lt; typename T1, typename T2,...., typename Tn &gt;</code></p><p><strong>声明包含默认参数的模板</strong><br>声明包含默认参数的模板时, 可将它初始化成默认类型：<br><code>template &lt; typename T1 = int, ... , typename tn = int &gt;</code></p><p><strong>*模板类和静态成员</strong><br>在普通的类中，类成员被定义成静态的话，该静态成员被所有实例共享；<br>在模板类中，也类似这样，只不过是被同类型的具体化的实例所共享的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Template</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T m_Obj1;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> T_Num; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getT_Num</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> T_Num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setT_Num</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T_Num = num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员变量的初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Template&lt;T&gt;::T_Num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Template&lt;<span class="keyword">int</span>&gt;::setT_Num(<span class="number">1997</span>);</span><br><span class="line">Template&lt;<span class="keyword">float</span>&gt;::setT_Num(<span class="number">917</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Template&lt;<span class="keyword">int</span>&gt;::getT_Num() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1997</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Template&lt;<span class="keyword">float</span>&gt;::getT_Num() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//917</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中两次输出结果分别是1997、917。你该懂了吧<br><strong>c++中的静态成员变量</strong><br>在c++的类中，如果存在静态成员变量的话，必须对它进行初始化,格式如下：<br><code>&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt; = &lt;值&gt;</code></p><p>模板类中的静态成员变量的初始化格式：（参考上述代码的初始化）<br>template&lt;参数&gt; &lt;数据类型&gt;&lt;类名&lt;参数&gt;&gt;::&lt;静态数据成员名&gt; = &lt;值&gt;   </p><p><strong>c++11</strong><br><strong>使用static_assert执行编译阶段的检查</strong>（类似assert宏）<br>static_assert是c++11中新加的功能（有的编译器不支持），它是一种编译断言，能够在不满足条件时禁止编译。使用格式：<br><code>static _assert(表达式, &quot;表达式为假时输出的错误信息&quot;)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CanNotInt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CanNotInt()&#123;</span><br><span class="line"><span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(T) != <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="string">"No int please"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CanNotInt&lt;<span class="keyword">int</span>&gt; test;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码编译时会报错。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++宏</title>
      <link href="/2019/03/13/c-%E5%AE%8F/"/>
      <url>/2019/03/13/c-%E5%AE%8F/</url>
      
        <content type="html"><![CDATA[<p><strong>前言</strong><br>C++主要有三个编译阶段：<strong>预处理</strong>、<strong>转译成目的码</strong>和<strong>链接</strong>（最后的两个阶段一般才视为真正的“<strong>编译</strong>”）。</p><p><strong>预处理器</strong></p><blockquote><p>预处理器：在编译之前运行的工具,会根据预编译指令对源代码进行“加工”，实际编译的源码是经过预处理器处理过的。<br><strong>预处理器编译指令</strong>是向预处理器发出的命令，总是以符号<strong>#</strong>开头。根据程序员的指示，决定编译器实际要编译的文本内容。<br>比如：对于一个宏<code>#define PI 3.1415</code>，在编译之前，预处理器会在代码中找到 PI 并将它替换为 3.1415 。</p></blockquote><p><strong>使用#define定义常量</strong></p><ul><li>语法： #define identifer(标识符) value(值)<br>栗子：   </li></ul><pre><code class="c++"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415</span><span class="meta">#<span class="meta-keyword">define</span> NICKNAME <span class="meta-string">"f_x"</span></span><span class="meta">#<span class="meta-keyword">define</span> THIS_IS_DOUBLE double</span><span class="meta">#<span class="meta-keyword">define</span> THIS_IS_FOR for</span></code></pre><ul><li>预处理器对宏指定的文本进行简单的替换，因此可以用宏来编写简单的函数<br>栗子：   </li></ul><pre><code class="c++"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415</span><span class="meta">#<span class="meta-keyword">define</span> AREA_CIRCLE(r) ( PI * (r) * (r))</span></code></pre><p><strong>为什么要使用这么多括号？</strong>   </p><blockquote><p>对于上面的宏AREA_CIRCLE,若在代码中这样使用<br><code>cout &lt;&lt; AREA_CIRCLE(4+6);</code><br>使用括号时，经预处理器处理后：<br><code>cout &lt;&lt; (3.1415 * (4 + 6) * (4 + 6))</code><br>不使用括号时：<br><code>cout &lt;&lt; 3.1415 * 4 + 6 * 4 + 6</code><br>你懂。。   </p></blockquote><p><strong>宏的其他作用</strong></p><ul><li>避免头文件的多次包含<br>假设有两个头文件class1.h,class2.h,当我们不得不让两个类相互包含时，对预处理器来说，这样会造成递归问题；<br>为了避免这种问题，可以使用宏和预处理器编译指令#ifndef（if-not-define）和endif。   </li></ul><pre><code class="c++"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADER2_H_H            <span class="comment">//如果宏HEADER2_H_H未定义</span></span><span class="meta">#<span class="meta-keyword">define</span> HEADER2_H_H            <span class="comment">//定义宏HEADER2_H_H</span></span><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;class2.h&gt;</span></span><span class="class"><span class="keyword">class</span> <span class="title">class1</span></span><span class="class">{</span>    ......};<span class="meta">#<span class="meta-keyword">endif</span></span><span class="meta">#<span class="meta-keyword">ifndef</span> HEADER1_H_H            <span class="comment">//如果宏HEADER1_H_H未定义</span></span><span class="meta">#<span class="meta-keyword">define</span> HEADER1_H_H            <span class="comment">//定义宏HEADER1_H_H</span></span><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;class1.h&gt;</span></span><span class="class"><span class="keyword">class</span> <span class="title">class2</span></span><span class="class">{</span>    ......};<span class="meta">#<span class="meta-keyword">endif</span>   </span></code></pre><p>预处理器进行死板的文本替换，这可以减轻程序员的负担，当并不是能减轻编译器的负担。<br>其次，对于宏PI，我们没有太大的控制权，其类型是double还是float？答案是都不是。在预处理器看来，PI就是3.1415，根本不知道其数据类型。<br>所以定义常量时 const 是更好的选择<br><code>const double PI = 3.14215;</code><br><strong>define与const的区别</strong></p><ul><li>起作用的阶段不同：#define在预处理阶段起作用； const在编译或者运行阶段起作用；   </li><li>起作用的方式不同：#define进行简单的文本替换，不能进行类型检查；const定义的常量有对应的数据类型；   </li><li>储存方式不同：#define定义的宏常量在内存中有多个备份，而const定义的常量在内存中只有一个备份；   </li><li>const常量可用于调试，而#define定义的常量不能用于调试（预处理阶段被替换掉了）；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法时间复杂度的计算</title>
      <link href="/2018/11/27/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
      <url>/2018/11/27/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一般用大写O()来表示算法的时间复杂度写法，通常叫做大O记法。<br>一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。 </p></blockquote><p><strong>大O推导法：</strong><br>用常数1取代运行时间中的所有加法常数<br>在修改后的运行函数中，只保留最高阶项<br>如果最高阶项存在且不是1，则去除与这个项相乘的常数    </p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n++;                                      <span class="comment">/*执行次数为1*/</span></span><br><span class="line">function(n);                              <span class="comment">/*执行次数为n*/</span></span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; n ; i++)&#123;                 <span class="comment">/*执行次数为nXn*/</span></span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">function(i);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; n ; i++)&#123;                <span class="comment">/*执行次数为n(n+1)/2*/</span></span><br><span class="line">  <span class="keyword">for</span>(j = i ; j &lt; n ; j++)&#123;</span><br><span class="line">      <span class="comment">/*时间复杂度为O(1)的程序*/</span>  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的执行次数<strong>f(n) = 1 + n + n^2 + n(n+1)/2</strong>,根据推导大O阶的方法，最终它的时间复杂度为：O(n^2)</p><p><img src="http://p.qpic.cn/pic_wework/1948211503/5b5d484b720be8d0e1d2e7cf5a8a485c0ed666692283b2b3/0" alt=""><br><img src="http://p.qpic.cn/pic_wework/1948211503/33352023608a66ea320f8e19136b58313127ff441c14650c/0" alt=""><br><strong>时间复杂度所耗费的时间是：</strong><br>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n2) &lt; O(n3) &lt;O(2n) &lt; O(n!) &lt;O(nn)</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统学习笔记</title>
      <link href="/2018/11/08/operating-system/"/>
      <url>/2018/11/08/operating-system/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>可以把操作系统比作是电脑上的“政府”，主要的只能是与硬件交互，管理资源。<br><strong>好的操作系统应有的特点：</strong>公平（资源分配上），高效，稳定，安全，方便。<br><strong>主要分类有：</strong>单处理器系统，所处理器系统，集群系统；嵌入式系统，多媒体系统；单任务系统，多任务系统……</p><h3 id="常见操作系统"><a href="#常见操作系统" class="headerlink" title="常见操作系统"></a>常见操作系统</h3><ol><li><p><strong>windows</strong>:Windows系列操作系统是微软公司在二十世纪九十年代研制成功的图形化工作界面操作系统，俗称“视窗”。<br>优点：</p><ul><li>易用性高，生态圈完善，兼容性高；</li><li>硬件丰富；</li><li>游戏娱乐性强；</li><li>图形化界面较为完善；<br>缺点：</li><li>安全性低；</li><li>系统漏洞较多；（因为是闭源的，参与测试的人少）</li><li>稳定性差；（蓝屏）</li></ul></li><li><p>Unix基础的操作系统，包含两个主要的部分：核心名为Darwin，是以FreeBSD源代码和Mach微核心为基础，由苹果公司和独立开发者社区协力开发；<br>优点：</p><ul><li>安全性高；</li><li>mac下没有很多win下多余的东西，没有磁盘碎片，不用整理硬盘，不用分区，几乎没有死机，不用关机，基本没用过进程管理器。所有和使用无关的东西，都被藏起来，用户很容易学习和使用；</li><li>设置简单；</li><li>稳定性高，BUG较少；<br>缺点：</li><li>兼容性差；（较windows而言，其实也不差）</li></ul></li><li><p><strong>Linux</strong>: Linux是一套免费使用和自由传播的类Unix操作系统，是一个多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。<br>优点：</p><ul><li>安全、易维护、稳定；</li><li>软件自由、开源；</li><li>低成本、低配置要求；<br>缺点：</li><li>应用软件较少；</li><li>图形界面不够好；</li></ul></li><li><p><strong>UNIX:</strong> UNIX是一个强大的多用户、多任务操作系统，支持多处理器架构、属于分时操作系统。<br>优点：</p><ul><li>开源；</li><li>将所有设备用文件标识，可使用与处理文件相同的<strong>命令</strong>和<strong>系统调用集</strong>访问设备。</li><li>具有可移植行。<br>缺点：</li><li>UNIX系统的标准I/O库相对其底层的系统调用接口已变得越来越复杂了。</li><li>传统的UNIX内核不够灵活，不具备很好的可扩充性。大部分代码也很难复用。</li></ul></li><li><p><strong>Android：</strong>Android是一种以Linux为基础的开放源代码的操作系统，主要用于便携式设备。<br>优点：</p><ul><li>开放性强、具有丰富的硬件选择。<br>缺点：</li><li>对硬件要求较高。</li><li>安全性较低。</li></ul></li><li><p><strong>iOS:</strong> iOS与苹果的Mac OS X操作系统一样，属于类Unix的商业操作系统。<br>优点：</p><ul><li>流畅的操作体验、丰富的应用程序、精美的系统界面、较高的安全性。<br>缺点：</li><li>系统封闭，权限控制严格，用户受限制多。</li></ul></li><li><p><strong>FreeBSD：</strong>FreeBSD是一种类UNIX操作系统，是由经过BSD、386BSD和4.4BSD发展而来的Unix的一个重要分支。FreeBSD 提供先进的网络、性能、安全以及兼容性，这些特性在其他现代操作系统上仍有所缺失，即使是一些最好的商业操作系统。<br>优点：</p><ul><li>强大的网络性能；</li><li>先进的嵌入式平台；</li><li>可以运行大量的程序；</li><li>易于安装及使用；</li><li>开源</li></ul></li></ol><ul><li><strong>VxWork：</strong>VxWorks操作系统是美国WindRiver公司于1983年设计开发的一种嵌入式实时操作系统(RTOS)，是嵌入式开发环境的关键组成部分。它以其良好的可靠性和卓越的实时性被广泛地应用在通信、军事、航空、航天等高精尖技术及实时性要求极高的领域中，如卫星通讯、军事演习、弹道制导、飞机导航等。<br>优点：<ul><li>稳定、可靠性；</li><li>实时性；</li><li>可裁剪行；</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
